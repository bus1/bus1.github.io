<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>The Internal Bus1 API</title><link rel="stylesheet" type="text/css" href="bus1.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="icon" href="bus1.png" type="image/png"><script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75729104-1', 'auto');
      ga('send', 'pageview');
    </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><header><a href="index.html"><img src="bus1.svg" alt="bus1" style="width:64px;height:64px;"></a><span class="version">Version 1</span></header><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="BUS1-API"></a>The Internal Bus1 API</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#intro">1. Bus1 Overview</a></span></dt><dt><span class="chapter"><a href="#peer">2. Bus1 Peer</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer"><span class="phrase">struct bus1_peer</span></a></span><span class="refpurpose"> — 
  peer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-acquire"><span class="phrase">bus1_peer_acquire</span></a></span><span class="refpurpose"> — 
     acquire active reference to peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-release"><span class="phrase">bus1_peer_release</span></a></span><span class="refpurpose"> — 
     release an active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-new"><span class="phrase">bus1_peer_new</span></a></span><span class="refpurpose"> — 
  allocate new peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-free"><span class="phrase">bus1_peer_free</span></a></span><span class="refpurpose"> — 
     destroy peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-ioctl"><span class="phrase">bus1_peer_ioctl</span></a></span><span class="refpurpose"> — 
     handle peer ioctls
 </span></dt></dl></dd><dt><span class="chapter"><a href="#message">3. Bus1 Message</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-factory"><span class="phrase">struct bus1_factory</span></a></span><span class="refpurpose"> — 
  message factory
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-message"><span class="phrase">struct bus1_message</span></a></span><span class="refpurpose"> — 
     data messages
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-ref"><span class="phrase">bus1_message_ref</span></a></span><span class="refpurpose"> — 
     acquire object reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-unref"><span class="phrase">bus1_message_unref</span></a></span><span class="refpurpose"> — 
     release object reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-factory-new"><span class="phrase">bus1_factory_new</span></a></span><span class="refpurpose"> — 
  create new message factory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-factory-free"><span class="phrase">bus1_factory_free</span></a></span><span class="refpurpose"> — 
     destroy message factory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-factory-seal"><span class="phrase">bus1_factory_seal</span></a></span><span class="refpurpose"> — 
     charge and commit local resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-factory-instantiate"><span class="phrase">bus1_factory_instantiate</span></a></span><span class="refpurpose"> — 
     instantiate a message from a factory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-free"><span class="phrase">bus1_message_free</span></a></span><span class="refpurpose"> — 
     destroy message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-stage"><span class="phrase">bus1_message_stage</span></a></span><span class="refpurpose"> — 
     stage message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-install"><span class="phrase">bus1_message_install</span></a></span><span class="refpurpose"> — 
     install message payload into target process
 </span></dt></dl></dd><dt><span class="chapter"><a href="#transaction">4. Bus1 Transaction</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-bus1-tx-bits"><span class="phrase">enum bus1_tx_bits</span></a></span><span class="refpurpose"> — 
  transaction flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-tx"><span class="phrase">struct bus1_tx</span></a></span><span class="refpurpose"> — 
     transaction context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-init"><span class="phrase">bus1_tx_init</span></a></span><span class="refpurpose"> — 
     initialize transaction context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-deinit"><span class="phrase">bus1_tx_deinit</span></a></span><span class="refpurpose"> — 
     deinitialize transaction context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-stage-sync"><span class="phrase">bus1_tx_stage_sync</span></a></span><span class="refpurpose"> — 
  stage message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-stage-later"><span class="phrase">bus1_tx_stage_later</span></a></span><span class="refpurpose"> — 
     postpone message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-join"><span class="phrase">bus1_tx_join</span></a></span><span class="refpurpose"> — 
     HIC SUNT DRACONES!
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-commit"><span class="phrase">bus1_tx_commit</span></a></span><span class="refpurpose"> — 
     commit transaction
 </span></dt></dl></dd><dt><span class="chapter"><a href="#handle">5. Bus1 Handle</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-bus1-handle-bits"><span class="phrase">enum bus1_handle_bits</span></a></span><span class="refpurpose"> — 
  node flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle"><span class="phrase">struct bus1_handle</span></a></span><span class="refpurpose"> — 
     object handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-is-anchor"><span class="phrase">bus1_handle_is_anchor</span></a></span><span class="refpurpose"> — 
     check whether handle is an anchor
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-is-live"><span class="phrase">bus1_handle_is_live</span></a></span><span class="refpurpose"> — 
     check whether handle is live
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-is-public"><span class="phrase">bus1_handle_is_public</span></a></span><span class="refpurpose"> — 
     check whether handle is public
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-ref"><span class="phrase">bus1_handle_ref</span></a></span><span class="refpurpose"> — 
     acquire object reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-unref"><span class="phrase">bus1_handle_unref</span></a></span><span class="refpurpose"> — 
     release object reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-acquire"><span class="phrase">bus1_handle_acquire</span></a></span><span class="refpurpose"> — 
     acquire weak/strong reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release"><span class="phrase">bus1_handle_release</span></a></span><span class="refpurpose"> — 
     release weak/strong reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release-n"><span class="phrase">bus1_handle_release_n</span></a></span><span class="refpurpose"> — 
     release multiple references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-new-anchor"><span class="phrase">bus1_handle_new_anchor</span></a></span><span class="refpurpose"> — 
  allocate new anchor handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-new-remote"><span class="phrase">bus1_handle_new_remote</span></a></span><span class="refpurpose"> — 
     allocate new remote handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-free"><span class="phrase">bus1_handle_free</span></a></span><span class="refpurpose"> — 
     free handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-acquire-owner"><span class="phrase">bus1_handle_acquire_owner</span></a></span><span class="refpurpose"> — 
     acquire owner of a handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-ref-by-other"><span class="phrase">bus1_handle_ref_by_other</span></a></span><span class="refpurpose"> — 
     lookup handle on a peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-acquire-locked"><span class="phrase">bus1_handle_acquire_locked</span></a></span><span class="refpurpose"> — 
     acquire strong reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-acquire-slow"><span class="phrase">bus1_handle_acquire_slow</span></a></span><span class="refpurpose"> — 
     slow-path of handle acquisition
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release-slow"><span class="phrase">bus1_handle_release_slow</span></a></span><span class="refpurpose"> — 
     slow-path of handle release
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-destroy-locked"><span class="phrase">bus1_handle_destroy_locked</span></a></span><span class="refpurpose"> — 
     stage node destruction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-is-live-at"><span class="phrase">bus1_handle_is_live_at</span></a></span><span class="refpurpose"> — 
     check whether handle is live at a given time
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-import"><span class="phrase">bus1_handle_import</span></a></span><span class="refpurpose"> — 
     import handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-identify"><span class="phrase">bus1_handle_identify</span></a></span><span class="refpurpose"> — 
     identify handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-export"><span class="phrase">bus1_handle_export</span></a></span><span class="refpurpose"> — 
     export handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-forget"><span class="phrase">bus1_handle_forget</span></a></span><span class="refpurpose"> — 
     forget handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-forget-keep"><span class="phrase">bus1_handle_forget_keep</span></a></span><span class="refpurpose"> — 
     forget handle but keep rb-tree order
 </span></dt></dl></dd><dt><span class="chapter"><a href="#user">6. Bus1 User</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-usage"><span class="phrase">struct bus1_user_usage</span></a></span><span class="refpurpose"> — 
  usage counters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-limits"><span class="phrase">struct bus1_user_limits</span></a></span><span class="refpurpose"> — 
     resource limit counters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user"><span class="phrase">struct bus1_user</span></a></span><span class="refpurpose"> — 
     resource accounting for users
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-modexit"><span class="phrase">bus1_user_modexit</span></a></span><span class="refpurpose"> — 
  clean up global resources of user accounting
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-limits-init"><span class="phrase">bus1_user_limits_init</span></a></span><span class="refpurpose"> — 
     initialize resource limit counter
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-limits-deinit"><span class="phrase">bus1_user_limits_deinit</span></a></span><span class="refpurpose"> — 
     deinitialize source limit counter
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref-by-uid"><span class="phrase">bus1_user_ref_by_uid</span></a></span><span class="refpurpose"> — 
     get a user object for a uid
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref"><span class="phrase">bus1_user_ref</span></a></span><span class="refpurpose"> — 
     acquire reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-unref"><span class="phrase">bus1_user_unref</span></a></span><span class="refpurpose"> — 
     release reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-charge"><span class="phrase">bus1_user_charge</span></a></span><span class="refpurpose"> — 
     charge a user resource
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-discharge"><span class="phrase">bus1_user_discharge</span></a></span><span class="refpurpose"> — 
     discharge a user resource
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-charge-quota"><span class="phrase">bus1_user_charge_quota</span></a></span><span class="refpurpose"> — 
     charge quota resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-discharge-quota"><span class="phrase">bus1_user_discharge_quota</span></a></span><span class="refpurpose"> — 
     discharge quota resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-commit-quota"><span class="phrase">bus1_user_commit_quota</span></a></span><span class="refpurpose"> — 
     commit quota resources
 </span></dt></dl></dd><dt><span class="chapter"><a href="#active">7. Bus1 Active Reference</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-active"><span class="phrase">struct bus1_active</span></a></span><span class="refpurpose"> — 
  active references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-acquire"><span class="phrase">bus1_active_acquire</span></a></span><span class="refpurpose"> — 
     acquire active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-release"><span class="phrase">bus1_active_release</span></a></span><span class="refpurpose"> — 
     release active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-init-private"><span class="phrase">bus1_active_init_private</span></a></span><span class="refpurpose"> — 
  initialize object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-deinit"><span class="phrase">bus1_active_deinit</span></a></span><span class="refpurpose"> — 
     destroy object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-is-new"><span class="phrase">bus1_active_is_new</span></a></span><span class="refpurpose"> — 
     check whether object is new
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-is-active"><span class="phrase">bus1_active_is_active</span></a></span><span class="refpurpose"> — 
     check whether object is active
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-is-deactivated"><span class="phrase">bus1_active_is_deactivated</span></a></span><span class="refpurpose"> — 
     check whether object was deactivated
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-is-drained"><span class="phrase">bus1_active_is_drained</span></a></span><span class="refpurpose"> — 
     check whether object is drained
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-activate"><span class="phrase">bus1_active_activate</span></a></span><span class="refpurpose"> — 
     activate object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-deactivate"><span class="phrase">bus1_active_deactivate</span></a></span><span class="refpurpose"> — 
     deactivate object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-drain"><span class="phrase">bus1_active_drain</span></a></span><span class="refpurpose"> — 
     drain active references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-cleanup"><span class="phrase">bus1_active_cleanup</span></a></span><span class="refpurpose"> — 
     cleanup drained object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-lockdep-acquired"><span class="phrase">bus1_active_lockdep_acquired</span></a></span><span class="refpurpose"> — 
     acquire lockdep reader
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-lockdep-released"><span class="phrase">bus1_active_lockdep_released</span></a></span><span class="refpurpose"> — 
     release lockdep reader
 </span></dt></dl></dd><dt><span class="chapter"><a href="#flist">8. Bus1 Fixed List</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-flist"><span class="phrase">struct bus1_flist</span></a></span><span class="refpurpose"> — 
  fixed list
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-inline-size"><span class="phrase">bus1_flist_inline_size</span></a></span><span class="refpurpose"> — 
     calculate required inline size
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-init"><span class="phrase">bus1_flist_init</span></a></span><span class="refpurpose"> — 
     initialize an flist
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-deinit"><span class="phrase">bus1_flist_deinit</span></a></span><span class="refpurpose"> — 
     deinitialize an flist
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-next"><span class="phrase">bus1_flist_next</span></a></span><span class="refpurpose"> — 
     flist iterator
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-walk"><span class="phrase">bus1_flist_walk</span></a></span><span class="refpurpose"> — 
     walk flist in batches
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-populate"><span class="phrase">bus1_flist_populate</span></a></span><span class="refpurpose"> — 
  populate an flist
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-new"><span class="phrase">bus1_flist_new</span></a></span><span class="refpurpose"> — 
     allocate new flist
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-free"><span class="phrase">bus1_flist_free</span></a></span><span class="refpurpose"> — 
     free flist
 </span></dt></dl></dd><dt><span class="chapter"><a href="#pool">9. Bus1 Pool</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool-slice"><span class="phrase">struct bus1_pool_slice</span></a></span><span class="refpurpose"> — 
  pool slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool"><span class="phrase">struct bus1_pool</span></a></span><span class="refpurpose"> — 
     client pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-slice-is-public"><span class="phrase">bus1_pool_slice_is_public</span></a></span><span class="refpurpose"> — 
     check whether a slice is public
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-init"><span class="phrase">bus1_pool_init</span></a></span><span class="refpurpose"> — 
  create memory pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-deinit"><span class="phrase">bus1_pool_deinit</span></a></span><span class="refpurpose"> — 
     destroy pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-alloc"><span class="phrase">bus1_pool_alloc</span></a></span><span class="refpurpose"> — 
     allocate memory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-kernel"><span class="phrase">bus1_pool_release_kernel</span></a></span><span class="refpurpose"> — 
     release kernel-owned slice reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-publish"><span class="phrase">bus1_pool_publish</span></a></span><span class="refpurpose"> — 
     publish a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-user"><span class="phrase">bus1_pool_release_user</span></a></span><span class="refpurpose"> — 
     release a public slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-flush"><span class="phrase">bus1_pool_flush</span></a></span><span class="refpurpose"> — 
     flush all user references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-mmap"><span class="phrase">bus1_pool_mmap</span></a></span><span class="refpurpose"> — 
     mmap the pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-iovec"><span class="phrase">bus1_pool_write_iovec</span></a></span><span class="refpurpose"> — 
     copy user memory to a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-kvec"><span class="phrase">bus1_pool_write_kvec</span></a></span><span class="refpurpose"> — 
     copy kernel memory to a slice
 </span></dt></dl></dd><dt><span class="chapter"><a href="#queue">10. Bus1 Queue</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue-node"><span class="phrase">struct bus1_queue_node</span></a></span><span class="refpurpose"> — 
  node into message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue"><span class="phrase">struct bus1_queue</span></a></span><span class="refpurpose"> — 
     message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-init"><span class="phrase">bus1_queue_node_init</span></a></span><span class="refpurpose"> — 
     initialize queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-deinit"><span class="phrase">bus1_queue_node_deinit</span></a></span><span class="refpurpose"> — 
     destroy queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-type"><span class="phrase">bus1_queue_node_get_type</span></a></span><span class="refpurpose"> — 
     query node type
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-timestamp"><span class="phrase">bus1_queue_node_get_timestamp</span></a></span><span class="refpurpose"> — 
     query node timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-queued"><span class="phrase">bus1_queue_node_is_queued</span></a></span><span class="refpurpose"> — 
     check whether a node is queued
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-staging"><span class="phrase">bus1_queue_node_is_staging</span></a></span><span class="refpurpose"> — 
     check whether a node is marked staging
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-tick"><span class="phrase">bus1_queue_tick</span></a></span><span class="refpurpose"> — 
     increment queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-sync"><span class="phrase">bus1_queue_sync</span></a></span><span class="refpurpose"> — 
     sync queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-is-readable-rcu"><span class="phrase">bus1_queue_is_readable_rcu</span></a></span><span class="refpurpose"> — 
     check whether a queue is readable
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-compare"><span class="phrase">bus1_queue_compare</span></a></span><span class="refpurpose"> — 
     comparator for queue ordering
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-init"><span class="phrase">bus1_queue_init</span></a></span><span class="refpurpose"> — 
  initialize queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-deinit"><span class="phrase">bus1_queue_deinit</span></a></span><span class="refpurpose"> — 
     destroy queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-flush"><span class="phrase">bus1_queue_flush</span></a></span><span class="refpurpose"> — 
     flush message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-stage"><span class="phrase">bus1_queue_stage</span></a></span><span class="refpurpose"> — 
     stage queue entry with fresh timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-staged"><span class="phrase">bus1_queue_commit_staged</span></a></span><span class="refpurpose"> — 
     commit staged queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-unstaged"><span class="phrase">bus1_queue_commit_unstaged</span></a></span><span class="refpurpose"> — 
     commit unstaged queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-synthetic"><span class="phrase">bus1_queue_commit_synthetic</span></a></span><span class="refpurpose"> — 
     commit synthetic entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-remove"><span class="phrase">bus1_queue_remove</span></a></span><span class="refpurpose"> — 
     remove entry from queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-peek"><span class="phrase">bus1_queue_peek</span></a></span><span class="refpurpose"> — 
     peek first available entry
 </span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="intro"></a>Chapter 1. Bus1 Overview</h1></div></div></div><p>
   </p><p>
   bus1 is a local IPC system, which provides a decentralized infrastructure to
   share objects between local peers. The main building blocks are nodes and
   handles. Nodes represent objects of a local peer, while handles represent
   descriptors that point to a node. Nodes can be created and destroyed by any
   peer, and they will always remain owned by their respective creator. Handles,
   on the other hand, are used to refer to nodes and can be passed around with
   messages as auxiliary data. Whenever a handle is transferred, the receiver
   will get its own handle allocated, pointing to the same node as the original
   handle.
   </p><p>
   Any peer can send messages directed at one of their handles. This will
   transfer the message to the owner of the node the handle points to. If a
   peer does not posess a handle to a given node, it will not be able to send a
   message to that node. That is, handles provide exclusive access management.
   Anyone that somehow acquired a handle to a node is privileged to further
   send this handle to other peers. As such, access management is transitive.
   Once a peer acquired a handle, it cannot be revoked again. However, a node
   owner can, at anytime, destroy a node. This will effectively unbind all
   existing handles to that node on any peer, notifying each one of the
   destruction.
   </p><p>
   Unlike nodes and handles, peers cannot be addressed directly. In fact, peers
   are completely disconnected entities. A peer is merely an anchor of a set of
   nodes and handles, including an incoming message queue for any of those.
   Whether multiple nodes are all part of the same peer, or part of different
   peers does not affect the remote view of those. Peers solely exist as
   management entity and command dispatcher to local processes.
   </p><p>
   The set of actors on a system is completely decentralized. There is no
   global component involved that provides a central registry or discovery
   mechanism. Furthermore, communication between peers only involves those
   peers, and does not affect any other peer in any way. No global
   communication lock is taken. However, any communication is still globally
   ordered, including unicasts, multicasts, and notifications.
</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="peer"></a>Chapter 2. Bus1 Peer</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer"><span class="phrase">struct bus1_peer</span></a></span><span class="refpurpose"> — 
  peer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-acquire"><span class="phrase">bus1_peer_acquire</span></a></span><span class="refpurpose"> — 
     acquire active reference to peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-release"><span class="phrase">bus1_peer_release</span></a></span><span class="refpurpose"> — 
     release an active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-new"><span class="phrase">bus1_peer_new</span></a></span><span class="refpurpose"> — 
  allocate new peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-free"><span class="phrase">bus1_peer_free</span></a></span><span class="refpurpose"> — 
     destroy peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-ioctl"><span class="phrase">bus1_peer_ioctl</span></a></span><span class="refpurpose"> — 
     handle peer ioctls
 </span></dt></dl></div><p>
   </p><p>
   A peer context provides access to the bus1 system. A peer itself is not a
   routable entity, but rather only a local anchor to serve as gateway to the
   bus. To participate on the bus, you need to allocate a peer. This peer
   manages all your state on the bus, including all allocated nodes, owned
   handles, incoming messages, and more.
   </p><p>
   A peer is split into 3 sections:
   - A static section that is initialized at peer creation and never changes
   - A peer-local section that is only ever accessed by ioctls done by the
   peer itself.
   - A data section that might be accessed by remote peers when interacting
   with this peer.
   </p><p>
   All peers on the system operate on the same level. There is no context a
   peer is linked into. Hence, you can never lock multiple peers at the same
   time. Instead, peers provide active-references. Before performing an
   operation on a peer, an active reference must be acquired, and hold as long
   as the operation goes on. When done, the reference is released again.
   When a peer is disconnected, no more active references can be acquired, and
   any outstanding operation is waited for before the peer is destroyed.
   </p><p>
   Additionally to active-references, there are 2 locks: A peer-local lock and
   a data lock. The peer-local lock is used to synchronize operations done by
   the peer itself. It is never acquired by a remote peer. The data lock
   protects the data of the peer, which might be modified by remote peers. The
   data lock nests underneath the local-lock. Furthermore, the data-lock
   critical sections must be kept small and never block indefinitely. Remote
   peers might wait for data-locks, hence they must rely on not being DoSed.
   The local peer lock, however, is private to the peer itself. Not such
   restrictions apply. It is mostly used to give the impression of atomic
   operations (i.e., making the API appear consistent and coherent).
</p><div class="refentry"><a name="API-struct-bus1-peer"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_peer — 
  peer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_peer {
  u64 id;
  u64 flags;
  const struct cred * cred;
  struct pid_namespace * pid_ns;
  struct bus1_user * user;
  struct rcu_head rcu;
  wait_queue_head_t waitq;
  struct bus1_active active;
  struct dentry * debugdir;
};  </pre></div><div class="refsect1"><a name="id-1.4.7.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">id</span></dt><dd><p>
peer ID
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
peer flags
      </p></dd><dt><span class="term">cred</span></dt><dd><p>
pinned credentials
      </p></dd><dt><span class="term">pid_ns</span></dt><dd><p>
pinned pid-namespace
      </p></dd><dt><span class="term">user</span></dt><dd><p>
pinned user
      </p></dd><dt><span class="term">rcu</span></dt><dd><p>
rcu-delayed kfree of peer
      </p></dd><dt><span class="term">waitq</span></dt><dd><p>
peer wide wait queue
      </p></dd><dt><span class="term">active</span></dt><dd><p>
active references
      </p></dd><dt><span class="term">debugdir</span></dt><dd><p>
debugfs root of this peer, or NULL/ERR_PTR
<em class="parameter"><code>data</code></em>.lock:			data lock
<em class="parameter"><code>data</code></em>.pool:			data pool
<em class="parameter"><code>data</code></em>.queue:			message queue
<em class="parameter"><code>data</code></em>.limits:		resource limit counter
<em class="parameter"><code>local</code></em>.lock:			local peer runtime lock
<em class="parameter"><code>local</code></em>.seed:			pinned seed message
<em class="parameter"><code>local</code></em>.map_handles:		map of owned handles (by handle ID)
<em class="parameter"><code>local</code></em>.handle_ids:		handle ID allocator
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-acquire"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_acquire — 
     acquire active reference to peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_acquire </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.8.6"></a><h2>Description</h2><p>
   Acquire a new active reference to the given peer. If the peer was not
   activated yet, or if it was already deactivated, this will fail.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.4.8.7"></a><h2>Return</h2><p>
   Pointer to peer, NULL on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-release"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_release — 
     release an active reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_release </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     handle to release, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.9.6"></a><h2>Description</h2><p>
   This releases an active reference to a peer, acquired previously via
   <code class="function">bus1_peer_acquire</code>.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.4.9.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-new"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_new — 
  allocate new peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_new </b>(</code> <var class="pdparam">void</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>void</code></em></span></dt><dd><p>
     no arguments
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.10.6"></a><h2>Description</h2><p>
   </p><p>

   Allocate a new peer. It is immediately activated and ready for use. It is
   not linked into any context. The caller will get exclusively access to the
   peer object on success.
   </p><p>

   Note that the peer is opened on behalf of 'current'. That is, it pins its
   credentials and namespaces.
</p></div><div class="refsect1"><a name="id-1.4.10.7"></a><h2>Return</h2><p>
   Pointer to peer, ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_free — 
     destroy peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_free </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.11.6"></a><h2>Description</h2><p>
   Destroy a peer object that was previously allocated via <code class="function">bus1_peer_new</code>.
   This synchronously waits for any outstanding operations on this peer to
   finish, then releases all linked resources and deallocates the peer in an
   rcu-delayed manner.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.4.11.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-ioctl"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_ioctl — 
     handle peer ioctls
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">long <b class="fsfunc">bus1_peer_ioctl </b>(</code>struct file * <var class="pdparam">file</var>, unsigned int <var class="pdparam">cmd</var>, unsigned long <var class="pdparam">arg</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>file</code></em></span></dt><dd><p>
     file the ioctl is called on
    </p></dd><dt><span class="term"><em class="parameter"><code>cmd</code></em></span></dt><dd><p>
     ioctl command
    </p></dd><dt><span class="term"><em class="parameter"><code>arg</code></em></span></dt><dd><p>
     ioctl argument
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.12.6"></a><h2>Description</h2><p>
   This handles the given ioctl (cmd+arg) on a peer. This expects the peer to
   be stored in the private_data field of <em class="parameter"><code>file</code></em>.
   </p><p>

   Multiple ioctls can be called in parallel just fine. No locking is needed.
</p></div><div class="refsect1"><a name="id-1.4.12.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="message"></a>Chapter 3. Bus1 Message</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-factory"><span class="phrase">struct bus1_factory</span></a></span><span class="refpurpose"> — 
  message factory
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-message"><span class="phrase">struct bus1_message</span></a></span><span class="refpurpose"> — 
     data messages
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-ref"><span class="phrase">bus1_message_ref</span></a></span><span class="refpurpose"> — 
     acquire object reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-unref"><span class="phrase">bus1_message_unref</span></a></span><span class="refpurpose"> — 
     release object reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-factory-new"><span class="phrase">bus1_factory_new</span></a></span><span class="refpurpose"> — 
  create new message factory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-factory-free"><span class="phrase">bus1_factory_free</span></a></span><span class="refpurpose"> — 
     destroy message factory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-factory-seal"><span class="phrase">bus1_factory_seal</span></a></span><span class="refpurpose"> — 
     charge and commit local resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-factory-instantiate"><span class="phrase">bus1_factory_instantiate</span></a></span><span class="refpurpose"> — 
     instantiate a message from a factory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-free"><span class="phrase">bus1_message_free</span></a></span><span class="refpurpose"> — 
     destroy message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-stage"><span class="phrase">bus1_message_stage</span></a></span><span class="refpurpose"> — 
     stage message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-install"><span class="phrase">bus1_message_install</span></a></span><span class="refpurpose"> — 
     install message payload into target process
 </span></dt></dl></div><p>
   </p><p>
   XXX
</p><div class="refentry"><a name="API-struct-bus1-factory"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_factory — 
  message factory
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_factory {
  struct bus1_peer * peer;
  struct bus1_cmd_send * param;
  const struct cred * cred;
  struct pid * pid;
  struct pid * tid;
  bool on_stack:1;
  bool has_secctx:1;
  size_t length_vecs;
  size_t n_vecs;
  size_t n_handles;
  size_t n_handles_charge;
  size_t n_files;
  u32 n_secctx;
  struct iovec * vecs;
  struct file ** files;
  char * secctx;
  struct bus1_flist handles[];
};  </pre></div><div class="refsect1"><a name="id-1.5.4.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">peer</span></dt><dd><p>
sending peer
      </p></dd><dt><span class="term">param</span></dt><dd><p>
factory parameters
      </p></dd><dt><span class="term">cred</span></dt><dd><p>
sender credentials
      </p></dd><dt><span class="term">pid</span></dt><dd><p>
sender PID
      </p></dd><dt><span class="term">tid</span></dt><dd><p>
sender TID
      </p></dd><dt><span class="term">on_stack</span></dt><dd><p>
whether object lives on stack
      </p></dd><dt><span class="term">has_secctx</span></dt><dd><p>
whether secctx has been set
      </p></dd><dt><span class="term">length_vecs</span></dt><dd><p>
total length of data in vectors
      </p></dd><dt><span class="term">n_vecs</span></dt><dd><p>
number of vectors
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
number of handles
      </p></dd><dt><span class="term">n_handles_charge</span></dt><dd><p>
number of handles to charge on commit
      </p></dd><dt><span class="term">n_files</span></dt><dd><p>
number of files
      </p></dd><dt><span class="term">n_secctx</span></dt><dd><p>
length of secctx
      </p></dd><dt><span class="term">vecs</span></dt><dd><p>
vector array
      </p></dd><dt><span class="term">files</span></dt><dd><p>
file array
      </p></dd><dt><span class="term">secctx</span></dt><dd><p>
allocated secctx
      </p></dd><dt><span class="term">handles[]</span></dt><dd><p>
handle array
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-message"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_message — 
     data messages
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_message {
  struct kref ref;
  struct bus1_queue_node qnode;
  struct bus1_handle * dst;
  struct bus1_user * user;
  u64 flags;
  uid_t uid;
  gid_t gid;
  pid_t pid;
  pid_t tid;
  size_t n_bytes;
  size_t n_handles;
  size_t n_handles_charge;
  size_t n_files;
  size_t n_secctx;
  struct bus1_pool_slice * slice;
  struct file ** files;
  struct bus1_flist handles[];
};  </pre></div><div class="refsect1"><a name="id-1.5.5.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">ref</span></dt><dd><p>
   reference counter
      </p></dd><dt><span class="term">qnode</span></dt><dd><p>
   embedded queue node
      </p></dd><dt><span class="term">dst</span></dt><dd><p>
   destination handle
      </p></dd><dt><span class="term">user</span></dt><dd><p>
   sending user
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
   message flags
      </p></dd><dt><span class="term">uid</span></dt><dd><p>
   sender UID
      </p></dd><dt><span class="term">gid</span></dt><dd><p>
   sender GID
      </p></dd><dt><span class="term">pid</span></dt><dd><p>
   sender PID
      </p></dd><dt><span class="term">tid</span></dt><dd><p>
   sender TID
      </p></dd><dt><span class="term">n_bytes</span></dt><dd><p>
   number of user-bytes transmitted
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
   number of handles transmitted
      </p></dd><dt><span class="term">n_handles_charge</span></dt><dd><p>
   number of handle charges
      </p></dd><dt><span class="term">n_files</span></dt><dd><p>
   number of files transmitted
      </p></dd><dt><span class="term">n_secctx</span></dt><dd><p>
   number of bytes of security context transmitted
      </p></dd><dt><span class="term">slice</span></dt><dd><p>
   actual message data
      </p></dd><dt><span class="term">files</span></dt><dd><p>
   passed file descriptors
      </p></dd><dt><span class="term">handles[]</span></dt><dd><p>
   passed handles
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-ref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_ref — 
     acquire object reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_ref </b>(</code>struct bus1_message * <var class="pdparam">m</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.6.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>m</code></em></span></dt><dd><p>
     message to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.6.6"></a><h2>Description</h2><p>
   This acquires a single reference to <em class="parameter"><code>m</code></em>. The caller must already hold a
   reference when calling this.
   </p><p>

   If <em class="parameter"><code>m</code></em> is NULL, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.5.6.7"></a><h2>Return</h2><p>
   <em class="parameter"><code>m</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-unref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_unref — 
     release object reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_unref </b>(</code>struct bus1_message * <var class="pdparam">m</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.7.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>m</code></em></span></dt><dd><p>
     message to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.7.6"></a><h2>Description</h2><p>
   This releases a single object reference to <em class="parameter"><code>m</code></em>. If the reference counter
   drops to 0, the message is destroyed.
   </p><p>

   If <em class="parameter"><code>m</code></em> is NULL, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.5.7.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-factory-new"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_factory_new — 
  create new message factory
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_factory * <b class="fsfunc">bus1_factory_new </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, struct bus1_cmd_send * <var class="pdparam">param</var>, void * <var class="pdparam">stack</var>, size_t <var class="pdparam">n_stack</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate as
    </p></dd><dt><span class="term"><em class="parameter"><code>param</code></em></span></dt><dd><p>
     factory parameters
    </p></dd><dt><span class="term"><em class="parameter"><code>stack</code></em></span></dt><dd><p>
     optional stack for factory, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>n_stack</code></em></span></dt><dd><p>
     size of space at <em class="parameter"><code>stack</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.8.6"></a><h2>Description</h2><p>
   This allocates a new message factory. It imports data from <em class="parameter"><code>param</code></em> and
   prepares the factory for a transaction. From this factory, messages can be
   instantiated. This is used both for unicasts and multicasts.
   </p><p>

   If <em class="parameter"><code>stack</code></em> is given, this tries to place the factory on the specified stack
   space. The caller must guarantee that the factory does not outlive the stack
   frame. If this is not wanted, pass 0 as <em class="parameter"><code>n_stack</code></em>.
   In either case, if the stack frame is too small, this will allocate the
   factory on the heap.
</p></div><div class="refsect1"><a name="id-1.5.8.7"></a><h2>Return</h2><p>
   Pointer to factory, or ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-factory-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_factory_free — 
     destroy message factory
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_factory * <b class="fsfunc">bus1_factory_free </b>(</code>struct bus1_factory * <var class="pdparam">f</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>f</code></em></span></dt><dd><p>
     factory to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.9.6"></a><h2>Description</h2><p>
   This destroys the message factory <em class="parameter"><code>f</code></em>, previously created via
   <code class="function">bus1_factory_new</code>. All pinned resources are freed. Messages created via the
   factory are unaffected.
   </p><p>

   If <em class="parameter"><code>f</code></em> is NULL, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.5.9.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-factory-seal"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_factory_seal — 
     charge and commit local resources
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_factory_seal </b>(</code>struct bus1_factory * <var class="pdparam">f</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>f</code></em></span></dt><dd><p>
     factory to use
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.10.6"></a><h2>Description</h2><p>
   The factory needs to pin and possibly create local peer resources. This
   commits those resources. You should call this after you instantiated all
   messages, since you cannot undo it easily.
</p></div><div class="refsect1"><a name="id-1.5.10.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-factory-instantiate"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_factory_instantiate — 
     instantiate a message from a factory
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_factory_instantiate </b>(</code>struct bus1_factory * <var class="pdparam">f</var>, struct bus1_handle * <var class="pdparam">handle</var>, struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>f</code></em></span></dt><dd><p>
     factory to use
    </p></dd><dt><span class="term"><em class="parameter"><code>handle</code></em></span></dt><dd><p>
     destination handle
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     destination peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.11.6"></a><h2>Description</h2><p>
   This instantiates a new message targetted at <em class="parameter"><code>handle</code></em>, based on the plans in
   the message factory <em class="parameter"><code>f</code></em>.
   </p><p>

   The newly created message is not linked into any contexts, but is available
   for free use to the caller.
</p></div><div class="refsect1"><a name="id-1.5.11.7"></a><h2>Return</h2><p>
   Pointer to new message, or ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_free — 
     destroy message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_message_free </b>(</code>struct kref * <var class="pdparam">k</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>k</code></em></span></dt><dd><p>
     kref belonging to a message
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.12.6"></a><h2>Description</h2><p>
   This frees the message belonging to the reference counter <em class="parameter"><code>k</code></em>. It is supposed
   to be used with <code class="function">kref_put</code>. See <code class="function">bus1_message_unref</code>. Like all queue nodes,
   the memory deallocation is rcu-delayed.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-stage"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_stage — 
     stage message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_message_stage </b>(</code>struct bus1_message * <var class="pdparam">m</var>, struct bus1_tx * <var class="pdparam">tx</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>m</code></em></span></dt><dd><p>
     message to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>tx</code></em></span></dt><dd><p>
     transaction to stage on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.13.6"></a><h2>Description</h2><p>
   This acquires all resources of the message <em class="parameter"><code>m</code></em> and then stages the message on
   <em class="parameter"><code>tx</code></em>. Like all stage operations, this cannot be undone. Hence, you must make
   sure you can continue to commit the transaction without erroring-out in
   between.
   </p><p>

   This consumes the caller's reference on <em class="parameter"><code>m</code></em>, plus the active reference on the
   destination peer.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-install"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_install — 
     install message payload into target process
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_message_install </b>(</code>struct bus1_message * <var class="pdparam">m</var>, struct bus1_cmd_recv * <var class="pdparam">param</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>m</code></em></span></dt><dd><p>
     message to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>param</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.14.6"></a><h2>Description</h2><p>
   This installs the payload FDs and handles of <em class="parameter"><code>message</code></em> into the receiving
   peer and the calling process. Handles are always installed, FDs are only
   installed if explicitly requested via <em class="parameter"><code>param</code></em>.
</p></div><div class="refsect1"><a name="id-1.5.14.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="transaction"></a>Chapter 4. Bus1 Transaction</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-enum-bus1-tx-bits"><span class="phrase">enum bus1_tx_bits</span></a></span><span class="refpurpose"> — 
  transaction flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-tx"><span class="phrase">struct bus1_tx</span></a></span><span class="refpurpose"> — 
     transaction context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-init"><span class="phrase">bus1_tx_init</span></a></span><span class="refpurpose"> — 
     initialize transaction context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-deinit"><span class="phrase">bus1_tx_deinit</span></a></span><span class="refpurpose"> — 
     deinitialize transaction context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-stage-sync"><span class="phrase">bus1_tx_stage_sync</span></a></span><span class="refpurpose"> — 
  stage message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-stage-later"><span class="phrase">bus1_tx_stage_later</span></a></span><span class="refpurpose"> — 
     postpone message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-join"><span class="phrase">bus1_tx_join</span></a></span><span class="refpurpose"> — 
     HIC SUNT DRACONES!
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-tx-commit"><span class="phrase">bus1_tx_commit</span></a></span><span class="refpurpose"> — 
     commit transaction
 </span></dt></dl></div><p>
   </p><p>
   The transaction engine is an object that lives an the stack and is used to
   stage and commit multicasts properly. Unlike unicasts, a multicast cannot
   just be queued on each destination, but must be properly synchronized. This
   requires us to first stage each message on their respective destination,
   then sync and tick the clocks, and eventual commit all messages.
</p><div class="refentry"><a name="API-enum-bus1-tx-bits"></a><div class="titlepage"></div><div class="refnamediv"><p>enum bus1_tx_bits — 
  transaction flags
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
enum bus1_tx_bits {
  BUS1_TX_BIT_SEALED
};  </pre></div><div class="refsect1"><a name="id-1.6.4.5"></a><h2>Constants</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">BUS1_TX_BIT_SEALED</span></dt><dd><p>
The transaction is sealed, no new messages can
be added to the transaction. The commit of all
staged messages is ongoing.
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-tx"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_tx — 
     transaction context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_tx {
  struct bus1_peer * origin;
  struct bus1_queue_node * sync;
  struct bus1_queue_node * async;
  struct bus1_queue_node * postponed;
  unsigned long flags;
  u64 timestamp;
  u64 async_ts;
};  </pre></div><div class="refsect1"><a name="id-1.6.5.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">origin</span></dt><dd><p>
   origin of this transaction
      </p></dd><dt><span class="term">sync</span></dt><dd><p>
   unlocked list of staged messages
      </p></dd><dt><span class="term">async</span></dt><dd><p>
   locked list of staged messages
      </p></dd><dt><span class="term">postponed</span></dt><dd><p>
   unlocked list of unstaged messages
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
   transaction flags
      </p></dd><dt><span class="term">timestamp</span></dt><dd><p>
   unlocked timestamp of this transaction
      </p></dd><dt><span class="term">async_ts</span></dt><dd><p>
   locked timestamp cache of async list
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-tx-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_tx_init — 
     initialize transaction context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_tx_init </b>(</code>struct bus1_tx * <var class="pdparam">tx</var>, struct bus1_peer * <var class="pdparam">origin</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.6.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>tx</code></em></span></dt><dd><p>
     transaction context to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>origin</code></em></span></dt><dd><p>
     origin of this transaction
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.6.6"></a><h2>Description</h2><p>
   This initializes a transaction context. The initiating peer must be pinned
   by the caller for the entire lifetime of <em class="parameter"><code>tx</code></em> (until <code class="function">bus1_tx_deinit</code> is
   called) and given as <em class="parameter"><code>origin</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-tx-deinit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_tx_deinit — 
     deinitialize transaction context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_tx_deinit </b>(</code>struct bus1_tx * <var class="pdparam">tx</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.7.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>tx</code></em></span></dt><dd><p>
     transaction context to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.7.6"></a><h2>Description</h2><p>
   This deinitializes a transaction context previously created via
   <code class="function">bus1_tx_init</code>. This is merely for debugging, as no resources are pinned on
   the transaction. However, if any message was staged on the transaction, it
   must be committed via <code class="function">bus1_tx_commit</code> before it is deinitialized.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-tx-stage-sync"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_tx_stage_sync — 
  stage message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_tx_stage_sync </b>(</code>struct bus1_tx * <var class="pdparam">tx</var>, struct bus1_queue_node * <var class="pdparam">qnode</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>tx</code></em></span></dt><dd><p>
     transaction to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>qnode</code></em></span></dt><dd><p>
     message to stage
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.8.6"></a><h2>Description</h2><p>
   This stages <em class="parameter"><code>qnode</code></em> on the transaction <em class="parameter"><code>tx</code></em>. It is an error to call this on a
   qnode that is already staged. The caller must set qnode-&gt;owner to the
   destination peer and acquire it. If it is NULL, it is assumed to be the same
   as the origin of the transaction.
   </p><p>

   The caller must hold the data-lock of the destination peer.
   </p><p>

   This consumes <em class="parameter"><code>qnode</code></em>. The caller must increment the required reference
   counts to make sure <em class="parameter"><code>qnode</code></em> does not vanish.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-tx-stage-later"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_tx_stage_later — 
     postpone message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_tx_stage_later </b>(</code>struct bus1_tx * <var class="pdparam">tx</var>, struct bus1_queue_node * <var class="pdparam">qnode</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>tx</code></em></span></dt><dd><p>
     transaction to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>qnode</code></em></span></dt><dd><p>
     message to postpone
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.9.6"></a><h2>Description</h2><p>
   This queues <em class="parameter"><code>qnode</code></em> on <em class="parameter"><code>tx</code></em>, but does not stage it. It will be staged just
   before the transaction is committed. This can be used over
   <code class="function">bus1_tx_stage_sync</code> if no immediate staging is necessary, or if required
   locks cannot be taken.
   </p><p>

   It is a caller-error if <em class="parameter"><code>qnode</code></em> is already part of a transaction.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-tx-join"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_tx_join — 
     HIC SUNT DRACONES!
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_tx_join </b>(</code>struct bus1_queue_node * <var class="pdparam">whom</var>, struct bus1_queue_node * <var class="pdparam">qnode</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>whom</code></em></span></dt><dd><p>
     whom to join
    </p></dd><dt><span class="term"><em class="parameter"><code>qnode</code></em></span></dt><dd><p>
     who joins
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.10.6"></a><h2>Description</h2><p>
   This makes <em class="parameter"><code>qnode</code></em> join the on-going transaction of <em class="parameter"><code>whom</code></em>. That is, it is
   semantically equivalent of calling:
   </p><p>

   bus1_tx_stage_sync(whom-&gt;group, qnode);
   </p><p>

   However, you can only dereference whom-&gt;group while it is still ongoing.
   Once committed, it might be a stale pointer. This function safely checks for
   the required conditions and bails out if too late.
   </p><p>

   The caller must hold the data locks of both peers (target of <em class="parameter"><code>whom</code></em> and
   <em class="parameter"><code>qnode</code></em>). <em class="parameter"><code>node</code></em>-&gt;owner must not be NULL! Furthermore, <em class="parameter"><code>qnode</code></em> must not be
   staged into any transaction, yet.
   </p><p>

   In general, this function is not what you want. There is no guarantee that
   you can join the transaction, hence a negative return value must be expected
   by the caller and handled gracefully. In that case, this function guarantees
   that the clock of the holder of <em class="parameter"><code>qnode</code></em> is synced with the transaction of
   <em class="parameter"><code>whom</code></em>, and as such is correctly ordered against the transaction.
   </p><p>

   If this function returns <span class="quote">“<span class="quote">false</span>”</span>, you must settle on the transaction before
   visibly reacting to it. That is, user-space must not see that you failed to
   join the transaction before the transaction is settled!
</p></div><div class="refsect1"><a name="id-1.6.10.7"></a><h2>Return</h2><p>
   True if successfull, false if too late.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-tx-commit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_tx_commit — 
     commit transaction
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_tx_commit </b>(</code>struct bus1_tx * <var class="pdparam">tx</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>tx</code></em></span></dt><dd><p>
     transaction to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.11.6"></a><h2>Description</h2><p>
   Commit a transaction. First all postponed entries are staged, then we commit
   all messages that belong to this transaction. This works with any number of
   messages.
</p></div><div class="refsect1"><a name="id-1.6.11.7"></a><h2>Return</h2><p>
   This returns the commit timestamp used.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="handle"></a>Chapter 5. Bus1 Handle</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-enum-bus1-handle-bits"><span class="phrase">enum bus1_handle_bits</span></a></span><span class="refpurpose"> — 
  node flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle"><span class="phrase">struct bus1_handle</span></a></span><span class="refpurpose"> — 
     object handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-is-anchor"><span class="phrase">bus1_handle_is_anchor</span></a></span><span class="refpurpose"> — 
     check whether handle is an anchor
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-is-live"><span class="phrase">bus1_handle_is_live</span></a></span><span class="refpurpose"> — 
     check whether handle is live
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-is-public"><span class="phrase">bus1_handle_is_public</span></a></span><span class="refpurpose"> — 
     check whether handle is public
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-ref"><span class="phrase">bus1_handle_ref</span></a></span><span class="refpurpose"> — 
     acquire object reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-unref"><span class="phrase">bus1_handle_unref</span></a></span><span class="refpurpose"> — 
     release object reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-acquire"><span class="phrase">bus1_handle_acquire</span></a></span><span class="refpurpose"> — 
     acquire weak/strong reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release"><span class="phrase">bus1_handle_release</span></a></span><span class="refpurpose"> — 
     release weak/strong reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release-n"><span class="phrase">bus1_handle_release_n</span></a></span><span class="refpurpose"> — 
     release multiple references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-new-anchor"><span class="phrase">bus1_handle_new_anchor</span></a></span><span class="refpurpose"> — 
  allocate new anchor handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-new-remote"><span class="phrase">bus1_handle_new_remote</span></a></span><span class="refpurpose"> — 
     allocate new remote handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-free"><span class="phrase">bus1_handle_free</span></a></span><span class="refpurpose"> — 
     free handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-acquire-owner"><span class="phrase">bus1_handle_acquire_owner</span></a></span><span class="refpurpose"> — 
     acquire owner of a handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-ref-by-other"><span class="phrase">bus1_handle_ref_by_other</span></a></span><span class="refpurpose"> — 
     lookup handle on a peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-acquire-locked"><span class="phrase">bus1_handle_acquire_locked</span></a></span><span class="refpurpose"> — 
     acquire strong reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-acquire-slow"><span class="phrase">bus1_handle_acquire_slow</span></a></span><span class="refpurpose"> — 
     slow-path of handle acquisition
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release-slow"><span class="phrase">bus1_handle_release_slow</span></a></span><span class="refpurpose"> — 
     slow-path of handle release
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-destroy-locked"><span class="phrase">bus1_handle_destroy_locked</span></a></span><span class="refpurpose"> — 
     stage node destruction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-is-live-at"><span class="phrase">bus1_handle_is_live_at</span></a></span><span class="refpurpose"> — 
     check whether handle is live at a given time
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-import"><span class="phrase">bus1_handle_import</span></a></span><span class="refpurpose"> — 
     import handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-identify"><span class="phrase">bus1_handle_identify</span></a></span><span class="refpurpose"> — 
     identify handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-export"><span class="phrase">bus1_handle_export</span></a></span><span class="refpurpose"> — 
     export handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-forget"><span class="phrase">bus1_handle_forget</span></a></span><span class="refpurpose"> — 
     forget handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-forget-keep"><span class="phrase">bus1_handle_forget_keep</span></a></span><span class="refpurpose"> — 
     forget handle but keep rb-tree order
 </span></dt></dl></div><p>
   </p><p>
   The object system on a bus is based on 'nodes' and 'handles'. Any peer can
   allocate new, local objects at any time. The creator automatically becomes
   the sole owner of the object. References to objects can be passed as payload
   of messages. The recipient will then gain their own reference to the object
   as well. Additionally, an object can be the destination of a message, in
   which case the message is always sent to the original creator (and thus the
   owner) of the object.
   </p><p>
   Internally, objects are called 'nodes'. A reference to an object is a
   'handle'. Whenever a new node is created, the owner implicitly gains an
   handle as well. In fact, handles are the only way to refer to a node. The
   node itself is entirely hidden in the implementation, and visible in the API
   as an <span class="quote">“<span class="quote">anchor handle</span>”</span>.
   </p><p>
   Whenever a handle is passed as payload of a message, the target peer will
   gain a handle linked to the same underlying node. This works regardless
   of whether the sender is the owner of the underlying node, or not.
   </p><p>
   Each peer can identify all its handles (both owned and un-owned) by a 64-bit
   integer. The namespace is local to each peer, and the numbers cannot be
   compared with the numbers of other peers (in fact, they are very likely
   to clash, but might still have *different* underlying nodes). However, if a
   peer receives a reference to the same node multiple times, the resulting
   handle will be the same. The kernel keeps count of how often each peer owns
   a handle.
   </p><p>
   If a peer no longer requires a specific handle, it can release it. If the
   peer releases its last reference to a handle, the handle will be destroyed.
   </p><p>
   The owner of a node (and *only* the owner) can trigger the destruction of a
   node (even if other peers still own handles to it). In this case, all peers
   that own a handle are notified of this fact.
   Once all handles to a specific node have been released (except for the handle
   internally pinned in the node itself), the owner of the node is notified of
   this, so it can potentially destroy both any linked state and the node
   itself.
   </p><p>
   Node destruction is fully synchronized with any transaction. That is, a node
   and all its handles are valid in every message that is transmitted *before*
   the notification of its destruction. Furthermore, no message after this
   notification will carry the ID of such a destroyed node.
   Note that message transactions are asynchronous. That is, there is no unique
   point in time that a message is synchronized with another message. Hence,
   whether a specific handle passed with a message is still valid or not,
   cannot be predicted by the sender, but only by one of the receivers.
</p><div class="refentry"><a name="API-enum-bus1-handle-bits"></a><div class="titlepage"></div><div class="refnamediv"><p>enum bus1_handle_bits — 
  node flags
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
enum bus1_handle_bits {
  BUS1_HANDLE_BIT_RELEASED,
  BUS1_HANDLE_BIT_DESTROYED
};  </pre></div><div class="refsect1"><a name="id-1.7.10.5"></a><h2>Constants</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">BUS1_HANDLE_BIT_RELEASED</span></dt><dd><p>
The anchor handle has been released.
Any further attach operation will still
work, but result in a stale attach,
even in case of re-attach of the anchor
itself.
      </p></dd><dt><span class="term">BUS1_HANDLE_BIT_DESTROYED</span></dt><dd><p>
A destruction has already been
scheduled for this node.
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle — 
     object handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle {
  struct kref ref;
  atomic_t n_weak;
  atomic_t n_user;
  struct bus1_peer * holder;
  struct bus1_handle * anchor;
  struct bus1_handle * tlink;
  struct rb_node rb_to_peer;
  u64 id;
  struct bus1_queue_node qnode;
  union {unnamed_union};
};  </pre></div><div class="refsect1"><a name="id-1.7.11.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">ref</span></dt><dd><p>
   object reference counter
      </p></dd><dt><span class="term">n_weak</span></dt><dd><p>
   number of weak references
      </p></dd><dt><span class="term">n_user</span></dt><dd><p>
   number of user references
      </p></dd><dt><span class="term">holder</span></dt><dd><p>
   holder of this handle
      </p></dd><dt><span class="term">anchor</span></dt><dd><p>
   anchor handle
      </p></dd><dt><span class="term">tlink</span></dt><dd><p>
   singly-linked list for free use
      </p></dd><dt><span class="term">rb_to_peer</span></dt><dd><p>
   rb-link into peer by ID
      </p></dd><dt><span class="term">id</span></dt><dd><p>
   current ID
      </p></dd><dt><span class="term">qnode</span></dt><dd><p>
   queue node for notifications
   <em class="parameter"><code>node</code></em>.map_handles:			map of attached handles by peer
   <em class="parameter"><code>node</code></em>.flags:				node flags
   <em class="parameter"><code>node</code></em>.n_strong:			number of strong references
   <em class="parameter"><code>remote</code></em>.rb_to_anchor:		rb-link into node by peer
      </p></dd><dt><span class="term">{unnamed_union}</span></dt><dd><p>
   anonymous
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-is-anchor"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_is_anchor — 
     check whether handle is an anchor
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_handle_is_anchor </b>(</code>struct bus1_handle * <var class="pdparam">h</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.12.6"></a><h2>Description</h2><p>
   This checks whether <em class="parameter"><code>h</code></em> is an anchor. That is, <em class="parameter"><code>h</code></em> was created via
   <code class="function">bus1_handle_new_anchor</code>, rather than via <code class="function">bus1_handle_new_remote</code>.
</p></div><div class="refsect1"><a name="id-1.7.12.7"></a><h2>Return</h2><p>
   True if it is an anchor, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-is-live"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_is_live — 
     check whether handle is live
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_handle_is_live </b>(</code>struct bus1_handle * <var class="pdparam">h</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.13.6"></a><h2>Description</h2><p>
   This checks whether the given handle is still live. That is, its anchor was
   not destroyed, yet.
</p></div><div class="refsect1"><a name="id-1.7.13.7"></a><h2>Return</h2><p>
   True if it is live, false if already destroyed.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-is-public"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_is_public — 
     check whether handle is public
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_handle_is_public </b>(</code>struct bus1_handle * <var class="pdparam">h</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.14.6"></a><h2>Description</h2><p>
   This checks whether the given handle is public. That is, it was exported to
   user-space and at least one public reference is left.
</p></div><div class="refsect1"><a name="id-1.7.14.7"></a><h2>Return</h2><p>
   True if it is public, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-ref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_ref — 
     acquire object reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_ref </b>(</code>struct bus1_handle * <var class="pdparam">h</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.15.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.15.6"></a><h2>Description</h2><p>
   This acquires an object reference to <em class="parameter"><code>h</code></em>. The caller must already hold a
   reference. Otherwise, the behavior is undefined.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.7.15.7"></a><h2>Return</h2><p>
   <em class="parameter"><code>h</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-unref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_unref — 
     release object reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_unref </b>(</code>struct bus1_handle * <var class="pdparam">h</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.16.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.16.6"></a><h2>Description</h2><p>
   This releases an object reference. If the reference count drops to 0, the
   object is released (rcu-delayed).
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.7.16.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-acquire"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_acquire — 
     acquire weak/strong reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_acquire </b>(</code>struct bus1_handle * <var class="pdparam">h</var>, bool <var class="pdparam">strong</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to operate on, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>strong</code></em></span></dt><dd><p>
     whether to acquire a strong reference
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.17.6"></a><h2>Description</h2><p>
   This acquires a weak/strong reference to the node <em class="parameter"><code>h</code></em> is attached to.
   This always succeeds. However, if a conflict is detected, <em class="parameter"><code>h</code></em> is
   unreferenced and the conflicting handle is returned (with an object
   reference taken and strong reference acquired).
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.7.17.7"></a><h2>Return</h2><p>
   Pointer to the acquired handle is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-release"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_release — 
     release weak/strong reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_release </b>(</code>struct bus1_handle * <var class="pdparam">h</var>, bool <var class="pdparam">strong</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.18.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to operate on, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>strong</code></em></span></dt><dd><p>
     whether to release a strong reference
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.18.6"></a><h2>Description</h2><p>
   This releases a weak or strong reference to the node <em class="parameter"><code>h</code></em> is attached to.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.7.18.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-release-n"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_release_n — 
     release multiple references
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_release_n </b>(</code>struct bus1_handle * <var class="pdparam">h</var>, unsigned int <var class="pdparam">n</var>, bool <var class="pdparam">strong</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.19.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to operate on, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>n</code></em></span></dt><dd><p>
     number of references to release
    </p></dd><dt><span class="term"><em class="parameter"><code>strong</code></em></span></dt><dd><p>
     whether to release strong references
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.19.6"></a><h2>Description</h2><p>
   This releases <em class="parameter"><code>n</code></em> weak or strong references to the node <em class="parameter"><code>h</code></em> is attached to.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.7.19.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-new-anchor"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_new_anchor — 
  allocate new anchor handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_new_anchor </b>(</code>struct bus1_peer * <var class="pdparam">holder</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.20.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>holder</code></em></span></dt><dd><p>
     peer to set as holder
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.20.6"></a><h2>Description</h2><p>
   This allocates a new, fresh, anchor handle for free use to the caller.
</p></div><div class="refsect1"><a name="id-1.7.20.7"></a><h2>Return</h2><p>
   Pointer to handle, or ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-new-remote"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_new_remote — 
     allocate new remote handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_new_remote </b>(</code>struct bus1_peer * <var class="pdparam">holder</var>, struct bus1_handle * <var class="pdparam">other</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.21.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>holder</code></em></span></dt><dd><p>
     peer to set as holder
    </p></dd><dt><span class="term"><em class="parameter"><code>other</code></em></span></dt><dd><p>
     other handle to link to
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.21.6"></a><h2>Description</h2><p>
   This allocates a new, fresh, remote handle for free use to the caller. The
   handle will use the same anchor as <em class="parameter"><code>other</code></em> (or <em class="parameter"><code>other</code></em> in case it is an
   anchor).
</p></div><div class="refsect1"><a name="id-1.7.21.7"></a><h2>Return</h2><p>
   Pointer to handle, or ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_free — 
     free handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_free </b>(</code>struct kref * <var class="pdparam">k</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.22.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>k</code></em></span></dt><dd><p>
     kref of handle to free
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.22.6"></a><h2>Description</h2><p>
   This frees the handle belonging to the kref <em class="parameter"><code>k</code></em>. It is meant to be used as
   callback for <code class="function">kref_put</code>. The actual memory release is rcu-delayed so the
   handle stays around at least until the next grace period.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-acquire-owner"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_acquire_owner — 
     acquire owner of a handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_handle_acquire_owner </b>(</code>struct bus1_handle * <var class="pdparam">handle</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.23.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>handle</code></em></span></dt><dd><p>
     handle to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.23.6"></a><h2>Description</h2><p>
   This tries to acquire the owner of a handle. If the owner is already
   detached, this will return NULL.
</p></div><div class="refsect1"><a name="id-1.7.23.7"></a><h2>Return</h2><p>
   Pointer to owner on success, NULL on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-ref-by-other"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_ref_by_other — 
     lookup handle on a peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_ref_by_other </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, struct bus1_handle * <var class="pdparam">handle</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.24.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to lookup handle for
    </p></dd><dt><span class="term"><em class="parameter"><code>handle</code></em></span></dt><dd><p>
     other handle to match for
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.24.6"></a><h2>Description</h2><p>
   This looks for an handle held by <em class="parameter"><code>peer</code></em>, which points to the same node as
   <em class="parameter"><code>handle</code></em> (i.e., it is linked to <em class="parameter"><code>handle</code></em>-&gt;anchor). If <em class="parameter"><code>peer</code></em> does not hold such
   a handle, this returns NULL. Otherwise, an object reference is acquired and
   returned as pointer.
   </p><p>

   The caller must hold an active reference to <em class="parameter"><code>peer</code></em>.
</p></div><div class="refsect1"><a name="id-1.7.24.7"></a><h2>Return</h2><p>
   Pointer to handle if found, NULL if not found.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-acquire-locked"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_acquire_locked — 
     acquire strong reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_acquire_locked </b>(</code>struct bus1_handle * <var class="pdparam">handle</var>, bool <var class="pdparam">strong</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.25.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>handle</code></em></span></dt><dd><p>
     handle to operate on, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>strong</code></em></span></dt><dd><p>
     whether to acquire a strong reference
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.25.6"></a><h2>Description</h2><p>
   This is the same as <code class="function">bus1_handle_acquire_slow</code>, but requires the caller to
   hold the data lock of <em class="parameter"><code>holder</code></em> and the owner.
</p></div><div class="refsect1"><a name="id-1.7.25.7"></a><h2>Return</h2><p>
   Acquired handle (possibly a conflict).
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-acquire-slow"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_acquire_slow — 
     slow-path of handle acquisition
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_acquire_slow </b>(</code>struct bus1_handle * <var class="pdparam">handle</var>, bool <var class="pdparam">strong</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.26.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>handle</code></em></span></dt><dd><p>
     handle to acquire
    </p></dd><dt><span class="term"><em class="parameter"><code>strong</code></em></span></dt><dd><p>
     whether to acquire a strong reference
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.26.6"></a><h2>Description</h2><p>
   This is the slow-path of <code class="function">bus1_handle_acquire</code>. See there for details.
</p></div><div class="refsect1"><a name="id-1.7.26.7"></a><h2>Return</h2><p>
   Acquired handle (possibly a conflict).
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-release-slow"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_release_slow — 
     slow-path of handle release
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_release_slow </b>(</code>struct bus1_handle * <var class="pdparam">handle</var>, bool <var class="pdparam">strong</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.27.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>handle</code></em></span></dt><dd><p>
     handle to release
    </p></dd><dt><span class="term"><em class="parameter"><code>strong</code></em></span></dt><dd><p>
     whether to release a strong reference
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.27.6"></a><h2>Description</h2><p>
   This is the slow-path of <code class="function">bus1_handle_release</code>. See there for details.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-destroy-locked"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_destroy_locked — 
     stage node destruction
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_destroy_locked </b>(</code>struct bus1_handle * <var class="pdparam">handle</var>, struct bus1_tx * <var class="pdparam">tx</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.28.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>handle</code></em></span></dt><dd><p>
     handle to destroy
    </p></dd><dt><span class="term"><em class="parameter"><code>tx</code></em></span></dt><dd><p>
     transaction to use
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.28.6"></a><h2>Description</h2><p>
   This stages a destruction on <em class="parameter"><code>handle</code></em>. That is, it marks <em class="parameter"><code>handle</code></em> as destroyed
   and stages a release-notification for all live handles via <em class="parameter"><code>tx</code></em>. It is the
   responsibility of the caller to commit <em class="parameter"><code>tx</code></em>.
   </p><p>

   The given handle must be an anchor and not destroyed, yet. Furthermore, the
   caller must hold the local-lock and data-lock of the owner.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-is-live-at"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_is_live_at — 
     check whether handle is live at a given time
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_handle_is_live_at </b>(</code>struct bus1_handle * <var class="pdparam">h</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.29.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to check
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     timestamp to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.29.6"></a><h2>Description</h2><p>
   This checks whether the handle <em class="parameter"><code>h</code></em> is live at the time of <em class="parameter"><code>timestamp</code></em>. The
   caller must make sure that <em class="parameter"><code>timestamp</code></em> was acquired on the clock of the
   holder of <em class="parameter"><code>h</code></em>.
   </p><p>

   Note that this does not synchronize on the node owner. That is, usually you
   want to call this at the time of RECV, so it is guaranteed that there is no
   staging message in front of <em class="parameter"><code>timestamp</code></em>. Otherwise, a node owner might
   acquire a commit-timestamp for the destruction of <em class="parameter"><code>h</code></em> lower than <em class="parameter"><code>timestamp</code></em>.
   </p><p>

   The caller must hold the data-lock of the holder of <em class="parameter"><code>h</code></em>.
</p></div><div class="refsect1"><a name="id-1.7.29.7"></a><h2>Return</h2><p>
   True if live at the given timestamp, false if destroyed.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-import"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_import — 
     import handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_handle * <b class="fsfunc">bus1_handle_import </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, u64 <var class="pdparam">id</var>, bool * <var class="pdparam">is_newp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.30.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>id</code></em></span></dt><dd><p>
     ID of handle
    </p></dd><dt><span class="term"><em class="parameter"><code>is_newp</code></em></span></dt><dd><p>
     store whether handle is new
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.30.6"></a><h2>Description</h2><p>
   This searches the ID-namespace of <em class="parameter"><code>peer</code></em> for a handle with the given ID. If
   found, it is referenced, returned to the caller, and <em class="parameter"><code>is_newp</code></em> is set to
   false.
   </p><p>

   If not found and <em class="parameter"><code>id</code></em> is a remote ID, then an error is returned. But if it
   is a local ID, a new handle is created and placed in the lookup tree. In
   this case <em class="parameter"><code>is_newp</code></em> is set to true.
</p></div><div class="refsect1"><a name="id-1.7.30.7"></a><h2>Return</h2><p>
   Pointer to referenced handle is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-identify"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_identify — 
     identify handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_handle_identify </b>(</code>struct bus1_handle * <var class="pdparam">h</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.31.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.31.6"></a><h2>Description</h2><p>
   This returns the ID of <em class="parameter"><code>h</code></em>. If no ID was assigned, yet, a new one is picked.
</p></div><div class="refsect1"><a name="id-1.7.31.7"></a><h2>Return</h2><p>
   The ID of <em class="parameter"><code>h</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-export"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_export — 
     export handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_export </b>(</code>struct bus1_handle * <var class="pdparam">handle</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.32.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>handle</code></em></span></dt><dd><p>
     handle to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.32.6"></a><h2>Description</h2><p>
   This exports <em class="parameter"><code>handle</code></em> into the ID namespace of its holder. That is, if
   <em class="parameter"><code>handle</code></em> is not linked into the ID namespace yet, it is linked into it.
   </p><p>

   If <em class="parameter"><code>handle</code></em> is already linked, nothing is done.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-forget"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_forget — 
     forget handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_forget </b>(</code>struct bus1_handle * <var class="pdparam">h</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.33.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.33.6"></a><h2>Description</h2><p>
   If <em class="parameter"><code>h</code></em> is not public, but linked into the ID-lookup tree, this will remove it
   from the tree and clear the ID of <em class="parameter"><code>h</code></em>. It basically undoes what
   <code class="function">bus1_handle_import</code> and <code class="function">bus1_handle_export</code> do.
   </p><p>

   Note that there is no counter in <code class="function">bus1_handle_import</code> or
   <code class="function">bus1_handle_export</code>. That is, if you call <code class="function">bus1_handle_import</code> multiple
   times, a single <code class="function">bus1_handle_forget</code> undoes it. It is the callers
   responsibility to not release the local-lock randomly, and to properly
   detect cases where the same handle is used multiple times.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-forget-keep"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_forget_keep — 
     forget handle but keep rb-tree order
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_forget_keep </b>(</code>struct bus1_handle * <var class="pdparam">h</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.34.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>h</code></em></span></dt><dd><p>
     handle to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.34.6"></a><h2>Description</h2><p>
   This is like <code class="function">bus1_handle_forget</code>, but does not modify the ID-namespace
   rb-tree. That is, the backlink in <em class="parameter"><code>h</code></em> is cleared (h-&gt;rb_to_peer), but the
   rb-tree is not rebalanced. As such, you can use it with
   <code class="function">rbtree_postorder_for_each_entry_safe</code> to drop all entries.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="user"></a>Chapter 6. Bus1 User</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-usage"><span class="phrase">struct bus1_user_usage</span></a></span><span class="refpurpose"> — 
  usage counters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-limits"><span class="phrase">struct bus1_user_limits</span></a></span><span class="refpurpose"> — 
     resource limit counters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user"><span class="phrase">struct bus1_user</span></a></span><span class="refpurpose"> — 
     resource accounting for users
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-modexit"><span class="phrase">bus1_user_modexit</span></a></span><span class="refpurpose"> — 
  clean up global resources of user accounting
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-limits-init"><span class="phrase">bus1_user_limits_init</span></a></span><span class="refpurpose"> — 
     initialize resource limit counter
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-limits-deinit"><span class="phrase">bus1_user_limits_deinit</span></a></span><span class="refpurpose"> — 
     deinitialize source limit counter
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref-by-uid"><span class="phrase">bus1_user_ref_by_uid</span></a></span><span class="refpurpose"> — 
     get a user object for a uid
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref"><span class="phrase">bus1_user_ref</span></a></span><span class="refpurpose"> — 
     acquire reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-unref"><span class="phrase">bus1_user_unref</span></a></span><span class="refpurpose"> — 
     release reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-charge"><span class="phrase">bus1_user_charge</span></a></span><span class="refpurpose"> — 
     charge a user resource
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-discharge"><span class="phrase">bus1_user_discharge</span></a></span><span class="refpurpose"> — 
     discharge a user resource
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-charge-quota"><span class="phrase">bus1_user_charge_quota</span></a></span><span class="refpurpose"> — 
     charge quota resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-discharge-quota"><span class="phrase">bus1_user_discharge_quota</span></a></span><span class="refpurpose"> — 
     discharge quota resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-commit-quota"><span class="phrase">bus1_user_commit_quota</span></a></span><span class="refpurpose"> — 
     commit quota resources
 </span></dt></dl></div><p>
   </p><p>
   Different users can communicate via bus1, and many resources are shared
   between multiple users. The bus1_user object represents the UID of a user,
   like <span class="quote">“<span class="quote">struct user_struct</span>”</span> does in the kernel core. It is used to account
   global resources, apply limits, and calculate quotas if different UIDs
   communicate with each other.
   </p><p>
   All dynamic resources have global per-user limits, which cannot be exceeded
   by a user. They prevent a single user from exhausting local resources. Each
   peer that is created is always owned by the user that initialized it. All
   resources allocated on that peer are accounted on that pinned user.
   Additionally to global resources, there are local limits per peer, that can
   be controlled by each peer individually (e.g., specifying a maximum pool
   size). Those local limits allow a user to distribute the globally available
   resources across its peer instances.
   </p><p>
   Since bus1 allows communication across UID boundaries, any such transmission
   of resources must be properly accounted. Bus1 employs dynamic quotas to
   fairly distribute available resources. Those quotas make sure that available
   resources of a peer cannot be exhausted by remote UIDs, but are fairly
   divided among all communicating peers.
</p><div class="refentry"><a name="API-struct-bus1-user-usage"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_user_usage — 
  usage counters
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_user_usage {
  atomic_t n_slices;
  atomic_t n_handles;
  atomic_t n_bytes;
  atomic_t n_fds;
};  </pre></div><div class="refsect1"><a name="id-1.8.6.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_slices</span></dt><dd><p>
number of used slices
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
number of used handles
      </p></dd><dt><span class="term">n_bytes</span></dt><dd><p>
number of used bytes
      </p></dd><dt><span class="term">n_fds</span></dt><dd><p>
number of used fds
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-user-limits"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_user_limits — 
     resource limit counters
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_user_limits {
  atomic_t n_slices;
  atomic_t n_handles;
  atomic_t n_inflight_bytes;
  atomic_t n_inflight_fds;
  unsigned int max_slices;
  unsigned int max_handles;
  unsigned int max_inflight_bytes;
  unsigned int max_inflight_fds;
  struct idr usages;
};  </pre></div><div class="refsect1"><a name="id-1.8.7.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_slices</span></dt><dd><p>
   number of remaining quota for owned slices
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
   number of remaining quota for owned handles
      </p></dd><dt><span class="term">n_inflight_bytes</span></dt><dd><p>
   number of remaining quota for inflight bytes
      </p></dd><dt><span class="term">n_inflight_fds</span></dt><dd><p>
   number of remaining quota for inflight FDs
      </p></dd><dt><span class="term">max_slices</span></dt><dd><p>
   maximum number of owned slices
      </p></dd><dt><span class="term">max_handles</span></dt><dd><p>
   maximum number of owned handles
      </p></dd><dt><span class="term">max_inflight_bytes</span></dt><dd><p>
   maximum number of inflight bytes
      </p></dd><dt><span class="term">max_inflight_fds</span></dt><dd><p>
   maximum number of inflight FDs
      </p></dd><dt><span class="term">usages</span></dt><dd><p>
   idr of usage entries per uid
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-user"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_user — 
     resource accounting for users
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_user {
  struct kref ref;
  kuid_t uid;
  struct mutex lock;
  union {unnamed_union};
};  </pre></div><div class="refsect1"><a name="id-1.8.8.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">ref</span></dt><dd><p>
   reference counter
      </p></dd><dt><span class="term">uid</span></dt><dd><p>
   UID of the user
      </p></dd><dt><span class="term">lock</span></dt><dd><p>
   object lock
      </p></dd><dt><span class="term">{unnamed_union}</span></dt><dd><p>
   anonymous
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-modexit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_modexit — 
  clean up global resources of user accounting
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_modexit </b>(</code> <var class="pdparam">void</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>void</code></em></span></dt><dd><p>
     no arguments
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.9.6"></a><h2>Description</h2><p>
   </p><p>

   This function cleans up any remaining global resources that were allocated
   by the user accounting helpers. The caller must make sure that no user
   object is referenced anymore, before calling this. This function just clears
   caches and verifies nothing is leaked.
   </p><p>

   This is meant to be called on module-exit.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-limits-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_limits_init — 
     initialize resource limit counter
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_limits_init </b>(</code>struct bus1_user_limits * <var class="pdparam">limits</var>, struct bus1_user * <var class="pdparam">source</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>limits</code></em></span></dt><dd><p>
     object to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>source</code></em></span></dt><dd><p>
     source to initialize from, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.10.6"></a><h2>Description</h2><p>
   This initializes the resource-limit counter <em class="parameter"><code>limit</code></em>. The initial limits are
   taken from <em class="parameter"><code>source</code></em>, if given. If NULL, the global default limits are taken.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-limits-deinit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_limits_deinit — 
     deinitialize source limit counter
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_limits_deinit </b>(</code>struct bus1_user_limits * <var class="pdparam">limits</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>limits</code></em></span></dt><dd><p>
     object to deinitialize
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.11.6"></a><h2>Description</h2><p>
   This should be called on destruction of <em class="parameter"><code>limits</code></em>. It verifies the correctness
   of the limits and emits warnings if something went wrong.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-ref-by-uid"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_ref_by_uid — 
     get a user object for a uid
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_user * <b class="fsfunc">bus1_user_ref_by_uid </b>(</code>kuid_t <var class="pdparam">uid</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>uid</code></em></span></dt><dd><p>
     uid of the user
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.12.6"></a><h2>Description</h2><p>
   Find and return the user object for the uid if it exists, otherwise create
   it first.
</p></div><div class="refsect1"><a name="id-1.8.12.7"></a><h2>Return</h2><p>
   A user object for the given uid, ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-ref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_ref — 
     acquire reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_user * <b class="fsfunc">bus1_user_ref </b>(</code>struct bus1_user * <var class="pdparam">user</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to acquire, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.13.6"></a><h2>Description</h2><p>
   Acquire an additional reference to a user-object. The caller must already
   own a reference.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.8.13.7"></a><h2>Return</h2><p>
   <em class="parameter"><code>user</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-unref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_unref — 
     release reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_user * <b class="fsfunc">bus1_user_unref </b>(</code>struct bus1_user * <var class="pdparam">user</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to release, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.14.6"></a><h2>Description</h2><p>
   Release a reference to a user-object.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.8.14.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-charge"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_charge — 
     charge a user resource
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_user_charge </b>(</code>atomic_t * <var class="pdparam">global</var>, atomic_t * <var class="pdparam">local</var>, int <var class="pdparam">charge</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.15.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>global</code></em></span></dt><dd><p>
     global resource to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>local</code></em></span></dt><dd><p>
     local resource to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>charge</code></em></span></dt><dd><p>
     charge to apply
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.15.6"></a><h2>Description</h2><p>
   This charges <em class="parameter"><code>charge</code></em> on two resource counters. Only if both charges apply,
   this returns success. It is an error to call this with negative charges.
</p></div><div class="refsect1"><a name="id-1.8.15.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-discharge"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_discharge — 
     discharge a user resource
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_discharge </b>(</code>atomic_t * <var class="pdparam">global</var>, atomic_t * <var class="pdparam">local</var>, int <var class="pdparam">charge</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.16.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>global</code></em></span></dt><dd><p>
     global resource to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>local</code></em></span></dt><dd><p>
     local resource to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>charge</code></em></span></dt><dd><p>
     charge to apply
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.16.6"></a><h2>Description</h2><p>
   This discharges <em class="parameter"><code>charge</code></em> on two resource counters. This always succeeds. It
   is an error to call this with a negative charge.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-charge-quota"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_charge_quota — 
     charge quota resources
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_user_charge_quota </b>(</code>struct bus1_user * <var class="pdparam">user</var>, struct bus1_user * <var class="pdparam">actor</var>, struct bus1_user_limits * <var class="pdparam">limits</var>, int <var class="pdparam">n_slices</var>, int <var class="pdparam">n_handles</var>, int <var class="pdparam">n_bytes</var>, int <var class="pdparam">n_fds</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>actor</code></em></span></dt><dd><p>
     user to charge as
    </p></dd><dt><span class="term"><em class="parameter"><code>limits</code></em></span></dt><dd><p>
     local limits to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>n_slices</code></em></span></dt><dd><p>
     number of slices to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_bytes</code></em></span></dt><dd><p>
     number of bytes to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_fds</code></em></span></dt><dd><p>
     number of FDs to charge
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.17.6"></a><h2>Description</h2><p>
   This charges the given resources on <em class="parameter"><code>user</code></em> and <em class="parameter"><code>limits</code></em>. It does both, local
   and remote charges. It is all charged for user <em class="parameter"><code>actor</code></em>.
   </p><p>

   Negative charges always succeed. Positive charges might fail if quota is
   denied. Note that a single call is always atomic, so either all succeed or
   all fail. Hence, it makes little sense to mix negative and positive charges
   in a single call.
</p></div><div class="refsect1"><a name="id-1.8.17.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-discharge-quota"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_discharge_quota — 
     discharge quota resources
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_discharge_quota </b>(</code>struct bus1_user * <var class="pdparam">user</var>, struct bus1_user * <var class="pdparam">actor</var>, struct bus1_user_limits * <var class="pdparam">l_local</var>, int <var class="pdparam">n_slices</var>, int <var class="pdparam">n_handles</var>, int <var class="pdparam">n_bytes</var>, int <var class="pdparam">n_fds</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.18.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>actor</code></em></span></dt><dd><p>
     user to charge as
    </p></dd><dt><span class="term"><em class="parameter"><code>l_local</code></em></span></dt><dd><p>
     local limits to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>n_slices</code></em></span></dt><dd><p>
     number of slices to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_bytes</code></em></span></dt><dd><p>
     number of bytes to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_fds</code></em></span></dt><dd><p>
     number of FDs to charge
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.18.6"></a><h2>Description</h2><p>
   This discharges the given resources on <em class="parameter"><code>user</code></em> and <em class="parameter"><code>limits</code></em>. It does both local
   and remote charges. It is all discharged for user <em class="parameter"><code>actor</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-commit-quota"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_commit_quota — 
     commit quota resources
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_commit_quota </b>(</code>struct bus1_user * <var class="pdparam">user</var>, struct bus1_user * <var class="pdparam">actor</var>, struct bus1_user_limits * <var class="pdparam">l_local</var>, int <var class="pdparam">n_slices</var>, int <var class="pdparam">n_handles</var>, int <var class="pdparam">n_bytes</var>, int <var class="pdparam">n_fds</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.19.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>actor</code></em></span></dt><dd><p>
     user to charge as
    </p></dd><dt><span class="term"><em class="parameter"><code>l_local</code></em></span></dt><dd><p>
     local limits to charge on
    </p></dd><dt><span class="term"><em class="parameter"><code>n_slices</code></em></span></dt><dd><p>
     number of slices to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_bytes</code></em></span></dt><dd><p>
     number of bytes to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_fds</code></em></span></dt><dd><p>
     number of FDs to charge
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.19.6"></a><h2>Description</h2><p>
   This commits the given resources on <em class="parameter"><code>user</code></em> and <em class="parameter"><code>limits</code></em>. Committing a quota
   means discharging the usage objects but leaving the limits untouched.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="active"></a>Chapter 7. Bus1 Active Reference</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-active"><span class="phrase">struct bus1_active</span></a></span><span class="refpurpose"> — 
  active references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-acquire"><span class="phrase">bus1_active_acquire</span></a></span><span class="refpurpose"> — 
     acquire active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-release"><span class="phrase">bus1_active_release</span></a></span><span class="refpurpose"> — 
     release active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-init-private"><span class="phrase">bus1_active_init_private</span></a></span><span class="refpurpose"> — 
  initialize object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-deinit"><span class="phrase">bus1_active_deinit</span></a></span><span class="refpurpose"> — 
     destroy object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-is-new"><span class="phrase">bus1_active_is_new</span></a></span><span class="refpurpose"> — 
     check whether object is new
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-is-active"><span class="phrase">bus1_active_is_active</span></a></span><span class="refpurpose"> — 
     check whether object is active
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-is-deactivated"><span class="phrase">bus1_active_is_deactivated</span></a></span><span class="refpurpose"> — 
     check whether object was deactivated
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-is-drained"><span class="phrase">bus1_active_is_drained</span></a></span><span class="refpurpose"> — 
     check whether object is drained
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-activate"><span class="phrase">bus1_active_activate</span></a></span><span class="refpurpose"> — 
     activate object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-deactivate"><span class="phrase">bus1_active_deactivate</span></a></span><span class="refpurpose"> — 
     deactivate object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-drain"><span class="phrase">bus1_active_drain</span></a></span><span class="refpurpose"> — 
     drain active references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-cleanup"><span class="phrase">bus1_active_cleanup</span></a></span><span class="refpurpose"> — 
     cleanup drained object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-lockdep-acquired"><span class="phrase">bus1_active_lockdep_acquired</span></a></span><span class="refpurpose"> — 
     acquire lockdep reader
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-active-lockdep-released"><span class="phrase">bus1_active_lockdep_released</span></a></span><span class="refpurpose"> — 
     release lockdep reader
 </span></dt></dl></div><p>
   </p><p>
   The bus1_active object implements active references. They work similarly to
   plain object reference counters, but allow disabling any new references from
   being taken.
   </p><p>
   Each bus1_active object goes through a set of states:
   NEW:       Initial state, no active references can be acquired
   ACTIVE:    Live state, active references can be acquired
   DRAINING:  Deactivated but lingering, no active references can be acquired
   DRAINED:   Deactivated and all active references were dropped
   RELEASED:  Fully drained and synchronously released
   </p><p>
   Initially, all bus1_active objects are in state NEW. As soon as they're
   activated, they enter ACTIVE and active references can be acquired. This is
   the normal, live state. Once the object is deactivated, it enters state
   DRAINING. No new active references can be acquired, but some threads might
   still own active references. Once all those are dropped, the object enters
   state DRAINED. Now the object can be released a *single* time, before it
   enters state RELEASED and is finished. It cannot be re-used anymore.
   </p><p>
   Active-references are very useful to track threads that call methods on an
   object. As long as a method is running, an active reference is held, and as
   such the object is usually protected from being destroyed. The destructor of
   the object needs to deactivate *and* drain the object, before releasing
   resources.
   </p><p>
   Note that active-references cannot be used to manage their own backing
   memory. That is, they do not replace normal reference counts.
</p><div class="refentry"><a name="API-struct-bus1-active"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_active — 
  active references
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_active {
  atomic_t count;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
  struct lockdep_map dep_map;
#endif
};  </pre></div><div class="refsect1"><a name="id-1.9.8.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">count</span></dt><dd><p>
active reference counter
      </p></dd><dt><span class="term">dep_map</span></dt><dd><p>
lockdep annotations
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.8.6"></a><h2>Description</h2><p>
   This object should be treated like a simple atomic_t. It will only contain
   more fields in the case of lockdep-enabled compilations.
   </p><p>

   Users must embed this object into their parent structures and create/destroy
   it via <code class="function">bus1_active_init</code> and <code class="function">bus1_active_deinit</code>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-acquire"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_acquire — 
     acquire active reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_active * <b class="fsfunc">bus1_active_acquire </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to acquire active reference to, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.9.6"></a><h2>Description</h2><p>
   This acquires an active reference to the passed object. If the object was
   not activated, yet, or if it was already deactivated, this will fail and
   return NULL. If a reference was successfully acquired, this will return
   <em class="parameter"><code>active</code></em>.
   </p><p>

   If NULL is passed, this is a no-op and always returns NULL.
   </p><p>

   This behaves as a <code class="function">down_read_trylock</code>. Use <code class="function">bus1_active_release</code> to release
   the reference again and get the matching <code class="function">up_read</code>.
</p></div><div class="refsect1"><a name="id-1.9.9.7"></a><h2>Return</h2><p>
   <em class="parameter"><code>active</code></em> if reference was acquired, NULL if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-release"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_release — 
     release active reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_active * <b class="fsfunc">bus1_active_release </b>(</code>struct bus1_active * <var class="pdparam">active</var>, wait_queue_head_t * <var class="pdparam">waitq</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to release active reference of, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait-queue linked to <em class="parameter"><code>active</code></em>, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.10.6"></a><h2>Description</h2><p>
   This releases an active reference that was previously acquired via
   <code class="function">bus1_active_acquire</code>.
   </p><p>

   This is a no-op if NULL is passed.
   </p><p>

   This behaves like an <code class="function">up_read</code>.
</p></div><div class="refsect1"><a name="id-1.9.10.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-init-private"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_init_private — 
  initialize object
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_active_init_private </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to initialize
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.11.6"></a><h2>Description</h2><p>
   This initializes an active-object. The initial state is NEW, and as such no
   active reference can be acquired. The object must be activated first.
   </p><p>

   This is an internal helper. Always use the public <code class="function">bus1_active_init</code> macro
   which does proper lockdep initialization for private key classes.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-deinit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_deinit — 
     destroy object
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_active_deinit </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to destroy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.12.6"></a><h2>Description</h2><p>
   Destroy an active-object. The object must have been initialized via
   <code class="function">bus1_active_init</code>, deactivated via <code class="function">bus1_active_deactivate</code>, drained via
   <code class="function">bus1_active_drain</code> and cleaned via <code class="function">bus1_active_cleanup</code>, before you can
   destroy it. Alternatively, it can also be destroyed if still in state NEW.
   </p><p>

   This function only does sanity checks, it does not modify the object itself.
   There is no allocated memory, so there is nothing to do.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-is-new"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_is_new — 
     check whether object is new
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_active_is_new </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.13.6"></a><h2>Description</h2><p>
   This checks whether the object is new, that is, it was never activated nor
   deactivated.
</p></div><div class="refsect1"><a name="id-1.9.13.7"></a><h2>Return</h2><p>
   True if new, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-is-active"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_is_active — 
     check whether object is active
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_active_is_active </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.14.6"></a><h2>Description</h2><p>
   This checks whether the given active-object is active. That is, the object
   was already activated, but not deactivated, yet.
   </p><p>

   Note that this function does not give any guarantee that the object is still
   active/inactive at the time this call returns. It only serves as a barrier.
</p></div><div class="refsect1"><a name="id-1.9.14.7"></a><h2>Return</h2><p>
   True if active, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-is-deactivated"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_is_deactivated — 
     check whether object was deactivated
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_active_is_deactivated </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.15.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.15.6"></a><h2>Description</h2><p>
   This checks whether the given active-object was already deactivated. That
   is, the object was actively deactivated (state NEW does *not* count as
   deactivated) via <code class="function">bus1_active_deactivate</code>.
   </p><p>

   Once this function returns true, it cannot change again on this object.
</p></div><div class="refsect1"><a name="id-1.9.15.7"></a><h2>Return</h2><p>
   True if already deactivated, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-is-drained"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_is_drained — 
     check whether object is drained
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_active_is_drained </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.16.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.16.6"></a><h2>Description</h2><p>
   This checks whether the given object was already deactivated and is fully
   drained. That is, no active references to the object exist, nor can they be
   acquired, anymore.
</p></div><div class="refsect1"><a name="id-1.9.16.7"></a><h2>Return</h2><p>
   True if drained, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-activate"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_activate — 
     activate object
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_active_activate </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to activate
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.17.6"></a><h2>Description</h2><p>
   This activates the given object, if it is still in state NEW. Otherwise, it
   is a no-op (and the object might already be deactivated).
   </p><p>

   Once this returns successfully, active references can be acquired.
</p></div><div class="refsect1"><a name="id-1.9.17.7"></a><h2>Return</h2><p>
   True if this call activated it, false if it was already activated,
   or deactivated.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-deactivate"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_deactivate — 
     deactivate object
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_active_deactivate </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.18.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to deactivate
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.18.6"></a><h2>Description</h2><p>
   This deactivates the given object, if not already done by someone else. Once
   this returns, no new active references can be acquired.
</p></div><div class="refsect1"><a name="id-1.9.18.7"></a><h2>Return</h2><p>
   True if this call deactivated the object, false if it was already
   deactivated by someone else.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-drain"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_drain — 
     drain active references
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_active_drain </b>(</code>struct bus1_active * <var class="pdparam">active</var>, wait_queue_head_t * <var class="pdparam">waitq</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.19.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to drain
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait-queue linked to <em class="parameter"><code>active</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.19.6"></a><h2>Description</h2><p>
   This waits for all active-references on <em class="parameter"><code>active</code></em> to be dropped. It uses the
   passed wait-queue to sleep. It must be the same wait-queue that is used when
   calling <code class="function">bus1_active_release</code>.
   </p><p>

   The caller must guarantee that <code class="function">bus1_active_deactivate</code> was called before.
   </p><p>

   This function can be safely called in parallel on multiple CPUs.
   </p><p>

   Semantically (and also enforced by lockdep), this call behaves like a
   <code class="function">down_write</code>, followed by an <code class="function">up_write</code>, on this active object.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-cleanup"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_cleanup — 
     cleanup drained object
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_active_cleanup </b>(</code>struct bus1_active * <var class="pdparam">active</var>, wait_queue_head_t * <var class="pdparam">waitq</var>, void (*<var class="pdparam">cleanup</var>)
     <code>(</code>struct bus1_active *, void *<code>)</code>, void * <var class="pdparam">userdata</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.20.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to release
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait-queue linked to <em class="parameter"><code>active</code></em>, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>cleanup</code></em></span></dt><dd><p>
     cleanup callback, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>userdata</code></em></span></dt><dd><p>
     userdata for callback
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.20.6"></a><h2>Description</h2><p>
   This performs the final object cleanup. The caller must guarantee that the
   object is drained, by calling <code class="function">bus1_active_drain</code>.
   </p><p>

   This function invokes the passed cleanup callback on the object. However, it
   guarantees that this is done exactly once. If there're multiple parallel
   callers, this will pick one randomly and make all others wait until it is
   done. If you call this after it was already cleaned up, this is a no-op
   and only serves as barrier.
   </p><p>

   If <em class="parameter"><code>waitq</code></em> is NULL, the wait is skipped and the call returns immediately. In
   this case, another thread has entered before, but there is no guarantee that
   they finished executing the cleanup callback, yet.
   </p><p>

   If <em class="parameter"><code>waitq</code></em> is non-NULL, this call behaves like a <code class="function">down_write</code>, followed by an
   <code class="function">up_write</code>, just like <code class="function">bus1_active_drain</code>. If <em class="parameter"><code>waitq</code></em> is NULL, this rather
   behaves like a <code class="function">down_write_trylock</code>, optionally followed by an <code class="function">up_write</code>.
</p></div><div class="refsect1"><a name="id-1.9.20.7"></a><h2>Return</h2><p>
   True if this is the thread that released it, false otherwise.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-lockdep-acquired"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_lockdep_acquired — 
     acquire lockdep reader
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_active_lockdep_acquired </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.21.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to acquire lockdep reader of, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.21.6"></a><h2>Description</h2><p>
   Whenever you acquire an active reference via <code class="function">bus1_active_acquire</code>, this
   function is implicitly called afterwards. It enables lockdep annotations and
   tells lockdep that you acquired the active reference.
   </p><p>

   However, lockdep cannot support arbitrary depths, hence, we allow
   temporarily dropping the lockdep-annotation via
   <code class="function">bus1_active_lockdep_release</code>, and acquiring them later again via
   <code class="function">bus1_active_lockdep_acquire</code>.
</p></div><div class="refsect1"><a name="id-1.9.21.7"></a><h2>Example</h2><div class="informalexample"><pre class="programlisting">
   If you need to pin a large number of objects, you would acquire each
            of them individually via <code class="function">bus1_active_acquire</code>. Then you would
            perform state tracking, etc. on that object. Before you continue
            with the next, you call <code class="function">bus1_active_lockdep_released</code>, to pretend
            you released the lock (but you still retain your active reference).
            Now you continue with pinning the next object, etc. until you
            pinned all objects you need.

            If you now need to access one of your pinned objects (or want to
            release them eventually), you call <code class="function">bus1_active_lockdep_acquired</code>
            before accessing the object. This enables the lockdep annotations
            again. This cannot fail, ever. You still own the active reference
            at all times.
            Once you're done with the single object, you either release your
            entire active reference via <code class="function">bus1_active_release</code>, or you
            temporarily disable lockdep via <code class="function">bus1_active_lockdep_released</code>
            again, in case you need the pinned object again later.

   Note that you can acquired multiple active references just fine. The only
   reason those lockdep helpers are provided, is if you need to acquire a
   *large* number at the same time. Lockdep is usually limited to a depths of 64
   so you cannot hold more locks at the same time.
</pre></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-active-lockdep-released"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_active_lockdep_released — 
     release lockdep reader
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_active_lockdep_released </b>(</code>struct bus1_active * <var class="pdparam">active</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.22.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>active</code></em></span></dt><dd><p>
     object to release lockdep reader of, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.22.6"></a><h2>Description</h2><p>
   This is the counterpart of <code class="function">bus1_active_lockdep_acquired</code>. See its
   documentation for details.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="flist"></a>Chapter 8. Bus1 Fixed List</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-flist"><span class="phrase">struct bus1_flist</span></a></span><span class="refpurpose"> — 
  fixed list
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-inline-size"><span class="phrase">bus1_flist_inline_size</span></a></span><span class="refpurpose"> — 
     calculate required inline size
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-init"><span class="phrase">bus1_flist_init</span></a></span><span class="refpurpose"> — 
     initialize an flist
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-deinit"><span class="phrase">bus1_flist_deinit</span></a></span><span class="refpurpose"> — 
     deinitialize an flist
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-next"><span class="phrase">bus1_flist_next</span></a></span><span class="refpurpose"> — 
     flist iterator
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-walk"><span class="phrase">bus1_flist_walk</span></a></span><span class="refpurpose"> — 
     walk flist in batches
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-populate"><span class="phrase">bus1_flist_populate</span></a></span><span class="refpurpose"> — 
  populate an flist
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-new"><span class="phrase">bus1_flist_new</span></a></span><span class="refpurpose"> — 
     allocate new flist
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-flist-free"><span class="phrase">bus1_flist_free</span></a></span><span class="refpurpose"> — 
     free flist
 </span></dt></dl></div><p>
   </p><p>
   This implements a fixed-size list called bus1_flist. The size of the list
   must be constant over the lifetime of the list. The list can hold one
   arbitrary pointer per node.
   </p><p>
   Fixed lists are a combination of a linked list and a static array. That is,
   fixed lists behave like linked lists (no random access, but arbitrary size),
   but compare in speed with arrays (consequetive accesses are fast). Unlike
   fixed arrays, fixed lists can hold huge number of elements without requiring
   <code class="function">vmalloc</code>, but solely relying on small-size <code class="function">kmalloc</code> allocations.
   </p><p>
   Internally, fixed lists are a singly-linked list of static arrays. This
   guarantees that iterations behave almost like on an array, except when
   crossing a batch-border.
   </p><p>
   Fixed lists can replace fixed-size arrays whenever you need to support large
   number of elements, but don't need random access. Fixed lists have ALMOST
   the same memory requirements as fixed-size arrays, except one pointer of
   state per 'BUS1_FLIST_BATCH' elements. If only a small size (i.e., it only
   requires one batch) is stored in a fixed list, then its memory requirements
   and iteration time are equivalent to fixed-size arrays.
</p><div class="refentry"><a name="API-struct-bus1-flist"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_flist — 
  fixed list
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_flist {
  union {unnamed_union};
};  </pre></div><div class="refsect1"><a name="id-1.10.7.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">{unnamed_union}</span></dt><dd><p>
anonymous
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-flist-inline-size"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_flist_inline_size — 
     calculate required inline size
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">size_t <b class="fsfunc">bus1_flist_inline_size </b>(</code>size_t <var class="pdparam">n</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>n</code></em></span></dt><dd><p>
     number of entries
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.8.6"></a><h2>Description</h2><p>
   When allocating storage for an flist, this calculates the size of the
   initial array in bytes. Use <code class="function">bus1_flist_new</code> directly if you want to
   allocate an flist on the heap. This helper is only needed if you embed an
   flist into another struct like this:
   </p><p>

   struct foo {
   ...
   struct bus1_flist list[];
   };
   </p><p>

   In that case the flist must be the last element, and the size in bytes
   required by it is returned by this function.
   </p><p>

   The inline-size of an flist is always bound to a fixed maximum. That is,
   regardless of <em class="parameter"><code>n</code></em>, this will always return a reasonable number that can be
   allocated via <code class="function">kmalloc</code>.
</p></div><div class="refsect1"><a name="id-1.10.8.7"></a><h2>Return</h2><p>
   Size in bytes required for the initial batch of an flist.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-flist-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_flist_init — 
     initialize an flist
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_flist_init </b>(</code>struct bus1_flist * <var class="pdparam">list</var>, size_t <var class="pdparam">n</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>list</code></em></span></dt><dd><p>
     flist to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>n</code></em></span></dt><dd><p>
     number of entries
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.9.6"></a><h2>Description</h2><p>
   This initializes an flist of size <em class="parameter"><code>n</code></em>. It does NOT preallocate the memory,
   but only initializes <em class="parameter"><code>list</code></em> in a way that <code class="function">bus1_flist_deinit</code> can be called
   on it. Use <code class="function">bus1_flist_populate</code> to populate the flist.
   </p><p>

   This is only needed if your backing memory of <em class="parameter"><code>list</code></em> is shared with another
   object. If possible, use <code class="function">bus1_flist_new</code> to allocate an flist on the heap
   and avoid this dance.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-flist-deinit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_flist_deinit — 
     deinitialize an flist
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_flist_deinit </b>(</code>struct bus1_flist * <var class="pdparam">list</var>, size_t <var class="pdparam">n</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>list</code></em></span></dt><dd><p>
     flist to deinitialize
    </p></dd><dt><span class="term"><em class="parameter"><code>n</code></em></span></dt><dd><p>
     number of entries
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.10.6"></a><h2>Description</h2><p>
   This deallocates an flist and releases all resources. If already
   deinitialized, this is a no-op. This is only needed if you called
   <code class="function">bus1_flist_populate</code>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-flist-next"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_flist_next — 
     flist iterator
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_flist * <b class="fsfunc">bus1_flist_next </b>(</code>struct bus1_flist * <var class="pdparam">iter</var>, size_t * <var class="pdparam">pos</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>iter</code></em></span></dt><dd><p>
     iterator
    </p></dd><dt><span class="term"><em class="parameter"><code>pos</code></em></span></dt><dd><p>
     current position
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.11.6"></a><h2>Description</h2><p>
   This advances an flist iterator by one position. <em class="parameter"><code>iter</code></em> must point to the
   current position, and the new position is returned by this function. <em class="parameter"><code>pos</code></em>
   must point to a variable that contains the current index position. That is,
   <em class="parameter"><code>pos</code></em> must be initialized to 0 and <em class="parameter"><code>iter</code></em> to the flist head.
   </p><p>

   Neither <em class="parameter"><code>pos</code></em> nor <em class="parameter"><code>iter</code></em> must be modified by anyone but this helper. In the
   loop body you can use <em class="parameter"><code>iter</code></em>-&gt;ptr to access the current element.
   </p><p>

   This iterator is normally used like this:
   </p><p>

   size_t pos, n = 128;
   struct bus1_flist *e, *list = bus1_flist_new(n);
   </p><p>

   ...
   </p><p>

   for (pos = 0, e = list; pos &lt; n; e = bus1_flist_next(e, <span class="structname">pos</span>)) {
   ... access e-&gt;ptr ...
   }
</p></div><div class="refsect1"><a name="id-1.10.11.7"></a><h2>Return</h2><p>
   Next iterator position.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-flist-walk"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_flist_walk — 
     walk flist in batches
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">size_t <b class="fsfunc">bus1_flist_walk </b>(</code>struct bus1_flist * <var class="pdparam">list</var>, size_t <var class="pdparam">n</var>, struct bus1_flist ** <var class="pdparam">iter</var>, size_t * <var class="pdparam">pos</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>list</code></em></span></dt><dd><p>
     list to walk
    </p></dd><dt><span class="term"><em class="parameter"><code>n</code></em></span></dt><dd><p>
     number of entries
    </p></dd><dt><span class="term"><em class="parameter"><code>iter</code></em></span></dt><dd><p>
     iterator
    </p></dd><dt><span class="term"><em class="parameter"><code>pos</code></em></span></dt><dd><p>
     current position
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.12.6"></a><h2>Description</h2><p>
   This walks an flist in batches of size up to BUS1_FLIST_BATCH. It is
   normally used like this:
   </p><p>

   size_t pos, z, n = 65536;
   struct bus1_flist *e, *list = bus1_flist_new(n);
   </p><p>

   ...
   </p><p>

   pos = 0;
   while ((z = bus1_flist_walk(list, n, <span class="structname">e</span>, <span class="structname">pos</span>)) &gt; 0) {
   ... access e[0...z]-&gt;ptr
   ... invariant: z &lt;= BUS1_FLIST_BATCH
   ... invariant: e[i]-&gt;ptr == (<span class="structname">e</span>-&gt;ptr)[i]
   }
</p></div><div class="refsect1"><a name="id-1.10.12.7"></a><h2>Return</h2><p>
   Size of batch at <em class="parameter"><code>iter</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-flist-populate"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_flist_populate — 
  populate an flist
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_flist_populate </b>(</code>struct bus1_flist * <var class="pdparam">list</var>, size_t <var class="pdparam">n</var>, gfp_t <var class="pdparam">gfp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>list</code></em></span></dt><dd><p>
     flist to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>n</code></em></span></dt><dd><p>
     number of elements
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     GFP to use for allocations
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.13.6"></a><h2>Description</h2><p>
   Populate an flist. This pre-allocates the backing memory for an flist that
   was statically initialized via <code class="function">bus1_flist_init</code>. This is NOT needed if the
   list was allocated via <code class="function">bus1_flist_new</code>.
</p></div><div class="refsect1"><a name="id-1.10.13.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-flist-new"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_flist_new — 
     allocate new flist
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_flist * <b class="fsfunc">bus1_flist_new </b>(</code>size_t <var class="pdparam">n</var>, gfp_t <var class="pdparam">gfp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>n</code></em></span></dt><dd><p>
     number of elements
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     GFP to use for allocations
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.14.6"></a><h2>Description</h2><p>
   This allocates a new flist ready to store <em class="parameter"><code>n</code></em> elements.
</p></div><div class="refsect1"><a name="id-1.10.14.7"></a><h2>Return</h2><p>
   Pointer to flist, NULL if out-of-memory.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-flist-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_flist_free — 
     free flist
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_flist * <b class="fsfunc">bus1_flist_free </b>(</code>struct bus1_flist * <var class="pdparam">list</var>, size_t <var class="pdparam">n</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.15.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>list</code></em></span></dt><dd><p>
     flist to operate on, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>n</code></em></span></dt><dd><p>
     number of elements
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.15.6"></a><h2>Description</h2><p>
   This deallocates an flist previously created via <code class="function">bus1_flist_new</code>.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.10.15.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="pool"></a>Chapter 9. Bus1 Pool</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool-slice"><span class="phrase">struct bus1_pool_slice</span></a></span><span class="refpurpose"> — 
  pool slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool"><span class="phrase">struct bus1_pool</span></a></span><span class="refpurpose"> — 
     client pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-slice-is-public"><span class="phrase">bus1_pool_slice_is_public</span></a></span><span class="refpurpose"> — 
     check whether a slice is public
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-init"><span class="phrase">bus1_pool_init</span></a></span><span class="refpurpose"> — 
  create memory pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-deinit"><span class="phrase">bus1_pool_deinit</span></a></span><span class="refpurpose"> — 
     destroy pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-alloc"><span class="phrase">bus1_pool_alloc</span></a></span><span class="refpurpose"> — 
     allocate memory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-kernel"><span class="phrase">bus1_pool_release_kernel</span></a></span><span class="refpurpose"> — 
     release kernel-owned slice reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-publish"><span class="phrase">bus1_pool_publish</span></a></span><span class="refpurpose"> — 
     publish a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-user"><span class="phrase">bus1_pool_release_user</span></a></span><span class="refpurpose"> — 
     release a public slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-flush"><span class="phrase">bus1_pool_flush</span></a></span><span class="refpurpose"> — 
     flush all user references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-mmap"><span class="phrase">bus1_pool_mmap</span></a></span><span class="refpurpose"> — 
     mmap the pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-iovec"><span class="phrase">bus1_pool_write_iovec</span></a></span><span class="refpurpose"> — 
     copy user memory to a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-kvec"><span class="phrase">bus1_pool_write_kvec</span></a></span><span class="refpurpose"> — 
     copy kernel memory to a slice
 </span></dt></dl></div><p>
   </p><p>
   A pool is a shmem-backed memory pool shared between userspace and the kernel.
   The pool is used to transfer memory from the kernel to userspace without
   requiring userspace to allocate the memory.
   </p><p>
   The pool is managed in slices, which are published to userspace when they are
   ready to be read and must be released by userspace when userspace is done
   with them.
   </p><p>
   Userspace has read-only access to its pools and the kernel has read-write
   access, but published slices are not altered.
</p><div class="refentry"><a name="API-struct-bus1-pool-slice"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_pool_slice — 
  pool slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_pool_slice {
  u32 offset;
  u32 free:1;
  u32 ref_kernel:1;
  u32 ref_user:1;
  struct list_head entry;
  struct rb_node rb;
};  </pre></div><div class="refsect1"><a name="id-1.11.6.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">offset</span></dt><dd><p>
relative offset in parent pool
      </p></dd><dt><span class="term">free</span></dt><dd><p>
whether this slice is in-use or not
      </p></dd><dt><span class="term">ref_kernel</span></dt><dd><p>
whether a kernel reference exists
      </p></dd><dt><span class="term">ref_user</span></dt><dd><p>
whether a user reference exists
      </p></dd><dt><span class="term">entry</span></dt><dd><p>
link into linear list of slices
      </p></dd><dt><span class="term">rb</span></dt><dd><p>
link to busy/free rb-tree
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.6.6"></a><h2>Description</h2><p>
   Each chunk of memory in the pool is managed as a slice. A slice can be
   accessible by both the kernel and user-space, and their access rights are
   managed independently. As long as the kernel has a reference to a slice, its
   offset and size can be accessed freely and will not change. Once the kernel
   drops its reference, it must not access the slice, anymore.
   </p><p>

   To allow user-space access, the slice must be published. This marks the slice
   as referenced by user-space. Note that all slices are always readable by
   user-space, since the entire pool can be mapped. Publishing a slice only
   marks the slice as referenced by user-space, so it will not be modified or
   removed. Once user-space releases its reference, it should no longer access
   the slice as it might be modified and/or overwritten by other data.
   </p><p>

   Only if neither kernel nor user-space have a reference to a slice, the slice
   is released. The kernel reference can only be acquired/released once, but
   user-space references can be published/released several times. In particular,
   if the kernel retains a reference when a slice is published and later
   released by userspace, the same slice can be published again in the future.
   </p><p>

   Note that both kernel-space and user-space must be aware that slice
   references are not ref-counted. They are simple booleans. For the kernel-side
   this is obvious, as no ref/unref functions are provided. But user-space must
   be aware that the same slice being published several times does not increase
   the reference count.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-pool"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_pool — 
     client pool
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_pool {
  struct file * f;
  size_t allocated_size;
  struct list_head slices;
  struct rb_root slices_busy;
  struct rb_root slices_free;
};  </pre></div><div class="refsect1"><a name="id-1.11.7.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">f</span></dt><dd><p>
   backing shmem file
      </p></dd><dt><span class="term">allocated_size</span></dt><dd><p>
   currently allocated memory in bytes
      </p></dd><dt><span class="term">slices</span></dt><dd><p>
   all slices sorted by address
      </p></dd><dt><span class="term">slices_busy</span></dt><dd><p>
   tree of allocated slices
      </p></dd><dt><span class="term">slices_free</span></dt><dd><p>
   tree of free slices
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.7.6"></a><h2>Description</h2><p>
   A pool is used to allocate memory slices that can be shared between
   kernel-space and user-space. A pool is always backed by a shmem-file and puts
   a simple slice-allocator on top. User-space gets read-only access to the
   entire pool, kernel-space gets read/write access via accessor-functions.
   </p><p>

   Pools are used to transfer large sets of data to user-space, without
   requiring a round-trip to ask user-space for a suitable memory chunk.
   Instead, the kernel simply allocates slices in the pool and tells user-space
   where it put the data.
   </p><p>

   All pool operations must be serialized by the caller. No internal lock is
   provided. Slices can be queried/modified unlocked. But any pool operation
   (allocation, release, flush, ...) must be serialized.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-slice-is-public"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_slice_is_public — 
     check whether a slice is public
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_pool_slice_is_public </b>(</code>struct bus1_pool_slice * <var class="pdparam">slice</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.8.6"></a><h2>Description</h2><p>
   This checks whether <em class="parameter"><code>slice</code></em> is public. That is, <code class="function">bus1_pool_publish</code> has been
   called and the user has not released their reference, yet.
   </p><p>

   Note that if you need reliable results, you better make sure this cannot
   race calls to <code class="function">bus1_pool_publish</code> or <code class="function">bus1_pool_release_user</code>.
</p></div><div class="refsect1"><a name="id-1.11.8.7"></a><h2>Return</h2><p>
   True if public, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_init — 
  create memory pool
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_pool_init </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, const char * <var class="pdparam">filename</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>filename</code></em></span></dt><dd><p>
     name to use for the shmem-file (only visible via /proc)
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.9.6"></a><h2>Description</h2><p>
   Initialize a new pool object.
</p></div><div class="refsect1"><a name="id-1.11.9.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-deinit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_deinit — 
     destroy pool
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_pool_deinit </b>(</code>struct bus1_pool * <var class="pdparam">pool</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.10.6"></a><h2>Description</h2><p>
   This destroys a pool that was previously create via <code class="function">bus1_pool_init</code>. If
   NULL is passed, or if <em class="parameter"><code>pool</code></em>-&gt;f is NULL (i.e., the pool was initialized to 0
   but not created via <code class="function">bus1_pool_init</code>, yet), then this is a no-op.
   </p><p>

   The caller must make sure that no kernel reference to any slice exists. Any
   pending user-space reference to any slice is dropped by this function.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-alloc"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_alloc — 
     allocate memory
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_pool_slice * <b class="fsfunc">bus1_pool_alloc </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, size_t <var class="pdparam">size</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to allocate memory from
    </p></dd><dt><span class="term"><em class="parameter"><code>size</code></em></span></dt><dd><p>
     number of bytes to allocate
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.11.6"></a><h2>Description</h2><p>
   This allocates a new slice of <em class="parameter"><code>size</code></em> bytes from the memory pool at <em class="parameter"><code>pool</code></em>. The
   slice must be released via <code class="function">bus1_pool_release_kernel</code> by the caller. All
   slices are aligned to 8 bytes (both offset and size).
   </p><p>

   If no suitable slice can be allocated, an error is returned.
   </p><p>

   Each pool slice can have two different references, a kernel reference and a
   user-space reference. Initially, it only has a kernel-reference, which must
   be dropped via <code class="function">bus1_pool_release_kernel</code>. However, if you previously
   publish the slice via <code class="function">bus1_pool_publish</code>, it will also have a user-space
   reference, which user-space must (indirectly) release via a call to
   <code class="function">bus1_pool_release_user</code>.
   A slice is only actually freed if neither reference exists, anymore. Hence,
   pool-slice can be held by both, the kernel and user-space, and both can rely
   on it staying around as long as they wish.
</p></div><div class="refsect1"><a name="id-1.11.11.7"></a><h2>Return</h2><p>
   Pointer to new slice, or ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-release-kernel"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_release_kernel — 
     release kernel-owned slice reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_pool_slice * <b class="fsfunc">bus1_pool_release_kernel </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to free memory on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to release
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.12.6"></a><h2>Description</h2><p>
   This releases the kernel-reference to a slice that was previously allocated
   via <code class="function">bus1_pool_alloc</code>. This only releases the kernel reference to the slice.
   If the slice was already published to user-space, then their reference is
   left untouched. Once both references are gone, the memory is actually freed.
</p></div><div class="refsect1"><a name="id-1.11.12.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-publish"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_publish — 
     publish a slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_pool_publish </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to publish
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.13.6"></a><h2>Description</h2><p>
   Publish a pool slice to user-space, so user-space can get access to it via
   the mapped pool memory. If the slice was already published, this is a no-op.
   Otherwise, the slice is marked as public and will only get freed once both
   the user-space reference *and* kernel-space reference are released.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-release-user"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_release_user — 
     release a public slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_pool_release_user </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, size_t <var class="pdparam">offset</var>, size_t * <var class="pdparam">n_slicesp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>
     offset of slice to release
    </p></dd><dt><span class="term"><em class="parameter"><code>n_slicesp</code></em></span></dt><dd><p>
     output variable to store number of released slices, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.14.6"></a><h2>Description</h2><p>
   Release the user-space reference to a pool-slice, specified via the offset
   of the slice. If both, the user-space reference *and* the kernel-space
   reference to the slice are gone, the slice will be actually freed.
   </p><p>

   If no slice exists with the given offset, or if there is no user-space
   reference to the specified slice, an error is returned.
</p></div><div class="refsect1"><a name="id-1.11.14.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-flush"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_flush — 
     flush all user references
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_pool_flush </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, size_t * <var class="pdparam">n_slicesp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.15.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to flush
    </p></dd><dt><span class="term"><em class="parameter"><code>n_slicesp</code></em></span></dt><dd><p>
     output variable to store number of released slices, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.15.6"></a><h2>Description</h2><p>
   This flushes all user-references to any slice in <em class="parameter"><code>pool</code></em>. Kernel references
   are left untouched.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-mmap"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_mmap — 
     mmap the pool
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_pool_mmap </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct vm_area_struct * <var class="pdparam">vma</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.16.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>vma</code></em></span></dt><dd><p>
     VMA to map to
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.16.6"></a><h2>Description</h2><p>
   This maps the pools shmem file to the provided VMA. Only read-only mappings
   are allowed.
</p></div><div class="refsect1"><a name="id-1.11.16.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-write-iovec"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_write_iovec — 
     copy user memory to a slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">ssize_t <b class="fsfunc">bus1_pool_write_iovec </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var>, loff_t <var class="pdparam">offset</var>, struct iovec * <var class="pdparam">iov</var>, size_t <var class="pdparam">n_iov</var>, size_t <var class="pdparam">total_len</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to write to
    </p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>
     relative offset into slice memory
    </p></dd><dt><span class="term"><em class="parameter"><code>iov</code></em></span></dt><dd><p>
     iovec array, pointing to data to copy
    </p></dd><dt><span class="term"><em class="parameter"><code>n_iov</code></em></span></dt><dd><p>
     number of elements in <em class="parameter"><code>iov</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>total_len</code></em></span></dt><dd><p>
     total number of bytes to copy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.17.6"></a><h2>Description</h2><p>
   This copies the memory pointed to by <em class="parameter"><code>iov</code></em> into the memory slice <em class="parameter"><code>slice</code></em> at
   relative offset <em class="parameter"><code>offset</code></em> (relative to begin of slice).
</p></div><div class="refsect1"><a name="id-1.11.17.7"></a><h2>Return</h2><p>
   Numbers of bytes copied, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-write-kvec"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_write_kvec — 
     copy kernel memory to a slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">ssize_t <b class="fsfunc">bus1_pool_write_kvec </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var>, loff_t <var class="pdparam">offset</var>, struct kvec * <var class="pdparam">iov</var>, size_t <var class="pdparam">n_iov</var>, size_t <var class="pdparam">total_len</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.11.18.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to write to
    </p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>
     relative offset into slice memory
    </p></dd><dt><span class="term"><em class="parameter"><code>iov</code></em></span></dt><dd><p>
     kvec array, pointing to data to copy
    </p></dd><dt><span class="term"><em class="parameter"><code>n_iov</code></em></span></dt><dd><p>
     number of elements in <em class="parameter"><code>iov</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>total_len</code></em></span></dt><dd><p>
     total number of bytes to copy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.11.18.6"></a><h2>Description</h2><p>
   This copies the memory pointed to by <em class="parameter"><code>iov</code></em> into the memory slice <em class="parameter"><code>slice</code></em> at
   relative offset <em class="parameter"><code>offset</code></em> (relative to begin of slice).
</p></div><div class="refsect1"><a name="id-1.11.18.7"></a><h2>Return</h2><p>
   Numbers of bytes copied, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="queue"></a>Chapter 10. Bus1 Queue</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue-node"><span class="phrase">struct bus1_queue_node</span></a></span><span class="refpurpose"> — 
  node into message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue"><span class="phrase">struct bus1_queue</span></a></span><span class="refpurpose"> — 
     message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-init"><span class="phrase">bus1_queue_node_init</span></a></span><span class="refpurpose"> — 
     initialize queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-deinit"><span class="phrase">bus1_queue_node_deinit</span></a></span><span class="refpurpose"> — 
     destroy queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-type"><span class="phrase">bus1_queue_node_get_type</span></a></span><span class="refpurpose"> — 
     query node type
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-timestamp"><span class="phrase">bus1_queue_node_get_timestamp</span></a></span><span class="refpurpose"> — 
     query node timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-queued"><span class="phrase">bus1_queue_node_is_queued</span></a></span><span class="refpurpose"> — 
     check whether a node is queued
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-staging"><span class="phrase">bus1_queue_node_is_staging</span></a></span><span class="refpurpose"> — 
     check whether a node is marked staging
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-tick"><span class="phrase">bus1_queue_tick</span></a></span><span class="refpurpose"> — 
     increment queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-sync"><span class="phrase">bus1_queue_sync</span></a></span><span class="refpurpose"> — 
     sync queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-is-readable-rcu"><span class="phrase">bus1_queue_is_readable_rcu</span></a></span><span class="refpurpose"> — 
     check whether a queue is readable
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-compare"><span class="phrase">bus1_queue_compare</span></a></span><span class="refpurpose"> — 
     comparator for queue ordering
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-init"><span class="phrase">bus1_queue_init</span></a></span><span class="refpurpose"> — 
  initialize queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-deinit"><span class="phrase">bus1_queue_deinit</span></a></span><span class="refpurpose"> — 
     destroy queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-flush"><span class="phrase">bus1_queue_flush</span></a></span><span class="refpurpose"> — 
     flush message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-stage"><span class="phrase">bus1_queue_stage</span></a></span><span class="refpurpose"> — 
     stage queue entry with fresh timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-staged"><span class="phrase">bus1_queue_commit_staged</span></a></span><span class="refpurpose"> — 
     commit staged queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-unstaged"><span class="phrase">bus1_queue_commit_unstaged</span></a></span><span class="refpurpose"> — 
     commit unstaged queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-synthetic"><span class="phrase">bus1_queue_commit_synthetic</span></a></span><span class="refpurpose"> — 
     commit synthetic entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-remove"><span class="phrase">bus1_queue_remove</span></a></span><span class="refpurpose"> — 
     remove entry from queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-peek"><span class="phrase">bus1_queue_peek</span></a></span><span class="refpurpose"> — 
     peek first available entry
 </span></dt></dl></div><p>
   </p><p>
   (You are highly encouraged to read up on 'Lamport Timestamps', the
   concept of 'happened-before', and 'causal ordering'. The queue
   implementation has its roots in Lamport Timestamps, treating a set of local
   CPUs as a distributed system to avoid any global synchronization.)
   </p><p>
   A message queue is a FIFO, i.e., messages are linearly ordered by the time
   they were sent. Moreover, atomic delivery of messages to multiple queues are
   supported, without any global synchronization, i.e., the order of message
   delivery is consistent across queues.
   </p><p>
   Messages can be destined for multiple queues, hence, we need to be careful
   that all queues get a consistent order of incoming messages. We define the
   concept of `global order' to provide a basic set of guarantees. This global
   order is a partial order on the set of all messages. The order is defined as:
   </p><p>
   1) If a message B was queued *after* a message A, then: A &lt; B
   </p><p>
   2) If a message B was queued *after* a message A was dequeued, then: A &lt; B
   </p><p>
   3) If a message B was dequeued *after* a message A on the same queue,
   then: A &lt; B
   </p><p>
   (Note: Causality is honored. `after' and `before' do not refer to the
   same task, nor the same queue, but rather any kind of
   synchronization between the two operations.)
   </p><p>
   The queue object implements this global order in a lockless fashion. It
   solely relies on a distributed clock on each queue. Each message to be sent
   causes a clock tick on the local clock and on all destination clocks.
   Furthermore, all clocks are synchronized, meaning they're fast-forwarded in
   case they're behind the highest of all participating peers. No global state
   tracking is involved.
   </p><p>
   During a message transaction, we first queue a message as 'staging' entry in
   each destination with a preliminary timestamp. This timestamp is explicitly
   odd numbered. Any odd numbered timestamp is considered 'staging' and causes
   *any* message ordered after it to be blocked until it is no longer staging.
   This allows us to queue the message in parallel with any racing multicast,
   and be guaranteed that all possible conflicts are blocked until we eventually
   commit a transaction. To commit a transaction (after all staging entries are
   queued), we choose the highest timestamp we have seen across all destinations
   and re-queue all our entries on each peer using that timestamp. Here we use a
   commit timestamp (even numbered).
   </p><p>
   With this in mind, we define that a client can only dequeue messages from
   its queue that have an even timestamp. Furthermore, if there is a message
   queued with an odd timestamp that is lower than the even timestamp of
   another message, then neither message can be dequeued. They're considered to
   be in-flight conflicts. This guarantees that two concurrent multicast
   messages can be queued without any *global* locks, but either can only be
   dequeued by a peer if their ordering has been established (via commit
   timestamps).
   </p><p>
   NOTE: A fully committed message is not guaranteed to be ready to be dequeued
   as it may be blocked by a staging entry. This means that there is an
   arbitrary (though bounded) time from a message transaction completing
   when the queue may still appear to be empty. In other words, message
   transmission is not instantaneous. It would be possible to change this
   at the cost of shortly blocking each message transaction on all other
   conflicting tasks.
   </p><p>
   The queue implementation uses an rb-tree (ordered by timestamps and sender),
   with a cached pointer to the front of the queue.
</p><div class="refentry"><a name="API-struct-bus1-queue-node"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_queue_node — 
  node into message queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_queue_node {
  union {unnamed_union};
  u64 timestamp_and_type;
  struct bus1_queue_node * next;
  void * group;
  void * owner;
};  </pre></div><div class="refsect1"><a name="id-1.12.15.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">{unnamed_union}</span></dt><dd><p>
anonymous
      </p></dd><dt><span class="term">timestamp_and_type</span></dt><dd><p>
message timestamp and type of parent object
      </p></dd><dt><span class="term">next</span></dt><dd><p>
single-linked utility list
      </p></dd><dt><span class="term">group</span></dt><dd><p>
group association
      </p></dd><dt><span class="term">owner</span></dt><dd><p>
node owner
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-queue"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_queue — 
     message queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_queue {
  u64 clock;
  u64 flush;
  struct rb_node * leftmost;
  struct rb_node __rcu * front;
  struct rb_root messages;
};  </pre></div><div class="refsect1"><a name="id-1.12.16.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">clock</span></dt><dd><p>
   local clock (used for Lamport Timestamps)
      </p></dd><dt><span class="term">flush</span></dt><dd><p>
   last flush timestamp
      </p></dd><dt><span class="term">leftmost</span></dt><dd><p>
   cached left-most entry
      </p></dd><dt><span class="term">front</span></dt><dd><p>
   cached front entry
      </p></dd><dt><span class="term">messages</span></dt><dd><p>
   queued messages
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_init — 
     initialize queue node
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_node_init </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var>, unsigned int <var class="pdparam">type</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>type</code></em></span></dt><dd><p>
     message type
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.17.6"></a><h2>Description</h2><p>
   This initializes a previously unused node, and prepares it for use with a
   message queue.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-deinit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_deinit — 
     destroy queue node
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_node_deinit </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.18.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to destroy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.18.6"></a><h2>Description</h2><p>
   This destroys a previously initialized queue node. This is a no-op and only
   serves as debugger, testing whether the node was properly unqueued before.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-get-type"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_get_type — 
     query node type
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">unsigned int <b class="fsfunc">bus1_queue_node_get_type </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.19.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.19.6"></a><h2>Description</h2><p>
   This queries the node type that was provided via the node constructor. A
   node never changes its type during its entire lifetime.
</p></div><div class="refsect1"><a name="id-1.12.19.7"></a><h2>Return</h2><p>
   Type of <em class="parameter"><code>node</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-get-timestamp"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_get_timestamp — 
     query node timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_node_get_timestamp </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.20.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.20.6"></a><h2>Description</h2><p>
   This queries the node timestamp that is currently set on this node.
</p></div><div class="refsect1"><a name="id-1.12.20.7"></a><h2>Return</h2><p>
   Timestamp of <em class="parameter"><code>node</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-is-queued"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_is_queued — 
     check whether a node is queued
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_node_is_queued </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.21.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.21.6"></a><h2>Description</h2><p>
   This checks whether a node is currently queued in a message queue. That is,
   the node was linked and has not been dequeued, yet.
</p></div><div class="refsect1"><a name="id-1.12.21.7"></a><h2>Return</h2><p>
   True if <em class="parameter"><code>node</code></em> is currently queued.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-is-staging"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_is_staging — 
     check whether a node is marked staging
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_node_is_staging </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.22.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.22.6"></a><h2>Description</h2><p>
   This checks whether a given node is queued, but still marked staging. That
   means, the node has been put on the queue but there is still a transaction
   that pins it to commit it later.
</p></div><div class="refsect1"><a name="id-1.12.22.7"></a><h2>Return</h2><p>
   True if <em class="parameter"><code>node</code></em> is queued as staging entry.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-tick"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_tick — 
     increment queue clock
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_tick </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.23.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.23.6"></a><h2>Description</h2><p>
   This performs a clock-tick on <em class="parameter"><code>queue</code></em>. The clock is incremented by a full
   interval (+2). The caller is free to use both, the new value (even numbered)
   and its successor (odd numbered). Both are uniquely allocated to the
   caller.
</p></div><div class="refsect1"><a name="id-1.12.23.7"></a><h2>Return</h2><p>
   New clock value is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-sync"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_sync — 
     sync queue clock
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_sync </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.24.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     timestamp to sync on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.24.6"></a><h2>Description</h2><p>
   This synchronizes the clock of <em class="parameter"><code>queue</code></em> with the externally provided timestamp
   <em class="parameter"><code>timestamp</code></em>. That is, the queue clock is fast-forwarded to <em class="parameter"><code>timestamp</code></em>, in
   case it is newer than the queue clock. Otherwise, nothing is done.
   </p><p>

   The passed in timestamp must be even.
</p></div><div class="refsect1"><a name="id-1.12.24.7"></a><h2>Return</h2><p>
   New clock value is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-is-readable-rcu"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_is_readable_rcu — 
     check whether a queue is readable
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_is_readable_rcu </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.25.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.25.6"></a><h2>Description</h2><p>
   This checks whether the given queue is readable.
   </p><p>

   This does not require any locking, except for an rcu-read-side critical
   section.
</p></div><div class="refsect1"><a name="id-1.12.25.7"></a><h2>Return</h2><p>
   True if the queue is readable, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-compare"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_compare — 
     comparator for queue ordering
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_queue_compare </b>(</code>u64 <var class="pdparam">a_ts</var>, void * <var class="pdparam">a_g</var>, u64 <var class="pdparam">b_ts</var>, void * <var class="pdparam">b_g</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.26.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>a_ts</code></em></span></dt><dd><p>
     timestamp of first node to compare
    </p></dd><dt><span class="term"><em class="parameter"><code>a_g</code></em></span></dt><dd><p>
     group of first node to compare
    </p></dd><dt><span class="term"><em class="parameter"><code>b_ts</code></em></span></dt><dd><p>
     timestamp of second node to compare against
    </p></dd><dt><span class="term"><em class="parameter"><code>b_g</code></em></span></dt><dd><p>
     group of second node to compare against
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.26.6"></a><h2>Description</h2><p>
   Messages on a message queue are ordered. This function implements the
   comparator used for all message ordering in queues. Two tags are used for
   ordering, the timestamp and the group-tag of a node. Both must be passed to
   this function.
   </p><p>

   This compares the tuples (<em class="parameter"><code>a_ts</code></em>, <em class="parameter"><code>a_g</code></em>) and (<em class="parameter"><code>b_ts</code></em>, <em class="parameter"><code>b_g</code></em>).
</p></div><div class="refsect1"><a name="id-1.12.26.7"></a><h2>Return</h2><p>
   &lt;0 if (<em class="parameter"><code>a_ts</code></em>, <em class="parameter"><code>a_g</code></em>) is ordered before, &gt;0 if after, 0 if same.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_init — 
  initialize queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_init </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.27.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to initialize
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.27.6"></a><h2>Description</h2><p>
   This initializes a new queue. The queue memory is considered uninitialized,
   any previous content is unrecoverable.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-deinit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_deinit — 
     destroy queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_deinit </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.28.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to destroy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.28.6"></a><h2>Description</h2><p>
   This destroys a queue that was previously initialized via <code class="function">bus1_queue_init</code>.
   The caller must make sure the queue is empty before calling this.
   </p><p>

   This function is a no-op, and only does safety checks on the queue. It is
   safe to call this function multiple times on the same queue.
   </p><p>

   The caller must guarantee that the backing memory of <em class="parameter"><code>queue</code></em> is freed in an
   rcu-delayed manner.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-flush"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_flush — 
     flush message queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_queue_node * <b class="fsfunc">bus1_queue_flush </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, u64 <var class="pdparam">ts</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.29.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to flush
    </p></dd><dt><span class="term"><em class="parameter"><code>ts</code></em></span></dt><dd><p>
     flush timestamp
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.29.6"></a><h2>Description</h2><p>
   This flushes all committed entries from <em class="parameter"><code>queue</code></em> and returns them as
   singly-linked list for the caller to clean up. Staged entries are left in
   the queue.
   </p><p>

   You must acquire a timestamp before flushing the queue (e.g., tick the
   clock). This timestamp must be given as <em class="parameter"><code>ts</code></em>. Only entries lower than, or
   equal to, this timestamp are flushed. The timestamp is remembered as
   queue-&gt;flush.
</p></div><div class="refsect1"><a name="id-1.12.29.7"></a><h2>Return</h2><p>
   Single-linked list of flushed entries.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-stage"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_stage — 
     stage queue entry with fresh timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_stage </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, struct bus1_queue_node * <var class="pdparam">node</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.30.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to stage
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     minimum timestamp for <em class="parameter"><code>node</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.30.6"></a><h2>Description</h2><p>
   Link a queue entry with a new timestamp. The staging entry blocks all
   messages with timestamps synced on this queue in the future, as well as any
   messages with a timestamp greater than <em class="parameter"><code>timestamp</code></em>. However, it does not block
   any messages already committed to this queue.
   </p><p>

   The caller must provide an even timestamp and the entry may not already have
   been committed.
</p></div><div class="refsect1"><a name="id-1.12.30.7"></a><h2>Return</h2><p>
   The timestamp used.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-commit-staged"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_commit_staged — 
     commit staged queue entry with new timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_commit_staged </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, wait_queue_head_t * <var class="pdparam">waitq</var>, struct bus1_queue_node * <var class="pdparam">node</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.31.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait-queue to wake up on change, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to commit
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     new timestamp for <em class="parameter"><code>node</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.31.6"></a><h2>Description</h2><p>
   Update a staging queue entry according to <em class="parameter"><code>timestamp</code></em>. The timestamp must be
   even and the entry may not already have been committed.
   </p><p>

   Furthermore, the queue clock must be synced with the new timestamp *before*
   staging an entry. Similarly, the timestamp of an entry can only be
   increased, never decreased.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-commit-unstaged"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_commit_unstaged — 
     commit unstaged queue entry with new timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_commit_unstaged </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, wait_queue_head_t * <var class="pdparam">waitq</var>, struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.32.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait-queue to wake up on change, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to commit
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.32.6"></a><h2>Description</h2><p>
   Directly commit an unstaged queue entry to the destination queue. The entry
   must not be queued, yet.
   </p><p>

   The destination queue is ticked and the resulting timestamp is used to commit
   the queue entry.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-commit-synthetic"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_commit_synthetic — 
     commit synthetic entry
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_commit_synthetic </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, struct bus1_queue_node * <var class="pdparam">node</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.33.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     entry to commit
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     timestamp to use
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.33.6"></a><h2>Description</h2><p>
   This inserts the unqueued entry <em class="parameter"><code>node</code></em> into the queue with the commit
   timestamp <em class="parameter"><code>timestamp</code></em> (just like <code class="function">bus1_queue_commit_unstaged</code>). However, it
   only does so if the new entry would NOT become the new front. It thus allows
   inserting fake synthetic entries somewhere in the middle of a queue, but
   accepts the possibility of failure.
</p></div><div class="refsect1"><a name="id-1.12.33.7"></a><h2>Return</h2><p>
   True if committed, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-remove"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_remove — 
     remove entry from queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_remove </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, wait_queue_head_t * <var class="pdparam">waitq</var>, struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.34.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait-queue to wake up on change, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to remove
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.34.6"></a><h2>Description</h2><p>
   This unlinks <em class="parameter"><code>node</code></em> and fully removes it from the queue <em class="parameter"><code>queue</code></em>. If you want
   to re-insert the node into a queue, you must re-initialize it first.
   </p><p>

   It is an error to call this on an unlinked entry.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-peek"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_peek — 
     peek first available entry
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_queue_node * <b class="fsfunc">bus1_queue_peek </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, bool * <var class="pdparam">morep</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.12.35.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>morep</code></em></span></dt><dd><p>
     where to store group-state
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.12.35.6"></a><h2>Description</h2><p>
   This returns a pointer to the first available entry in the given queue, or
   NULL if there is none. The queue stays unmodified and the returned entry
   remains on the queue.
   </p><p>

   This only returns entries that are ready to be dequeued. Entries that are
   still in staging mode will not be considered.
   </p><p>

   If a node is returned, its group-state is stored in <em class="parameter"><code>morep</code></em>. That means,
   if there are more messages queued as part of the same transaction, true is
   stored in <em class="parameter"><code>morep</code></em>. But if the returned node is the last part of the
   transaction, false is returned.
</p></div><div class="refsect1"><a name="id-1.12.35.7"></a><h2>Return</h2><p>
   Pointer to first available entry, NULL if none available.
</p></div></div></div></div></body></html>
