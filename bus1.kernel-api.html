<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>The Internal Bus1 API</title><link rel="stylesheet" type="text/css" href="bus1.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="icon" href="bus1.png" type="image/png"><script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75729104-1', 'auto');
      ga('send', 'pageview');
    </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><header><a href="index.html"><img src="bus1.svg" alt="bus1" style="width:48px;height:48px;"></a><span class="version">Version 1</span></header><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="BUS1-API"></a>The Internal Bus1 API</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#intro">1. Bus1 Overview</a></span></dt><dt><span class="chapter"><a href="#peer">2. Bus1 Peer</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer-info"><span class="phrase">struct bus1_peer_info</span></a></span><span class="refpurpose"> — 
  peer specific runtime information
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer"><span class="phrase">struct bus1_peer</span></a></span><span class="refpurpose"> — 
     peer handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-acquire"><span class="phrase">bus1_peer_acquire</span></a></span><span class="refpurpose"> — 
     acquire active reference to peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-release"><span class="phrase">bus1_peer_release</span></a></span><span class="refpurpose"> — 
     release an active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-dereference"><span class="phrase">bus1_peer_dereference</span></a></span><span class="refpurpose"> — 
     dereference a peer handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-wake"><span class="phrase">bus1_peer_wake</span></a></span><span class="refpurpose"> — 
     wake up peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-new"><span class="phrase">bus1_peer_new</span></a></span><span class="refpurpose"> — 
  allocate new peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-free"><span class="phrase">bus1_peer_free</span></a></span><span class="refpurpose"> — 
     destroy peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-disconnect"><span class="phrase">bus1_peer_disconnect</span></a></span><span class="refpurpose"> — 
     disconnect peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-ioctl-init"><span class="phrase">bus1_peer_ioctl_init</span></a></span><span class="refpurpose"> — 
     initialize peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-ioctl"><span class="phrase">bus1_peer_ioctl</span></a></span><span class="refpurpose"> — 
     handle peer ioctl
 </span></dt></dl></dd><dt><span class="chapter"><a href="#message">3. Bus1 Message</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-message"><span class="phrase">struct bus1_message</span></a></span><span class="refpurpose"> — 
  message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-from-node"><span class="phrase">bus1_message_from_node</span></a></span><span class="refpurpose"> — 
     get parent message of a queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-new"><span class="phrase">bus1_message_new</span></a></span><span class="refpurpose"> — 
  allocate new message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-free"><span class="phrase">bus1_message_free</span></a></span><span class="refpurpose"> — 
     destroy a message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-allocate"><span class="phrase">bus1_message_allocate</span></a></span><span class="refpurpose"> — 
     allocate pool slice for message payload
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-deallocate"><span class="phrase">bus1_message_deallocate</span></a></span><span class="refpurpose"> — 
     deallocate pool slice for message payload
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-install"><span class="phrase">bus1_message_install</span></a></span><span class="refpurpose"> — 
     install message payload into target process
 </span></dt></dl></dd><dt><span class="chapter"><a href="#transaction">4. Bus1 Transaction</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#id-1.6.4">
   ipc/bus1/transaction.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-new-from-user"><span class="phrase">bus1_transaction_new_from_user</span></a></span><span class="refpurpose"> — 
  create new transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-free"><span class="phrase">bus1_transaction_free</span></a></span><span class="refpurpose"> — 
     free transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-instantiate-for-id"><span class="phrase">bus1_transaction_instantiate_for_id</span></a></span><span class="refpurpose"> — 
     instantiate a message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-commit"><span class="phrase">bus1_transaction_commit</span></a></span><span class="refpurpose"> — 
     commit a transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-commit-for-id"><span class="phrase">bus1_transaction_commit_for_id</span></a></span><span class="refpurpose"> — 
     instantiate and commit unicast
 </span></dt></dl></dd><dt><span class="chapter"><a href="#handle">5. Bus1 Handle</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-dest"><span class="phrase">struct bus1_handle_dest</span></a></span><span class="refpurpose"> — 
  destination context
 </span></dt><dt><span class="refentrytitle"><a href="#API-BUS1-HANDLE-BATCH-SIZE"><span class="phrase">BUS1_HANDLE_BATCH_SIZE</span></a></span><span class="refpurpose"> — 
     number of handles per set in a batch
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-entry"><span class="phrase">union bus1_handle_entry</span></a></span><span class="refpurpose"> — 
     batch entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-batch"><span class="phrase">struct bus1_handle_batch</span></a></span><span class="refpurpose"> — 
     dynamic set of handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-transfer"><span class="phrase">struct bus1_handle_transfer</span></a></span><span class="refpurpose"> — 
     handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-inflight"><span class="phrase">struct bus1_handle_inflight</span></a></span><span class="refpurpose"> — 
     set of inflight handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-batch-inline-size"><span class="phrase">bus1_handle_batch_inline_size</span></a></span><span class="refpurpose"> — 
     calculate required inline size
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle"><span class="phrase">struct bus1_handle</span></a></span><span class="refpurpose"> — 
  handle objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-node"><span class="phrase">struct bus1_node</span></a></span><span class="refpurpose"> — 
     node objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-from-queue"><span class="phrase">bus1_handle_from_queue</span></a></span><span class="refpurpose"> — 
     peek or dequeue at queued handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-pair"><span class="phrase">bus1_handle_pair</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release-by-id"><span class="phrase">bus1_handle_release_by_id</span></a></span><span class="refpurpose"> — 
     release a user handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-destroy-by-id"><span class="phrase">bus1_handle_destroy_by_id</span></a></span><span class="refpurpose"> — 
     destroy a user handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-flush-all"><span class="phrase">bus1_handle_flush_all</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-init"><span class="phrase">bus1_handle_dest_init</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-destroy"><span class="phrase">bus1_handle_dest_destroy</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-import"><span class="phrase">bus1_handle_dest_import</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-export"><span class="phrase">bus1_handle_dest_export</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-init"><span class="phrase">bus1_handle_transfer_init</span></a></span><span class="refpurpose"> — 
     initialize handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-destroy"><span class="phrase">bus1_handle_transfer_destroy</span></a></span><span class="refpurpose"> — 
     destroy handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-import"><span class="phrase">bus1_handle_transfer_import</span></a></span><span class="refpurpose"> — 
     import handles for transfer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-install"><span class="phrase">bus1_handle_transfer_install</span></a></span><span class="refpurpose"> — 
     install new nodes of transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-export"><span class="phrase">bus1_handle_transfer_export</span></a></span><span class="refpurpose"> — 
     publish new nodes of transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-init"><span class="phrase">bus1_handle_inflight_init</span></a></span><span class="refpurpose"> — 
     initialize inflight context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-destroy"><span class="phrase">bus1_handle_inflight_destroy</span></a></span><span class="refpurpose"> — 
     destroy inflight-context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-import"><span class="phrase">bus1_handle_inflight_import</span></a></span><span class="refpurpose"> — 
     import inflight context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-install"><span class="phrase">bus1_handle_inflight_install</span></a></span><span class="refpurpose"> — 
     install inflight handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-walk"><span class="phrase">bus1_handle_inflight_walk</span></a></span><span class="refpurpose"> — 
     walk all handle IDs
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-commit"><span class="phrase">bus1_handle_inflight_commit</span></a></span><span class="refpurpose"> — 
     commit inflight context
 </span></dt></dl></dd><dt><span class="chapter"><a href="#user">6. Bus1 User</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-user"><span class="phrase">struct bus1_user</span></a></span><span class="refpurpose"> — 
  resource accounting for users
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-stats"><span class="phrase">struct bus1_user_stats</span></a></span><span class="refpurpose"> — 
     quota statistics between a user and a peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-quota"><span class="phrase">struct bus1_user_quota</span></a></span><span class="refpurpose"> — 
     quota handling
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref-by-uid"><span class="phrase">bus1_user_ref_by_uid</span></a></span><span class="refpurpose"> — 
  get a user object for a uid
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref"><span class="phrase">bus1_user_ref</span></a></span><span class="refpurpose"> — 
     acquire reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-unref"><span class="phrase">bus1_user_unref</span></a></span><span class="refpurpose"> — 
     release reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-init"><span class="phrase">bus1_user_quota_init</span></a></span><span class="refpurpose"> — 
     initialize quota object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-destroy"><span class="phrase">bus1_user_quota_destroy</span></a></span><span class="refpurpose"> — 
     destroy quota object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-charge"><span class="phrase">bus1_user_quota_charge</span></a></span><span class="refpurpose"> — 
     try charging a user
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-discharge"><span class="phrase">bus1_user_quota_discharge</span></a></span><span class="refpurpose"> — 
     discharge a user
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-commit"><span class="phrase">bus1_user_quota_commit</span></a></span><span class="refpurpose"> — 
     commit a quota charge
 </span></dt></dl></dd><dt><span class="chapter"><a href="#pool">7. Bus1 Pool</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool-slice"><span class="phrase">struct bus1_pool_slice</span></a></span><span class="refpurpose"> — 
  pool slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool"><span class="phrase">struct bus1_pool</span></a></span><span class="refpurpose"> — 
     client pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-create-internal"><span class="phrase">bus1_pool_create_internal</span></a></span><span class="refpurpose"> — 
  create memory pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-destroy"><span class="phrase">bus1_pool_destroy</span></a></span><span class="refpurpose"> — 
     pool to destroy
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-alloc"><span class="phrase">bus1_pool_alloc</span></a></span><span class="refpurpose"> — 
     allocate memory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-kernel"><span class="phrase">bus1_pool_release_kernel</span></a></span><span class="refpurpose"> — 
     release kernel-owned slice reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-publish"><span class="phrase">bus1_pool_publish</span></a></span><span class="refpurpose"> — 
     publish a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-user"><span class="phrase">bus1_pool_release_user</span></a></span><span class="refpurpose"> — 
     release a public slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-flush"><span class="phrase">bus1_pool_flush</span></a></span><span class="refpurpose"> — 
     flush all user references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-iovec"><span class="phrase">bus1_pool_write_iovec</span></a></span><span class="refpurpose"> — 
     copy user memory to a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-kvec"><span class="phrase">bus1_pool_write_kvec</span></a></span><span class="refpurpose"> — 
     copy kernel memory to a slice
 </span></dt></dl></dd><dt><span class="chapter"><a href="#queue">8. Bus1 Queue</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue"><span class="phrase">struct bus1_queue</span></a></span><span class="refpurpose"> — 
  message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue-node"><span class="phrase">struct bus1_queue_node</span></a></span><span class="refpurpose"> — 
     node into message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-tick"><span class="phrase">bus1_queue_tick</span></a></span><span class="refpurpose"> — 
     increment queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-sync"><span class="phrase">bus1_queue_sync</span></a></span><span class="refpurpose"> — 
     sync queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-peek-rcu"><span class="phrase">bus1_queue_peek_rcu</span></a></span><span class="refpurpose"> — 
     peek first available entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-is-readable"><span class="phrase">bus1_queue_is_readable</span></a></span><span class="refpurpose"> — 
     check whether a queue is readable
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-type"><span class="phrase">bus1_queue_node_get_type</span></a></span><span class="refpurpose"> — 
  query node type
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-timestamp"><span class="phrase">bus1_queue_node_get_timestamp</span></a></span><span class="refpurpose"> — 
     query node timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-init-internal"><span class="phrase">bus1_queue_init_internal</span></a></span><span class="refpurpose"> — 
     initialize queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-destroy"><span class="phrase">bus1_queue_destroy</span></a></span><span class="refpurpose"> — 
     destroy queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-post-flush"><span class="phrase">bus1_queue_post_flush</span></a></span><span class="refpurpose"> — 
     flush queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-stage"><span class="phrase">bus1_queue_stage</span></a></span><span class="refpurpose"> — 
     stage queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-remove"><span class="phrase">bus1_queue_remove</span></a></span><span class="refpurpose"> — 
     remove entry from queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-peek"><span class="phrase">bus1_queue_peek</span></a></span><span class="refpurpose"> — 
     peek first available entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-init"><span class="phrase">bus1_queue_node_init</span></a></span><span class="refpurpose"> — 
     initialize queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-destroy"><span class="phrase">bus1_queue_node_destroy</span></a></span><span class="refpurpose"> — 
     destroy queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-queued"><span class="phrase">bus1_queue_node_is_queued</span></a></span><span class="refpurpose"> — 
     check whether a node is queued
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-committed"><span class="phrase">bus1_queue_node_is_committed</span></a></span><span class="refpurpose"> — 
     check whether a node is committed
 </span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="intro"></a>Chapter 1. Bus1 Overview</h1></div></div></div><p>
   </p><p>
   The bus1.ko module is a local IPC technology which provides a decentralized
   infrastructure to share objects between local peers. The main building
   blocks are nodes and handles. Nodes represent objects of a local peer,
   while handles represent descriptors that point to a node. Nodes can be
   created and destroyed by any peer, and they will always remain owned by
   their respective creator. Handles, on the other hand, are used to refer to
   nodes and can be passed around with messages as auxiliary data. Whenever a
   handle is transferred, the receiver will get its own handle allocated,
   pointing to the same node as the original handle.
   </p><p>
   Any peer can send messages directed at one of their handles. This will
   transfer the message to the owner of the node the handle points to. If a
   peer does not posess a handle to a given node, it will not be able to send a
   message to that node. That is, handles provide exclusive access management.
   Anyone that somehow acquired a handle to a node is privileged to further
   send this handle to other peers. As such, access management is transitive.
   Once a peer acquired a handle, it cannot be revoked again. However, a node
   owner can, at anytime, destroy a node. This will effectively unbind all
   existing handles to that node on any peer, notifying each one of the
   destruction.
   </p><p>
   Unlike nodes and handles, peers cannot be addressed directly. In fact, peers
   are completely unconnected entities in bus1.ko. A peer is merely an anchor
   of a set of nodes and handles, including an incoming message queue for any
   of those. Whether multiple nodes are all part of the same set (and as such
   the same peer), or part of different sets, does not affect the remote view
   of those. Peers solely exist as management entity and command dispatcher to
   local processes.
   </p><p>
   The set of actors on a system is completely decentralized. There is no
   global component involved that provides a central registry or discovery
   mechanism. Furthermore, communication between peers only involves those
   peers, and does not affect any other peer in any way. No global
   communication lock is taken. However, any communication is still globally
   ordered, including unicasts, multicasts, and notifications.
</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="peer"></a>Chapter 2. Bus1 Peer</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer-info"><span class="phrase">struct bus1_peer_info</span></a></span><span class="refpurpose"> — 
  peer specific runtime information
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer"><span class="phrase">struct bus1_peer</span></a></span><span class="refpurpose"> — 
     peer handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-acquire"><span class="phrase">bus1_peer_acquire</span></a></span><span class="refpurpose"> — 
     acquire active reference to peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-release"><span class="phrase">bus1_peer_release</span></a></span><span class="refpurpose"> — 
     release an active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-dereference"><span class="phrase">bus1_peer_dereference</span></a></span><span class="refpurpose"> — 
     dereference a peer handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-wake"><span class="phrase">bus1_peer_wake</span></a></span><span class="refpurpose"> — 
     wake up peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-new"><span class="phrase">bus1_peer_new</span></a></span><span class="refpurpose"> — 
  allocate new peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-free"><span class="phrase">bus1_peer_free</span></a></span><span class="refpurpose"> — 
     destroy peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-disconnect"><span class="phrase">bus1_peer_disconnect</span></a></span><span class="refpurpose"> — 
     disconnect peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-ioctl-init"><span class="phrase">bus1_peer_ioctl_init</span></a></span><span class="refpurpose"> — 
     initialize peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-ioctl"><span class="phrase">bus1_peer_ioctl</span></a></span><span class="refpurpose"> — 
     handle peer ioctl
 </span></dt></dl></div><p>
   </p><p>
   XXX
</p><div class="refentry"><a name="API-struct-bus1-peer-info"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_peer_info — 
  peer specific runtime information
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_peer_info {
  union {unnamed_union};
  const struct cred * cred;
  struct pid_namespace * pid_ns;
  struct bus1_user * user;
  struct bus1_user_quota quota;
  struct bus1_pool pool;
  struct bus1_queue queue;
  struct rb_root map_handles_by_id;
  struct rb_root map_handles_by_node;
  struct seqcount seqcount;
  atomic_t n_dropped;
  u64 handle_ids;
  size_t n_allocated;
  size_t n_messages;
  size_t n_handles;
  size_t n_fds;
};  </pre></div><div class="refsect1"><a name="id-1.4.4.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">{unnamed_union}</span></dt><dd><p>
anonymous
      </p></dd><dt><span class="term">cred</span></dt><dd><p>
user creds
      </p></dd><dt><span class="term">pid_ns</span></dt><dd><p>
user pid namespace
      </p></dd><dt><span class="term">user</span></dt><dd><p>
object owner
      </p></dd><dt><span class="term">quota</span></dt><dd><p>
quota handling
      </p></dd><dt><span class="term">pool</span></dt><dd><p>
data pool
      </p></dd><dt><span class="term">queue</span></dt><dd><p>
message queue, rcu-accessible
      </p></dd><dt><span class="term">map_handles_by_id</span></dt><dd><p>
map of owned handles, by handle id
      </p></dd><dt><span class="term">map_handles_by_node</span></dt><dd><p>
map of owned handles, by node pointer
      </p></dd><dt><span class="term">seqcount</span></dt><dd><p>
sequence counter
      </p></dd><dt><span class="term">n_dropped</span></dt><dd><p>
number of lost messages since last report
      </p></dd><dt><span class="term">handle_ids</span></dt><dd><p>
handle ID allocator
      </p></dd><dt><span class="term">n_allocated</span></dt><dd><p>
remaining quota for allocated pool memory
      </p></dd><dt><span class="term">n_messages</span></dt><dd><p>
remaining quota for owned messages
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
remaining quota for owned handles
      </p></dd><dt><span class="term">n_fds</span></dt><dd><p>
remaining quota for inflight FDs
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-peer"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_peer — 
     peer handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_peer {
  struct rcu_head rcu;
  wait_queue_head_t waitq;
  struct bus1_active active;
  struct bus1_peer_info __rcu * info;
};  </pre></div><div class="refsect1"><a name="id-1.4.5.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">rcu</span></dt><dd><p>
   rcu
      </p></dd><dt><span class="term">waitq</span></dt><dd><p>
   peer wide wait queue
      </p></dd><dt><span class="term">active</span></dt><dd><p>
   active references
      </p></dd><dt><span class="term">info</span></dt><dd><p>
   underlying peer information
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-acquire"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_acquire — 
     acquire active reference to peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_acquire </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.6.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.6.6"></a><h2>Description</h2><p>
   Acquire a new active reference to the given peer. If the peer was not
   activated yet, or if it was already deactivated, this will fail.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.4.6.7"></a><h2>Return</h2><p>
   Pointer to peer, NULL on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-release"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_release — 
     release an active reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_release </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.7.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     handle to release, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.7.6"></a><h2>Description</h2><p>
   This releases an active reference to a peer, acquired previously via one
   of the lookup functions.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.4.7.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-dereference"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_dereference — 
     dereference a peer handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer_info * <b class="fsfunc">bus1_peer_dereference </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     handle to dereference
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.8.6"></a><h2>Description</h2><p>
   Dereference a peer handle to get access to the underlying peer object. This
   function simply returns the pointer to the linked peer information object,
   which then can be accessed directly by the caller. The caller must hold an
   active reference to the handle, and retain it as long as the peer object is
   used.
   </p><p>

   You are perfectly free to access <em class="parameter"><code>peer</code></em>-&gt;info directly, if you are aware of
   the lifetime restrictions. This function provides lockdep-annotations to
   protect against gross misuse.
</p></div><div class="refsect1"><a name="id-1.4.8.7"></a><h2>Return</h2><p>
   Pointer to the underlying peer information object is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-wake"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_wake — 
     wake up peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_peer_wake </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to wake up
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.9.6"></a><h2>Description</h2><p>
   This wakes up a peer and notifies user-space about <code class="function">poll</code> events.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-new"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_new — 
  allocate new peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_new </b>(</code> <var class="pdparam">void</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>void</code></em></span></dt><dd><p>
     no arguments
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.10.6"></a><h2>Description</h2><p>
   </p><p>

   Allocate a new peer. The peer is *not* activated, nor linked into any
   context. The caller owns the only pointer to the new peer.
</p></div><div class="refsect1"><a name="id-1.4.10.7"></a><h2>Return</h2><p>
   Pointer to peer, ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_free — 
     destroy peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_free </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.11.6"></a><h2>Description</h2><p>
   Destroy a peer object that was previously allocated via <code class="function">bus1_peer_new</code>. If
   the peer object was activated, then the caller must make sure it was
   properly torn down before destroying it.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.4.11.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-disconnect"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_disconnect — 
     disconnect peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_peer_disconnect </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.12.6"></a><h2>Description</h2><p>
   This tears down a peer synchronously. It first marks the peer as deactivated,
   waits for all outstanding operations to finish, and eventually releases the
   linked peer_info object.
   </p><p>

   It is perfectly safe to call this function multiple times, even in parallel.
   It is guaranteed to block *until* the peer is fully torn down, regardless
   whether this was the call to tear it down, or not.
</p></div><div class="refsect1"><a name="id-1.4.12.7"></a><h2>Return</h2><p>
   0 on success, negative error code if already torn down.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-ioctl-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_ioctl_init — 
     initialize peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_peer_ioctl_init </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, unsigned long <var class="pdparam">arg</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>arg</code></em></span></dt><dd><p>
     ioctl argument
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.13.6"></a><h2>Description</h2><p>
   This initializes a peer that was created by an <code class="function">open</code> call, by creating a
   peer_info object and linking it into the peer.
   </p><p>

   The caller must not hold any active reference to the peer.
</p></div><div class="refsect1"><a name="id-1.4.13.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-ioctl"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_ioctl — 
     handle peer ioctl
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_peer_ioctl </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, struct file * <var class="pdparam">peer_file</var>, unsigned int <var class="pdparam">cmd</var>, unsigned long <var class="pdparam">arg</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to work on
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_file</code></em></span></dt><dd><p>
     underlying file of <em class="parameter"><code>peer</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>cmd</code></em></span></dt><dd><p>
     ioctl command
    </p></dd><dt><span class="term"><em class="parameter"><code>arg</code></em></span></dt><dd><p>
     ioctl argument
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.14.6"></a><h2>Description</h2><p>
   This handles the given ioctl (cmd+arg) on the passed peer. The caller must
   hold an active reference to <em class="parameter"><code>peer</code></em>.
   </p><p>

   This only handles the runtime ioctls. Setup and teardown must be called
   directly.
   </p><p>

   Multiple ioctls can be called in parallel just fine. No locking is needed.
</p></div><div class="refsect1"><a name="id-1.4.14.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="message"></a>Chapter 3. Bus1 Message</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-message"><span class="phrase">struct bus1_message</span></a></span><span class="refpurpose"> — 
  message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-from-node"><span class="phrase">bus1_message_from_node</span></a></span><span class="refpurpose"> — 
     get parent message of a queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-new"><span class="phrase">bus1_message_new</span></a></span><span class="refpurpose"> — 
  allocate new message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-free"><span class="phrase">bus1_message_free</span></a></span><span class="refpurpose"> — 
     destroy a message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-allocate"><span class="phrase">bus1_message_allocate</span></a></span><span class="refpurpose"> — 
     allocate pool slice for message payload
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-deallocate"><span class="phrase">bus1_message_deallocate</span></a></span><span class="refpurpose"> — 
     deallocate pool slice for message payload
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-install"><span class="phrase">bus1_message_install</span></a></span><span class="refpurpose"> — 
     install message payload into target process
 </span></dt></dl></div><p>
   </p><p>
   XXX
</p><div class="refentry"><a name="API-struct-bus1-message"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_message — 
  message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_message {
  struct bus1_queue_node qnode;
  struct bus1_msg_data data;
  struct bus1_user * user;
  struct bus1_pool_slice * slice;
  struct file ** files;
  struct bus1_handle_inflight handles;
};  </pre></div><div class="refsect1"><a name="id-1.5.4.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">qnode</span></dt><dd><p>
embedded queue node
      </p></dd><dt><span class="term">data</span></dt><dd><p>
message data
<em class="parameter"><code>transaction</code></em>.next:		message list (during transactions)
<em class="parameter"><code>transaction</code></em>.dest:		pinned destination (during transactions)
      </p></dd><dt><span class="term">user</span></dt><dd><p>
sending user
      </p></dd><dt><span class="term">slice</span></dt><dd><p>
actual message data
      </p></dd><dt><span class="term">files</span></dt><dd><p>
passed file descriptors
      </p></dd><dt><span class="term">handles</span></dt><dd><p>
passed handles
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-from-node"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_from_node — 
     get parent message of a queue node
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_from_node </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.5.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to get parent of
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.5.6"></a><h2>Description</h2><p>
   This turns a queue node into a message. The caller must verify that the
   passed node is actually a message.
</p></div><div class="refsect1"><a name="id-1.5.5.7"></a><h2>Return</h2><p>
   Pointer to message is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-new"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_new — 
  allocate new message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_new </b>(</code>size_t <var class="pdparam">n_bytes</var>, size_t <var class="pdparam">n_files</var>, size_t <var class="pdparam">n_handles</var>, bool <var class="pdparam">silent</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.6.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>n_bytes</code></em></span></dt><dd><p>
     number of bytes to transmit
    </p></dd><dt><span class="term"><em class="parameter"><code>n_files</code></em></span></dt><dd><p>
     number of files to pre-allocate
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to pre-allocate
    </p></dd><dt><span class="term"><em class="parameter"><code>silent</code></em></span></dt><dd><p>
     is this a silent message?
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.6.6"></a><h2>Description</h2><p>
   This allocates a new, unused message for free use to the caller. Storage for
   files and handles is (partially) pre-allocated. The number of embedded
   handles is capped, so in case many handles are passed more memory will have
   to be allocated later.
</p></div><div class="refsect1"><a name="id-1.5.6.7"></a><h2>Return</h2><p>
   Pointer to new message, ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_free — 
     destroy a message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_free </b>(</code>struct bus1_message * <var class="pdparam">message</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.7.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to destroy, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     owning peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.7.6"></a><h2>Description</h2><p>
   This deallocates, destroys, and frees a message that was previously created
   via <code class="function">bus1_message_new</code>. The caller must take care to unlink the message from
   any queues before calling this. Furthermore, quotas must be handled before
   as well.
</p></div><div class="refsect1"><a name="id-1.5.7.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-allocate"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_allocate — 
     allocate pool slice for message payload
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_message_allocate </b>(</code>struct bus1_message * <var class="pdparam">message</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var>, struct bus1_user * <var class="pdparam">user</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to allocate slice for
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     destination peer
    </p></dd><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to account in-flight resources on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.8.6"></a><h2>Description</h2><p>
   Allocate a pool slice for the given message, and charge the quota of the
   given user for all the associated in-flight resources. The peer_info lock
   must be held by the caller.
</p></div><div class="refsect1"><a name="id-1.5.8.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-deallocate"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_deallocate — 
     deallocate pool slice for message payload
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_message_deallocate </b>(</code>struct bus1_message * <var class="pdparam">message</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to deallocate slice for
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     destination peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.9.6"></a><h2>Description</h2><p>
   If allocated, deallocate the slice for the given peer and discharge the
   associated user quota. The peer_info lock must be held by the caller.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-install"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_install — 
     install message payload into target process
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_message_install </b>(</code>struct bus1_message * <var class="pdparam">message</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     calling peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.10.6"></a><h2>Description</h2><p>
   This installs the payload FDs and handles of <em class="parameter"><code>message</code></em> into <em class="parameter"><code>peer_info</code></em> and
   the calling process.
</p></div><div class="refsect1"><a name="id-1.5.10.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="transaction"></a>Chapter 4. Bus1 Transaction</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#id-1.6.4">
   ipc/bus1/transaction.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-new-from-user"><span class="phrase">bus1_transaction_new_from_user</span></a></span><span class="refpurpose"> — 
  create new transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-free"><span class="phrase">bus1_transaction_free</span></a></span><span class="refpurpose"> — 
     free transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-instantiate-for-id"><span class="phrase">bus1_transaction_instantiate_for_id</span></a></span><span class="refpurpose"> — 
     instantiate a message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-commit"><span class="phrase">bus1_transaction_commit</span></a></span><span class="refpurpose"> — 
     commit a transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-commit-for-id"><span class="phrase">bus1_transaction_commit_for_id</span></a></span><span class="refpurpose"> — 
     instantiate and commit unicast
 </span></dt></dl></div><p>
   </p><p>
   XXX
</p><div class="refentry"><a name="id-1.6.4"></a><div class="titlepage"></div><div class="refnamediv"><p>
   ipc/bus1/transaction.h
   — 
   Document generation inconsistency
  </p></div><div class="refsect1"><a name="id-1.6.4.2"></a><h2>
   Oops
  </h2><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
    The template for this document tried to insert
    the structured comment from the file
    <code class="filename">ipc/bus1/transaction.h</code> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </p></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-new-from-user"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_new_from_user — 
  create new transaction
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_transaction * <b class="fsfunc">bus1_transaction_new_from_user </b>(</code>u8 * <var class="pdparam">stack_buffer</var>, size_t <var class="pdparam">stack_size</var>, struct bus1_peer * <var class="pdparam">peer</var>, struct bus1_cmd_send * <var class="pdparam">param</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.5.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>stack_buffer</code></em></span></dt><dd><p>
     stack buffer to use as backing memory
    </p></dd><dt><span class="term"><em class="parameter"><code>stack_size</code></em></span></dt><dd><p>
     size of <em class="parameter"><code>stack_buffer</code></em> in bytes
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     origin of this transaction
    </p></dd><dt><span class="term"><em class="parameter"><code>param</code></em></span></dt><dd><p>
     transaction parameters
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.5.6"></a><h2>Description</h2><p>
   This allocates a new transaction object for a user-transaction as specified
   via <em class="parameter"><code>param</code></em>. The transaction is optionally put onto the stack, if the passed
   buffer <em class="parameter"><code>stack_buffer</code></em> is big enough. Otherwise, the memory is allocated. The
   caller must make sure to pass the same stack-pointer to
   <code class="function">bus1_transaction_free</code>.
   </p><p>

   The transaction object imports all its data from user-space. If anything
   fails, an error is returned.
   </p><p>

   Note that the transaction object relies on being local to the current task.
   That is, its lifetime must be limited to your own function lifetime. You
   must not pass pointers to transaction objects to contexts outside of this
   lifetime. This makes it possible to optimize access to 'current' (and its
   properties like creds and pids), and to place the transaction on the stack,
   when it fits.
</p></div><div class="refsect1"><a name="id-1.6.5.7"></a><h2>Return</h2><p>
   Pointer to transaction object, or ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_free — 
     free transaction
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_transaction * <b class="fsfunc">bus1_transaction_free </b>(</code>struct bus1_transaction * <var class="pdparam">transaction</var>, u8 * <var class="pdparam">stack_buffer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.6.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transaction</code></em></span></dt><dd><p>
     transaction to free, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>stack_buffer</code></em></span></dt><dd><p>
     stack buffer passed to constructor
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.6.6"></a><h2>Description</h2><p>
   This releases a transaction and all associated memory. If the transaction
   failed, any in-flight messages are dropped and pinned peers are released. If
   the transaction was successfull, this just releases the temporary data that
   was used for the transmission.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.6.6.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-instantiate-for-id"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_instantiate_for_id — 
     instantiate a message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_transaction_instantiate_for_id </b>(</code>struct bus1_transaction * <var class="pdparam">transaction</var>, u64 __user * <var class="pdparam">idp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.7.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transaction</code></em></span></dt><dd><p>
     transaction to work with
    </p></dd><dt><span class="term"><em class="parameter"><code>idp</code></em></span></dt><dd><p>
     user-space pointer with destination ID
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.7.6"></a><h2>Description</h2><p>
   Instantiate the message from the given transaction for the handle id
   in <em class="parameter"><code>idp</code></em>. A new pool-slice is allocated, a queue entry is created and the
   message is queued as in-flight message on the transaction object. The
   message is not linked on the destination, yet. You need to commit the
   transaction to actually link it on the destination queue.
</p></div><div class="refsect1"><a name="id-1.6.7.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-commit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_commit — 
     commit a transaction
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_transaction_commit </b>(</code>struct bus1_transaction * <var class="pdparam">transaction</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transaction</code></em></span></dt><dd><p>
     transaction to commit
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.8.6"></a><h2>Description</h2><p>
   This performs the final commit of this transaction. All instances of the
   message that have been created on this transaction are staged on their
   respective destination queues and committed. This function makes sure to
   adhere to global-order restrictions, hence, the caller *must* instantiate
   the message for each destination before committing the whole transaction.
   Otherwise, ordering would not be guaranteed.
   </p><p>

   This function flushes the entire transaction. Technically, you can
   instantiate further entries once this call returns and commit them again.
   However, they will be treated as a new message which just happens to have
   the same contents as the previous one. This might come in handy for messages
   that might be triggered multiple times (like peer notifications).
   </p><p>

   This function may fail if the handle id of newly allocated nodes cannot be
   written back to the caller. Errors due to racing node destructions are
   silently ignored.
</p></div><div class="refsect1"><a name="id-1.6.8.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-commit-for-id"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_commit_for_id — 
     instantiate and commit unicast
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_transaction_commit_for_id </b>(</code>struct bus1_transaction * <var class="pdparam">transaction</var>, u64 __user * <var class="pdparam">idp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transaction</code></em></span></dt><dd><p>
     transaction to use
    </p></dd><dt><span class="term"><em class="parameter"><code>idp</code></em></span></dt><dd><p>
     user-space pointer with destination ID
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.9.6"></a><h2>Description</h2><p>
   This is a fast-path for unicast messages. It is equivalent to calling
   <code class="function">bus1_transaction_instantiate_for_id</code>, followed by <code class="function">bus1_transaction_commit</code>.
</p></div><div class="refsect1"><a name="id-1.6.9.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="handle"></a>Chapter 5. Bus1 Handle</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-dest"><span class="phrase">struct bus1_handle_dest</span></a></span><span class="refpurpose"> — 
  destination context
 </span></dt><dt><span class="refentrytitle"><a href="#API-BUS1-HANDLE-BATCH-SIZE"><span class="phrase">BUS1_HANDLE_BATCH_SIZE</span></a></span><span class="refpurpose"> — 
     number of handles per set in a batch
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-entry"><span class="phrase">union bus1_handle_entry</span></a></span><span class="refpurpose"> — 
     batch entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-batch"><span class="phrase">struct bus1_handle_batch</span></a></span><span class="refpurpose"> — 
     dynamic set of handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-transfer"><span class="phrase">struct bus1_handle_transfer</span></a></span><span class="refpurpose"> — 
     handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-inflight"><span class="phrase">struct bus1_handle_inflight</span></a></span><span class="refpurpose"> — 
     set of inflight handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-batch-inline-size"><span class="phrase">bus1_handle_batch_inline_size</span></a></span><span class="refpurpose"> — 
     calculate required inline size
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle"><span class="phrase">struct bus1_handle</span></a></span><span class="refpurpose"> — 
  handle objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-node"><span class="phrase">struct bus1_node</span></a></span><span class="refpurpose"> — 
     node objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-from-queue"><span class="phrase">bus1_handle_from_queue</span></a></span><span class="refpurpose"> — 
     peek or dequeue at queued handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-pair"><span class="phrase">bus1_handle_pair</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release-by-id"><span class="phrase">bus1_handle_release_by_id</span></a></span><span class="refpurpose"> — 
     release a user handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-destroy-by-id"><span class="phrase">bus1_handle_destroy_by_id</span></a></span><span class="refpurpose"> — 
     destroy a user handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-flush-all"><span class="phrase">bus1_handle_flush_all</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-init"><span class="phrase">bus1_handle_dest_init</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-destroy"><span class="phrase">bus1_handle_dest_destroy</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-import"><span class="phrase">bus1_handle_dest_import</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-export"><span class="phrase">bus1_handle_dest_export</span></a></span><span class="refpurpose"> — 
     XXX
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-init"><span class="phrase">bus1_handle_transfer_init</span></a></span><span class="refpurpose"> — 
     initialize handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-destroy"><span class="phrase">bus1_handle_transfer_destroy</span></a></span><span class="refpurpose"> — 
     destroy handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-import"><span class="phrase">bus1_handle_transfer_import</span></a></span><span class="refpurpose"> — 
     import handles for transfer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-install"><span class="phrase">bus1_handle_transfer_install</span></a></span><span class="refpurpose"> — 
     install new nodes of transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-export"><span class="phrase">bus1_handle_transfer_export</span></a></span><span class="refpurpose"> — 
     publish new nodes of transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-init"><span class="phrase">bus1_handle_inflight_init</span></a></span><span class="refpurpose"> — 
     initialize inflight context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-destroy"><span class="phrase">bus1_handle_inflight_destroy</span></a></span><span class="refpurpose"> — 
     destroy inflight-context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-import"><span class="phrase">bus1_handle_inflight_import</span></a></span><span class="refpurpose"> — 
     import inflight context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-install"><span class="phrase">bus1_handle_inflight_install</span></a></span><span class="refpurpose"> — 
     install inflight handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-walk"><span class="phrase">bus1_handle_inflight_walk</span></a></span><span class="refpurpose"> — 
     walk all handle IDs
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-commit"><span class="phrase">bus1_handle_inflight_commit</span></a></span><span class="refpurpose"> — 
     commit inflight context
 </span></dt></dl></div><p>
   </p><p>
   The object system on a bus is based on nodes and handles. Any peer can
   allocate new, local objects at any time. They automatically become the sole
   owner of the object. Those objects can be passed as payload of messages. The
   recipient will thus gain a reference to the object as well. Additionally, an
   object can be the destination of a message, in which case the message is
   always sent to the original creator (and thus the owner) of the object.
   </p><p>
   Internally, objects are called 'nodes'. A reference to an object is a
   'handle'. Whenever a new node is created, the owner implicitly gains an
   handle as well. In fact, handles are the only way to refer to a node. The
   node itself is entirely hidden in the implementation.
   </p><p>
   Whenever a handle is passed as payload of a message, the target peer will
   gain a handle linked to the same underlying node. This works regardless
   whether the sender is the owner of the underlying node, or not.
   </p><p>
   Each peer can identify all its handles (both owned and un-owned) by a 64bit
   integer. The namespace is local to each peer, and the numbers cannot be
   compared with the numbers of other peers (in fact, they will be very likely
   to clash, but might still have *different* underlying nodes). However, if a
   peer receives a reference to the same node multiple times, the resulting
   handle will be the same. The kernel keeps count how often each peer owns a
   handle.
   </p><p>
   If a peer no longer requires a specific handle, it must release it. If the
   peer releases its last reference to a handle, the handle will be destroyed.
   </p><p>
   The ID of an handle is (almost) never reused. That is, once a handle was
   fully released, any new handle the peer receives will have a different ID.
   The only scenario where an ID is reused, is if the peer gains a new handle
   to an underlying node that it already owned a handle for earlier. This might
   happen, for instance, if a message is inflight that carries a handle that
   the peer was just about to release. Furthermore, the handle of the owner of
   a node is internally pinned. As such, it is always reused if the owner gains
   a handle to its own node again (this is required for explicit node
   destruction).
   Note that such ID-reuse is not guaranteed, though. If a peer used to own a
   handle, dropped it and gains another one for the same underlying node, the
   new ID might be completely different! The only guarantee here is: If the ID
   is the same as a previously owned ID, then the underlying node is still the
   same.
   </p><p>
   Once all handles to a specific node have been released, the node is
   unreferenced and is automatically destroyed. The owner of the node is
   notified of this, so it can destroy any linked state. Note that the owner of
   a node owns a handle themself, so it needs to release it as well to trigger
   the destruction of the node.
   Additionally, the owner of a node (and *only* the owner) can trigger
   destruction of a node manually (even if other peers still own handles). In
   this case, all peers that own a handle are notified by this.
   </p><p>
   Node destruction is fully synchronized with any transaction. That is, a node
   and all its handles are valid in every message that is transmitted *before*
   the notification of its destruction. Furthermore, no message after this
   notification will carry the ID of such a destructed node.
   Note that message transactions are fully async. That is, there is no unique
   point in time that a message is synchronized with another message. Hence,
   whether a specific handle passed with a message is still valid or not,
   cannot be predicted by the sender, but only by one of the receivers.
</p><div class="refentry"><a name="API-struct-bus1-handle-dest"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle_dest — 
  destination context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle_dest {
  struct bus1_handle * handle;
  struct bus1_peer * raw_peer;
  u64 __user * idp;
};  </pre></div><div class="refsect1"><a name="id-1.7.11.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">handle</span></dt><dd><p>
local destination handle
      </p></dd><dt><span class="term">raw_peer</span></dt><dd><p>
remote destination peer (raw active ref)
      </p></dd><dt><span class="term">idp</span></dt><dd><p>
user-memory to store allocated ID at
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-BUS1-HANDLE-BATCH-SIZE"></a><div class="titlepage"></div><div class="refnamediv"><p>BUS1_HANDLE_BATCH_SIZE — 
     number of handles per set in a batch
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef"> <b class="fsfunc">BUS1_HANDLE_BATCH_SIZE </b>(</code><code>void)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.12.5"></a><h2>Arguments</h2><p>
  None
 </p></div><div class="refsect1"><a name="id-1.7.12.6"></a><h2>Description</h2><p>
   </p><p>

   We need to support large handle transactions, bigger than any linear
   allocation we're supposed to do in a running kernel. Hence, we batch all
   handles in a transaction into sets of this size. The `bus1_handle_batch`
   object transparently hides this, and pretends it is a linear array.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle-entry"></a><div class="titlepage"></div><div class="refnamediv"><p>union bus1_handle_entry — 
     batch entry
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
union bus1_handle_entry {
  union bus1_handle_entry * next;
  struct bus1_handle * handle;
  u64 id;
};  </pre></div><div class="refsect1"><a name="id-1.7.13.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">next</span></dt><dd><p>
   pointer to next batch entry
      </p></dd><dt><span class="term">handle</span></dt><dd><p>
   pointer to stored handle
      </p></dd><dt><span class="term">id</span></dt><dd><p>
   stored handle ID
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.13.6"></a><h2>Description</h2><p>
   This union represents a single handle-entry in a batch. To support large
   batches, we only store a limited number of handles consequetively. Once the
   batch size is reached, a new batch is allocated and linked  This is all
   hidden in the batch implementation, the details are hidden from the caller.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle-batch"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle_batch — 
     dynamic set of handles
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle_batch {
  size_t n_entries;
  size_t n_handles;
  union bus1_handle_entry entries[0];
};  </pre></div><div class="refsect1"><a name="id-1.7.14.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_entries</span></dt><dd><p>
   number of ids or handles this batch carries (excluding
   .next pointers)
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
   number of slots that actually have a handle pinned
      </p></dd><dt><span class="term">entries[0]</span></dt><dd><p>
   stored entries
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.14.6"></a><h2>Description</h2><p>
   The batch object allows handling multiple handles in a single set. Each
   batch can store an unlimited number of handles, and internally they're
   grouped into batches of BUS1_HANDLE_BATCH_SIZE entries.
   </p><p>

   All handles are put into the trailing array <em class="parameter"><code>entries</code></em>. However, at most
   BUS1_HANDLE_BATCH_SIZE entries are stored there. If this number is exceeded,
   then batch-&gt;entries[BUS1_HANDLE_BATCH_SIZE].next points to the next
   dynamically allocated array of bus1_handle_entry objects. This can be
   extended as often as you want, to support unlimited sized batches.
   </p><p>

   The caller must not access <em class="parameter"><code>entries</code></em> directly!
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle-transfer"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle_transfer — 
     handle transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle_transfer {
  size_t n_new;
  struct bus1_handle_batch batch;
};  </pre></div><div class="refsect1"><a name="id-1.7.15.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_new</span></dt><dd><p>
   number of newly allocated nodes
      </p></dd><dt><span class="term">batch</span></dt><dd><p>
   associated handles
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.15.6"></a><h2>Description</h2><p>
   The bus1_handle_transfer object contains context state for message
   transactions, regarding handle transfers. It pins all the local handles of
   the sending peer for the whole duration of a transaction. It is usually used
   to instantiate bus1_handle_inflight objects for each destination.
   </p><p>

   A transfer context should have the same lifetime as the parent transaction
   context.
   </p><p>

   Note that the tail of the object contains a dynamically sized array with the
   first handle-set of <em class="parameter"><code>batch</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle-inflight"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle_inflight — 
     set of inflight handles
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle_inflight {
  size_t n_new;
  struct bus1_handle_batch batch;
};  </pre></div><div class="refsect1"><a name="id-1.7.16.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_new</span></dt><dd><p>
   number of newly allocated nodes
      </p></dd><dt><span class="term">batch</span></dt><dd><p>
   associated handles
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.16.6"></a><h2>Description</h2><p>
   The bus1_handle_inflight object carries state for each message instance
   regarding handle transfers. That is, it contains all the handle instances
   for the receiver of the message (while bus1_handle_transfer pins the handles
   of the sender). This object is usually embedded in the queue-entry that is
   used to send a single message instance to another peer.
   </p><p>

   Note that the tail of the object contains a dynamically sized array with the
   first handle-set of <em class="parameter"><code>batch</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-batch-inline-size"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_batch_inline_size — 
     calculate required inline size
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">size_t <b class="fsfunc">bus1_handle_batch_inline_size </b>(</code>size_t <var class="pdparam">n_entries</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>n_entries</code></em></span></dt><dd><p>
     size of batch
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.17.6"></a><h2>Description</h2><p>
   This calculates the size of the trailing entries array that is to be
   embedded into a <span class="quote">“<span class="quote">struct bus1_handle_batch</span>”</span>. That is, to statically allocate
   a batch, you need a memory block of size:
   </p><p>

   sizeof(struct bus1_handle_batch) + bus1_handle_batch_inline_size(n);
   </p><p>

   where 'n' is the number of entries to store. Note that <em class="parameter"><code>n</code></em> is capped. You
   still need to call <code class="function">bus1_handle_batch_create</code> afterwards, to make sure the
   memory is properly allocated, in case it does not fit into a single set.
</p></div><div class="refsect1"><a name="id-1.7.17.7"></a><h2>Return</h2><p>
   Size of required trailing bytes of a batch structure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle — 
  handle objects
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle {
  struct kref ref;
  atomic_t n_inflight;
  atomic_t n_user;
  struct rb_node rb_id;
  struct rb_node rb_node;
  struct bus1_node * node;
  u64 id;
  struct bus1_peer __rcu * holder;
  struct list_head link_node;
  union {unnamed_union};
};  </pre></div><div class="refsect1"><a name="id-1.7.18.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">ref</span></dt><dd><p>
object ref-count
      </p></dd><dt><span class="term">n_inflight</span></dt><dd><p>
number of inflight references; initially -1 if
unattached; &gt;0 if live; 0 if about to be detached
      </p></dd><dt><span class="term">n_user</span></dt><dd><p>
number of user-visible references (shifted by -1)
      </p></dd><dt><span class="term">rb_id</span></dt><dd><p>
link into owning peer, based on ID
      </p></dd><dt><span class="term">rb_node</span></dt><dd><p>
link into owning peer, based on node pointer
      </p></dd><dt><span class="term">node</span></dt><dd><p>
node this handle is linked to
      </p></dd><dt><span class="term">id</span></dt><dd><p>
current ID of this handle
      </p></dd><dt><span class="term">holder</span></dt><dd><p>
holder of this node
      </p></dd><dt><span class="term">link_node</span></dt><dd><p>
link into the node
      </p></dd><dt><span class="term">{unnamed_union}</span></dt><dd><p>
anonymous
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-node"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_node — 
     node objects
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_node {
  struct kref ref;
  u64 timestamp;
  struct list_head list_handles;
  struct completion completion;
  struct bus1_handle owner;
};  </pre></div><div class="refsect1"><a name="id-1.7.19.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">ref</span></dt><dd><p>
   object ref-count
      </p></dd><dt><span class="term">timestamp</span></dt><dd><p>
   destruction timestamp; 0 if not live yet; 1 if live;
   3 if selected for destruction; even timestamp if
   destruction is committed
      </p></dd><dt><span class="term">list_handles</span></dt><dd><p>
   linked list of registered handles
      </p></dd><dt><span class="term">completion</span></dt><dd><p>
   destruction wait-queue
      </p></dd><dt><span class="term">owner</span></dt><dd><p>
   embedded handle of node owner
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-from-queue"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_from_queue — 
     peek or dequeue at queued handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_handle_from_queue </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var>, bool <var class="pdparam">drop</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.20.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     peer that owns the entry
    </p></dd><dt><span class="term"><em class="parameter"><code>drop</code></em></span></dt><dd><p>
     whether to drop the queue entry
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.20.6"></a><h2>Description</h2><p>
   This returns the handle-id of the queued handle-notification <em class="parameter"><code>node</code></em>.
   <em class="parameter"><code>peer_info</code></em> must be the holder of <em class="parameter"><code>node</code></em> and must be locked by the caller.
   </p><p>

   If <em class="parameter"><code>drop</code></em> is true, <em class="parameter"><code>node</code></em> is dequeued and destroyed. Otherwise, it is left on
   the queue.
</p></div><div class="refsect1"><a name="id-1.7.20.7"></a><h2>Return</h2><p>
   Handle ID, or BUS1_HANDLE_INVALID if unknown to the user.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-pair"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_pair — 
     XXX
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_pair </b>(</code>struct bus1_peer * <var class="pdparam">clone</var>, struct bus1_peer * <var class="pdparam">peer</var>, u64 * <var class="pdparam">node_idp</var>, u64 * <var class="pdparam">handle_idp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.21.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>clone</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>node_idp</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>handle_idp</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-release-by-id"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_release_by_id — 
     release a user handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_release_by_id </b>(</code>struct bus1_peer_info * <var class="pdparam">peer_info</var>, u64 <var class="pdparam">id</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.22.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     peer to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>id</code></em></span></dt><dd><p>
     handle ID
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.22.6"></a><h2>Description</h2><p>
   This releases a *user* visible reference to the handle with the given ID.
</p></div><div class="refsect1"><a name="id-1.7.22.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-destroy-by-id"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_destroy_by_id — 
     destroy a user handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_destroy_by_id </b>(</code>struct bus1_peer_info * <var class="pdparam">peer_info</var>, u64 <var class="pdparam">id</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.23.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     peer to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>id</code></em></span></dt><dd><p>
     handle ID
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.23.6"></a><h2>Description</h2><p>
   This destroys the underlying node of the handle with the given ID.
</p></div><div class="refsect1"><a name="id-1.7.23.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-flush-all"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_flush_all — 
     XXX
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_flush_all </b>(</code>struct bus1_peer_info * <var class="pdparam">peer_info</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.24.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-dest-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_dest_init — 
     XXX
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_dest_init </b>(</code>struct bus1_handle_dest * <var class="pdparam">dest</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.25.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>dest</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-dest-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_dest_destroy — 
     XXX
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_dest_destroy </b>(</code>struct bus1_handle_dest * <var class="pdparam">dest</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.26.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>dest</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-dest-import"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_dest_import — 
     XXX
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_dest_import </b>(</code>struct bus1_handle_dest * <var class="pdparam">dest</var>, struct bus1_peer * <var class="pdparam">peer</var>, u64 __user * <var class="pdparam">idp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.27.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>dest</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>idp</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-dest-export"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_dest_export — 
     XXX
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_handle_dest_export </b>(</code>struct bus1_handle_dest * <var class="pdparam">dest</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var>, u64 <var class="pdparam">timestamp</var>, bool <var class="pdparam">commit</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.28.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>dest</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>commit</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_init — 
     initialize handle transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_transfer_init </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var>, size_t <var class="pdparam">n_entries</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.29.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>n_entries</code></em></span></dt><dd><p>
     number of handles that are transferred
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.29.6"></a><h2>Description</h2><p>
   This initializes a handle-transfer context. This object is needed to lookup,
   pin, and optionally create, the handles of the sender during a transaction.
   That is, for each transaction, you need one handle-transfer object,
   initialized with the number of handles to transfer.
   </p><p>

   Handles can be imported via <code class="function">bus1_handle_transfer_import</code>. Once done,
   the handle-inflight objects can be instantiated from it for each destination
   of the transaction.
   </p><p>

   The handle-transfer context embeds a handle-batch, as such must be
   pre-allocated via <code class="function">bus1_handle_batch_inline_size</code>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_destroy — 
     destroy handle transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_transfer_destroy </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.30.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context to destroy, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     owning peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.30.6"></a><h2>Description</h2><p>
   This releases all data allocated, or pinned by a handle-transfer context. If
   NULL is passed, or if the transfer object was already destroyed, then
   nothing is done.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-import"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_import — 
     import handles for transfer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_transfer_import </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var>, const u64 __user * <var class="pdparam">ids</var>, size_t <var class="pdparam">n_ids</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.31.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     peer to import handles of
    </p></dd><dt><span class="term"><em class="parameter"><code>ids</code></em></span></dt><dd><p>
     user-space array of handle IDs
    </p></dd><dt><span class="term"><em class="parameter"><code>n_ids</code></em></span></dt><dd><p>
     number of IDs in <em class="parameter"><code>ids</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.31.6"></a><h2>Description</h2><p>
   This imports an array of handle-IDs from user-space (provided as <em class="parameter"><code>ids</code></em> +
   <em class="parameter"><code>n_ids</code></em>) into the transfer context. It then resolves each of them to their
   actual bus1_handle objects, optionally creating new ones on demand.
   </p><p>

   This can only be called once per transfer context. Also, <em class="parameter"><code>n_ids</code></em> must match
   the size used with <code class="function">bus1_handle_transfer_init</code>.
</p></div><div class="refsect1"><a name="id-1.7.31.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-install"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_install — 
     install new nodes of transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_transfer_install </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var>, struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.32.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     owning peer of <em class="parameter"><code>transfer</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.32.6"></a><h2>Description</h2><p>
   After a transfer-context is imported, all the newly instantiated nodes must
   be installed in the caller process. This function installs them and marks
   them as done. It must be called *before* any derived inflight object is
   installed.
   </p><p>

   The caller must hold the peer-lock of <em class="parameter"><code>peer</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-export"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_export — 
     publish new nodes of transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_transfer_export </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var>, u64 __user * <var class="pdparam">ids</var>, size_t <var class="pdparam">n_ids</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.33.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     owning peer of <em class="parameter"><code>transfer</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>ids</code></em></span></dt><dd><p>
     user pointer to store IDs to
    </p></dd><dt><span class="term"><em class="parameter"><code>n_ids</code></em></span></dt><dd><p>
     number of IDs
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.33.6"></a><h2>Description</h2><p>
   For every node that is created as part of an handle transfer, we have to
   publish a single user reference to the node and provide it back to the
   caller. This function both publishes those user-refs *and* directly copies
   them over into the user-provided buffers.
   </p><p>

   This calls releases all handles after they have been processes. Hence, this
   must be the last operation on a transfer object, before it is destroyed.
   </p><p>

   The caller must hold the peer lock of <em class="parameter"><code>peer_info</code></em>.
</p></div><div class="refsect1"><a name="id-1.7.33.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_init — 
     initialize inflight context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_inflight_init </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, size_t <var class="pdparam">n_entries</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.34.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>n_entries</code></em></span></dt><dd><p>
     number of entries to store in this context
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.34.6"></a><h2>Description</h2><p>
   This initializes an inflight-context to carry <em class="parameter"><code>n_entries</code></em> handles. An
   inflight-context is used to instantiate and commit the handles a peer
   *receives* via a transaction. That is, it is created once for each
   destination of a transaction, and it is instantiated from the
   transfer-context of the transaction origin/sender.
   </p><p>

   The inflight-context embeds a handle-batch, as such must be pre-allocated
   via <code class="function">bus1_handle_batch_inline_size</code>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_destroy — 
     destroy inflight-context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_inflight_destroy </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.35.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to destroy, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     owning peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.35.6"></a><h2>Description</h2><p>
   This releases all data allocated, or pinned by an inflight-context. If NULL
   is passed, or if the inflight context was already destroyed, then nothing is
   done.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-import"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_import — 
     import inflight context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_inflight_import </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var>, struct bus1_handle_transfer * <var class="pdparam">transfer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.36.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to instantiate
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     peer info to instantiate for
    </p></dd><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer object to instantiate from
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.36.6"></a><h2>Description</h2><p>
   Instantiate an inflight-context from an existing transfer-context. Import
   each pinned handle from the transfer-context into the peer <em class="parameter"><code>peer_info</code></em>,
   creating new handles if required. All the handles are pinned in the inflight
   context, but not committed, yet.
   </p><p>

   This must only be called once per inflight object. Furthermore, the number
   of handles must match the number of handles of the transfer-context.
</p></div><div class="refsect1"><a name="id-1.7.36.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-install"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_install — 
     install inflight handles
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_inflight_install </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer * <var class="pdparam">dst</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.37.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     instantiated inflight context
    </p></dd><dt><span class="term"><em class="parameter"><code>dst</code></em></span></dt><dd><p>
     peer <em class="parameter"><code>inflight</code></em> is for
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.37.6"></a><h2>Description</h2><p>
   After an inflight context was successfully instantiated, this will install
   the handles into the peer <em class="parameter"><code>dst</code></em>. The caller must provide the used transfer
   context and the origin peer as <em class="parameter"><code>transfer</code></em> and <em class="parameter"><code>src</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-walk"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_walk — 
     walk all handle IDs
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">size_t <b class="fsfunc">bus1_handle_inflight_walk </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var>, size_t * <var class="pdparam">pos</var>, void ** <var class="pdparam">iter</var>, u64 * <var class="pdparam">ids</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.38.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to walk
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     peer info of inflight owner
    </p></dd><dt><span class="term"><em class="parameter"><code>pos</code></em></span></dt><dd><p>
     current iterator position
    </p></dd><dt><span class="term"><em class="parameter"><code>iter</code></em></span></dt><dd><p>
     opaque iterator
    </p></dd><dt><span class="term"><em class="parameter"><code>ids</code></em></span></dt><dd><p>
     output storage for ID block
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     timestamp of the transaction
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.38.6"></a><h2>Description</h2><p>
   This walks over all stored handles of <em class="parameter"><code>inflight</code></em>, returning their IDs in
   blocks to the caller, instantiating them if necessary. If a given handle will
   be invalid at <em class="parameter"><code>timestamp</code></em>, BUS1_HANDLE_INVALID is returned instead. The caller
   must initialize <em class="parameter"><code>pos</code></em> to 0 and pre-allocate <em class="parameter"><code>ids</code></em> large enough to hold IDs of
   all stored handles, but at most BUS1_HANDLE_BATCH_SIZE.
   </p><p>

   On each call, this function advances <em class="parameter"><code>pos</code></em> and <em class="parameter"><code>iter</code></em> to keep track of the
   iteration, and updates <em class="parameter"><code>ids</code></em> with the handle IDs of the current block. It
   returns the size of the current block, which is at most
   BUS1_HANDLE_BATCH_SIZE.
   </p><p>

   Once this returns 0, the iteration is finished.
</p></div><div class="refsect1"><a name="id-1.7.38.7"></a><h2>Return</h2><p>
   Number of IDs in the next block, 0 if done.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-commit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_commit — 
     commit inflight context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_inflight_commit </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer_info * <var class="pdparam">peer_info</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.39.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to commit
    </p></dd><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.39.6"></a><h2>Description</h2><p>
   This commits a fully installed inflight context, given the timestamp of a
   transaction. This will make sure to only transfer the actual handle if it is
   ordered *before* the handle destruction.
   </p><p>

   This must be called after a successful walk via <code class="function">bus1_handle_inflight_walk</code>.
   You must not release the peer-lock in-between, and the same timestamp must
   be provided.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="user"></a>Chapter 6. Bus1 User</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-user"><span class="phrase">struct bus1_user</span></a></span><span class="refpurpose"> — 
  resource accounting for users
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-stats"><span class="phrase">struct bus1_user_stats</span></a></span><span class="refpurpose"> — 
     quota statistics between a user and a peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-quota"><span class="phrase">struct bus1_user_quota</span></a></span><span class="refpurpose"> — 
     quota handling
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref-by-uid"><span class="phrase">bus1_user_ref_by_uid</span></a></span><span class="refpurpose"> — 
  get a user object for a uid
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref"><span class="phrase">bus1_user_ref</span></a></span><span class="refpurpose"> — 
     acquire reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-unref"><span class="phrase">bus1_user_unref</span></a></span><span class="refpurpose"> — 
     release reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-init"><span class="phrase">bus1_user_quota_init</span></a></span><span class="refpurpose"> — 
     initialize quota object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-destroy"><span class="phrase">bus1_user_quota_destroy</span></a></span><span class="refpurpose"> — 
     destroy quota object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-charge"><span class="phrase">bus1_user_quota_charge</span></a></span><span class="refpurpose"> — 
     try charging a user
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-discharge"><span class="phrase">bus1_user_quota_discharge</span></a></span><span class="refpurpose"> — 
     discharge a user
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-commit"><span class="phrase">bus1_user_quota_commit</span></a></span><span class="refpurpose"> — 
     commit a quota charge
 </span></dt></dl></div><p>
   </p><p>
   Different users can communicate via bus1, and many resources are shared
   between multiple users. The bus1_user object represents the UID of a user,
   like <span class="quote">“<span class="quote">struct user_struct</span>”</span> does in the kernel core. It is used to account
   global resources, apply limits, and calculate quotas if different UIDs
   communicate with each other.
   </p><p>
   All dynamic resources have global per-user limits, which cannot be exceeded
   by a user. They prevent a single user from exhausting local resources. Each
   peer that is created is always owned by the user that initialized it. All
   resources allocated on that peer are accounted on that pinned user.
   Additionally to global resources, there are local limits per peer, that can
   be controlled by each peer individually (e.g., specifying a maximum pool
   size). Those local limits allow a user to distribute the globally available
   resources across its peer instances.
   </p><p>
   Since bus1 allows communication across UID boundaries, any such transmission
   of resources must be properly accounted. Bus1 employs dynamic quotas to
   fairly distribute available resources. That is, each transmission is seen by
   bus1 as a transmission of resources from a UID to a peer. Any transmitted
   resources are thus limited by a quota object that represents the combination
   of the sending UID and the receiving peer. This means, regardless how many
   different peers a possibly malicious user creates, they are accounted to the
   same limits. So whenever a UID transmits resources to a peer, it gets access
   to a dynamically calculated subset of the receiver's resource limits. But it
   never gets access to the entire resource space, so it cannot exhaust the
   resource limits of the receiver, but only its own quota on those resource
   limits.
</p><div class="refentry"><a name="API-struct-bus1-user"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_user — 
  resource accounting for users
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_user {
  struct kref ref;
  unsigned int id;
  kuid_t uid;
  union {unnamed_union};
};  </pre></div><div class="refsect1"><a name="id-1.8.6.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">ref</span></dt><dd><p>
reference counter
      </p></dd><dt><span class="term">id</span></dt><dd><p>
internal index of this user
      </p></dd><dt><span class="term">uid</span></dt><dd><p>
UID of the user
      </p></dd><dt><span class="term">{unnamed_union}</span></dt><dd><p>
anonymous
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-user-stats"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_user_stats — 
     quota statistics between a user and a peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_user_stats {
  u32 n_allocated;
  u16 n_messages;
  u16 n_handles;
  u16 n_fds;
};  </pre></div><div class="refsect1"><a name="id-1.8.7.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_allocated</span></dt><dd><p>
   memory in bytes used by queued messages
      </p></dd><dt><span class="term">n_messages</span></dt><dd><p>
   number of queued messages
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
   number of queued handles
      </p></dd><dt><span class="term">n_fds</span></dt><dd><p>
   number of queued fds
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-user-quota"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_user_quota — 
     quota handling
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_user_quota {
  size_t n_stats;
  struct bus1_user_stats * stats;
};  </pre></div><div class="refsect1"><a name="id-1.8.8.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_stats</span></dt><dd><p>
   number of allocated user entries
      </p></dd><dt><span class="term">stats</span></dt><dd><p>
   user entries
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-ref-by-uid"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_ref_by_uid — 
  get a user object for a uid
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_user * <b class="fsfunc">bus1_user_ref_by_uid </b>(</code>kuid_t <var class="pdparam">uid</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>uid</code></em></span></dt><dd><p>
     uid of the user
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.9.6"></a><h2>Description</h2><p>
   Find and return the user object for the uid if it exists, otherwise create
   it first.
</p></div><div class="refsect1"><a name="id-1.8.9.7"></a><h2>Return</h2><p>
   A user object for the given uid, ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-ref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_ref — 
     acquire reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_user * <b class="fsfunc">bus1_user_ref </b>(</code>struct bus1_user * <var class="pdparam">user</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to acquire, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.10.6"></a><h2>Description</h2><p>
   Acquire an additional reference to a user-object. The caller must already
   own a reference.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.8.10.7"></a><h2>Return</h2><p>
   <em class="parameter"><code>user</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-unref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_unref — 
     release reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_user * <b class="fsfunc">bus1_user_unref </b>(</code>struct bus1_user * <var class="pdparam">user</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to release, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.11.6"></a><h2>Description</h2><p>
   Release a reference to a user-object.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.8.11.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_init — 
     initialize quota object
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_quota_init </b>(</code>struct bus1_user_quota * <var class="pdparam">quota</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>quota</code></em></span></dt><dd><p>
     quota object to initialize
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.12.6"></a><h2>Description</h2><p>
   Initialize all fields of a quota object.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_destroy — 
     destroy quota object
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_quota_destroy </b>(</code>struct bus1_user_quota * <var class="pdparam">quota</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>quota</code></em></span></dt><dd><p>
     quota object to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.13.6"></a><h2>Description</h2><p>
   Destroy and deallocate a quota object. All linked resources are freed, and
   the object is ready for re-use.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-charge"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_charge — 
     try charging a user
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_user_quota_charge </b>(</code>struct bus1_peer_info * <var class="pdparam">peer_info</var>, struct bus1_user * <var class="pdparam">user</var>, size_t <var class="pdparam">size</var>, size_t <var class="pdparam">n_handles</var>, size_t <var class="pdparam">n_fds</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     peer with quota to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>size</code></em></span></dt><dd><p>
     size to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_fds</code></em></span></dt><dd><p>
     number of FDs to charge
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.14.6"></a><h2>Description</h2><p>
   This performs a quota charge on the passes quota object for the given user.
   It first checks whether any quota is exceeded, and if not, it accounts for
   the specified quantities on the quota and peer.
   </p><p>

   This charges for _one_ message with a size of <em class="parameter"><code>size</code></em> bytes, carrying
   <em class="parameter"><code>n_handles</code></em> handles and <em class="parameter"><code>n_fds</code></em> file descriptors as payload.
</p></div><div class="refsect1"><a name="id-1.8.14.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-discharge"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_discharge — 
     discharge a user
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_quota_discharge </b>(</code>struct bus1_peer_info * <var class="pdparam">peer_info</var>, struct bus1_user * <var class="pdparam">user</var>, size_t <var class="pdparam">size</var>, size_t <var class="pdparam">n_handles</var>, size_t <var class="pdparam">n_fds</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.15.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     peer with quota to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to discharge
    </p></dd><dt><span class="term"><em class="parameter"><code>size</code></em></span></dt><dd><p>
     size to discharge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to discharge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_fds</code></em></span></dt><dd><p>
     number of FDs to discharge
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.15.6"></a><h2>Description</h2><p>
   This reverts a single charge done via <code class="function">bus1_user_quota_charge</code>. It
   discharges a single message with a slice size of <em class="parameter"><code>size</code></em>, <em class="parameter"><code>n_handles</code></em> handles
   and <em class="parameter"><code>n_fds</code></em> file-descriptors.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-commit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_commit — 
     commit a quota charge
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_quota_commit </b>(</code>struct bus1_peer_info * <var class="pdparam">peer_info</var>, struct bus1_user * <var class="pdparam">user</var>, size_t <var class="pdparam">size</var>, size_t <var class="pdparam">n_handles</var>, size_t <var class="pdparam">n_fds</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.16.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer_info</code></em></span></dt><dd><p>
     peer with quota to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to commit for
    </p></dd><dt><span class="term"><em class="parameter"><code>size</code></em></span></dt><dd><p>
     size to commit
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to commit
    </p></dd><dt><span class="term"><em class="parameter"><code>n_fds</code></em></span></dt><dd><p>
     number of FDs to commit
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.16.6"></a><h2>Description</h2><p>
   Commit a quota charge to the receiving user. This de-accounts the in-flight
   charges, but keeps the actual object charges on the receiver. The caller must
   make sure the actual objects are de-accounted once they are destructed.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="pool"></a>Chapter 7. Bus1 Pool</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool-slice"><span class="phrase">struct bus1_pool_slice</span></a></span><span class="refpurpose"> — 
  pool slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool"><span class="phrase">struct bus1_pool</span></a></span><span class="refpurpose"> — 
     client pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-create-internal"><span class="phrase">bus1_pool_create_internal</span></a></span><span class="refpurpose"> — 
  create memory pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-destroy"><span class="phrase">bus1_pool_destroy</span></a></span><span class="refpurpose"> — 
     pool to destroy
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-alloc"><span class="phrase">bus1_pool_alloc</span></a></span><span class="refpurpose"> — 
     allocate memory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-kernel"><span class="phrase">bus1_pool_release_kernel</span></a></span><span class="refpurpose"> — 
     release kernel-owned slice reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-publish"><span class="phrase">bus1_pool_publish</span></a></span><span class="refpurpose"> — 
     publish a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-user"><span class="phrase">bus1_pool_release_user</span></a></span><span class="refpurpose"> — 
     release a public slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-flush"><span class="phrase">bus1_pool_flush</span></a></span><span class="refpurpose"> — 
     flush all user references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-iovec"><span class="phrase">bus1_pool_write_iovec</span></a></span><span class="refpurpose"> — 
     copy user memory to a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-kvec"><span class="phrase">bus1_pool_write_kvec</span></a></span><span class="refpurpose"> — 
     copy kernel memory to a slice
 </span></dt></dl></div><p>
   </p><p>
   Each connected peer has its own memory pool associated with the
   file-descriptor. This pool can be mapped read-only by the client. The pool
   is used to transfer memory from the kernel to the client; this includes
   query/list operations the client performs, but also messages received by
   other clients.
   </p><p>
   The pool is managed in slices, and clients have to free each slice after
   they are done with it.
   </p><p>
   If a client queries the kernel for large sets of data (especially if it has
   a non-static size), the kernel will put that data into a freshly allocated
   slice in the pool and lets the client know the offset and size. The client
   can then access the data directly and keep it allocated as long as it
   wishes.
   </p><p>
   During message transactions, a sender copies the message directly into a
   pool-slice allocated in the pool of the receiver. There is no in-flight
   buffer, as such, only a single copy operation is needed to transfer the
   message.
   </p><p>
   Note that no-one has direct write-access to pool memory. Furthermore, only
   the owner of a pool has read-access. Any data that is written into the pool
   is written by the kernel itself, accounted by a custom quota logic, and
   protected by client provided policies.
</p><div class="refentry"><a name="API-struct-bus1-pool-slice"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_pool_slice — 
  pool slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_pool_slice {
  u32 offset;
  u32 free:1;
  u32 ref_kernel:1;
  u32 ref_user:1;
  struct list_head entry;
  struct rb_node rb;
};  </pre></div><div class="refsect1"><a name="id-1.9.8.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">offset</span></dt><dd><p>
relative offset in parent pool
      </p></dd><dt><span class="term">free</span></dt><dd><p>
whether this slice is in-use or not
      </p></dd><dt><span class="term">ref_kernel</span></dt><dd><p>
whether a kernel reference exists
      </p></dd><dt><span class="term">ref_user</span></dt><dd><p>
whether a user reference exists
      </p></dd><dt><span class="term">entry</span></dt><dd><p>
link into linear list of slices
      </p></dd><dt><span class="term">rb</span></dt><dd><p>
link to busy/free rb-tree
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-pool"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_pool — 
     client pool
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_pool {
  struct file * f;
  size_t size;
  size_t allocated_size;
  struct list_head slices;
  struct rb_root slices_busy;
  struct rb_root slices_free;
};  </pre></div><div class="refsect1"><a name="id-1.9.9.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">f</span></dt><dd><p>
   backing shmem file
      </p></dd><dt><span class="term">size</span></dt><dd><p>
   size of the file
      </p></dd><dt><span class="term">allocated_size</span></dt><dd><p>
   currently allocated memory in bytes
      </p></dd><dt><span class="term">slices</span></dt><dd><p>
   all slices sorted by address
      </p></dd><dt><span class="term">slices_busy</span></dt><dd><p>
   tree of allocated slices
      </p></dd><dt><span class="term">slices_free</span></dt><dd><p>
   tree of free slices
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-create-internal"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_create_internal — 
  create memory pool
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_pool_create_internal </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, size_t <var class="pdparam">size</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     (uninitialized) pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>size</code></em></span></dt><dd><p>
     size of the pool
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.10.6"></a><h2>Description</h2><p>
   Initialize a new pool object. This allocates a backing shmem object with the
   given name and size.
   </p><p>

   Note that all pools must be embedded into a parent bus1_peer_info object. The
   code works fine, if you don't, but the lockdep-annotations will fail
   horribly. They rely on <code class="function">container_of</code> to be valid on every pool. Use the
   <code class="function">bus1_pool_create_for_peer</code> macro to make sure you never violate this rule.
</p></div><div class="refsect1"><a name="id-1.9.10.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_destroy — 
     pool to destroy
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_pool_destroy </b>(</code>struct bus1_pool * <var class="pdparam">pool</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.11.6"></a><h2>Description</h2><p>
   This destroys a pool that was previously create via <code class="function">bus1_pool_create</code>. If
   NULL is passed, or if <em class="parameter"><code>pool</code></em>-&gt;f is NULL (i.e., the pool was initialized to 0
   but not created via <code class="function">bus1_pool_create</code>, yet), then this is a no-op.
   </p><p>

   The caller must make sure that no kernel reference to any slice exists. Any
   pending user-space reference to any slice is dropped by this function.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-alloc"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_alloc — 
     allocate memory
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_pool_slice * <b class="fsfunc">bus1_pool_alloc </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, size_t <var class="pdparam">size</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to allocate memory from
    </p></dd><dt><span class="term"><em class="parameter"><code>size</code></em></span></dt><dd><p>
     number of bytes to allocate
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.12.6"></a><h2>Description</h2><p>
   This allocates a new slice of <em class="parameter"><code>size</code></em> bytes from the memory pool at <em class="parameter"><code>pool</code></em>. The
   slice must be released via <code class="function">bus1_pool_release_kernel</code> by the caller. All
   slices are aligned to 8 bytes (both offset and size).
   </p><p>

   If no suitable slice can be allocated, an error is returned.
   </p><p>

   Each pool slice can have two different references, a kernel reference and a
   user-space reference. Initially, it only has a kernel-reference, which must
   be dropped via <code class="function">bus1_pool_release_kernel</code>. However, if you previously
   publish the slice via <code class="function">bus1_pool_publish</code>, it will also have a user-space
   reference, which user-space must (indirectly) release via a call to
   <code class="function">bus1_pool_release_user</code>.
   A slice is only actually freed if neither reference exists, anymore. Hence,
   pool-slice can be held by both, the kernel and user-space, and both can rely
   on it staying around as long as they wish.
</p></div><div class="refsect1"><a name="id-1.9.12.7"></a><h2>Return</h2><p>
   Pointer to new slice, or ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-release-kernel"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_release_kernel — 
     release kernel-owned slice reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_pool_slice * <b class="fsfunc">bus1_pool_release_kernel </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to free memory on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to release
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.13.6"></a><h2>Description</h2><p>
   This releases the kernel-reference to a slice that was previously allocated
   via <code class="function">bus1_pool_alloc</code>. This only releases the kernel reference to the slice.
   If the slice was already published to user-space, then their reference is
   left untouched. Once both references are gone, the memory is actually freed.
</p></div><div class="refsect1"><a name="id-1.9.13.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-publish"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_publish — 
     publish a slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_pool_publish </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to publish
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.14.6"></a><h2>Description</h2><p>
   Publish a pool slice to user-space, so user-space can get access to it via
   the mapped pool memory. If the slice was already published, this is a no-op.
   Otherwise, the slice is marked as public and will only get freed once both
   the user-space reference *and* kernel-space reference are released.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-release-user"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_release_user — 
     release a public slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_pool_release_user </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, size_t <var class="pdparam">offset</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.15.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>
     offset of slice to release
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.15.6"></a><h2>Description</h2><p>
   Release the user-space reference to a pool-slice, specified via the offset
   of the slice. If both, the user-space reference *and* the kernel-space
   reference to the slice are gone, the slice will be actually freed.
   </p><p>

   If no slice exists with the given offset, or if there is no user-space
   reference to the specified slice, an error is returned.
</p></div><div class="refsect1"><a name="id-1.9.15.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-flush"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_flush — 
     flush all user references
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_pool_flush </b>(</code>struct bus1_pool * <var class="pdparam">pool</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.16.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to flush
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.16.6"></a><h2>Description</h2><p>
   This flushes all user-references to any slice in <em class="parameter"><code>pool</code></em>. Kernel references
   are left untouched.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-write-iovec"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_write_iovec — 
     copy user memory to a slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">ssize_t <b class="fsfunc">bus1_pool_write_iovec </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var>, loff_t <var class="pdparam">offset</var>, struct iovec * <var class="pdparam">iov</var>, size_t <var class="pdparam">n_iov</var>, size_t <var class="pdparam">total_len</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to write to
    </p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>
     relative offset into slice memory
    </p></dd><dt><span class="term"><em class="parameter"><code>iov</code></em></span></dt><dd><p>
     iovec array, pointing to data to copy
    </p></dd><dt><span class="term"><em class="parameter"><code>n_iov</code></em></span></dt><dd><p>
     number of elements in <em class="parameter"><code>iov</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>total_len</code></em></span></dt><dd><p>
     total number of bytes to copy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.17.6"></a><h2>Description</h2><p>
   This copies the memory pointed to by <em class="parameter"><code>iov</code></em> into the memory slice <em class="parameter"><code>slice</code></em> at
   relative offset <em class="parameter"><code>offset</code></em> (relative to begin of slice).
</p></div><div class="refsect1"><a name="id-1.9.17.7"></a><h2>Return</h2><p>
   Numbers of bytes copied, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-write-kvec"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_write_kvec — 
     copy kernel memory to a slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">ssize_t <b class="fsfunc">bus1_pool_write_kvec </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var>, loff_t <var class="pdparam">offset</var>, struct kvec * <var class="pdparam">iov</var>, size_t <var class="pdparam">n_iov</var>, size_t <var class="pdparam">total_len</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.18.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to write to
    </p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>
     relative offset into slice memory
    </p></dd><dt><span class="term"><em class="parameter"><code>iov</code></em></span></dt><dd><p>
     kvec array, pointing to data to copy
    </p></dd><dt><span class="term"><em class="parameter"><code>n_iov</code></em></span></dt><dd><p>
     number of elements in <em class="parameter"><code>iov</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>total_len</code></em></span></dt><dd><p>
     total number of bytes to copy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.18.6"></a><h2>Description</h2><p>
   This copies the memory pointed to by <em class="parameter"><code>iov</code></em> into the memory slice <em class="parameter"><code>slice</code></em> at
   relative offset <em class="parameter"><code>offset</code></em> (relative to begin of slice).
</p></div><div class="refsect1"><a name="id-1.9.18.7"></a><h2>Return</h2><p>
   Numbers of bytes copied, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="queue"></a>Chapter 8. Bus1 Queue</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue"><span class="phrase">struct bus1_queue</span></a></span><span class="refpurpose"> — 
  message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue-node"><span class="phrase">struct bus1_queue_node</span></a></span><span class="refpurpose"> — 
     node into message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-tick"><span class="phrase">bus1_queue_tick</span></a></span><span class="refpurpose"> — 
     increment queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-sync"><span class="phrase">bus1_queue_sync</span></a></span><span class="refpurpose"> — 
     sync queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-peek-rcu"><span class="phrase">bus1_queue_peek_rcu</span></a></span><span class="refpurpose"> — 
     peek first available entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-is-readable"><span class="phrase">bus1_queue_is_readable</span></a></span><span class="refpurpose"> — 
     check whether a queue is readable
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-type"><span class="phrase">bus1_queue_node_get_type</span></a></span><span class="refpurpose"> — 
  query node type
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-timestamp"><span class="phrase">bus1_queue_node_get_timestamp</span></a></span><span class="refpurpose"> — 
     query node timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-init-internal"><span class="phrase">bus1_queue_init_internal</span></a></span><span class="refpurpose"> — 
     initialize queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-destroy"><span class="phrase">bus1_queue_destroy</span></a></span><span class="refpurpose"> — 
     destroy queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-post-flush"><span class="phrase">bus1_queue_post_flush</span></a></span><span class="refpurpose"> — 
     flush queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-stage"><span class="phrase">bus1_queue_stage</span></a></span><span class="refpurpose"> — 
     stage queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-remove"><span class="phrase">bus1_queue_remove</span></a></span><span class="refpurpose"> — 
     remove entry from queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-peek"><span class="phrase">bus1_queue_peek</span></a></span><span class="refpurpose"> — 
     peek first available entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-init"><span class="phrase">bus1_queue_node_init</span></a></span><span class="refpurpose"> — 
     initialize queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-destroy"><span class="phrase">bus1_queue_node_destroy</span></a></span><span class="refpurpose"> — 
     destroy queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-queued"><span class="phrase">bus1_queue_node_is_queued</span></a></span><span class="refpurpose"> — 
     check whether a node is queued
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-committed"><span class="phrase">bus1_queue_node_is_committed</span></a></span><span class="refpurpose"> — 
     check whether a node is committed
 </span></dt></dl></div><p>
   </p><p>
   (You are highly encouraged to read up on 'Lamport Timestamps', the
   concept of 'happened-before', and 'causal ordering'. The queue
   implementation has its roots in Lamport Timestamps, treating a set of local
   CPUs as a distributed system to avoid any global synchronization.)
   </p><p>
   Every peer on the bus has its own message queue. This is used to queue all
   messages that are sent to this peer. From a user-space perspective, this
   queue is a FIFO, that is, messages are linearly ordered by their time they
   were sent. User-space can peek the first message, or dequeue it.
   </p><p>
   Messages can be destined for multiple peers, hence, we need to be careful
   that all peers get a consistent partial order of incoming messages. We
   define the concept of `global order' to give user-space a basic set of
   guarantees. This global order is a partial order on the set of all messages.
   The order is defined as:
   </p><p>
   1) If a message B was queued *after* a message A (i.e., the send-ioctl of
   A returned *before* the send-ioctl for B was entered), then: A &lt; B
   </p><p>
   2) If a message B was queued *after* a message A was dequeued (i.e., the
   recv-ioctl of A returned *before* the send-ioctl for B was entered),
   then: A &lt; B
   </p><p>
   3) If a peer dequeues a message B *after* it dequeued a message A (i.e.,
   the recv-ioctl of A returned *before* the recv-ioctl for B was
   entered), then: A &lt; B
   </p><p>
   (Note: Causality is honored. `after' and `before' do not refer to the
   same task, nor the same peer, but rather any kind of
   synchronization between the two operations.)
   </p><p>
   The queue object implements this global order in a lockless fashion. It
   solely relies on a distributed clock on each peer. Each message to be sent
   causes a clock tick on the local clock and on all destination clocks.
   Furthermore, all clocks are synchronized, meaning they're fast-forwarded in
   case they're behind the highest of all participating peers. No global state
   tracking is involved.
   </p><p>
   During a message transaction, we first queue a message as <span class="quote">“<span class="quote">staging</span>”</span> entry in
   each destination with a preliminary timestamp. This timestamp is explicitly
   odd numbered. Any odd numbered timestamp is considered 'staging' and causes
   *any* message ordered after it to be blocked until it is no longer staging.
   This allows us to queue the message in parallel with any racing multicast,
   and be guaranteed that all possible conflicts are blocked until we
   eventually committed a transaction.
   To commit a transaction (after all staging entries are queued), we choose
   the highest timestamp we have seen across all destinations and re-queue all
   our entries on each peer. Here we use a commit timestamp (even numbered).
   </p><p>
   With this in mind, we define that a client can only dequeue messages from
   its queue, which have an even timestamp. Furthermore, if there is a message
   queued with an odd timestamp that is lower than the even timestamp of
   another message, then neither message can be dequeued. They're considered to
   be in-flight conflicts. This guarantees that two concurrent multicast
   messages can be queued without any *global* locks, but either can only be
   dequeued by a peer if their ordering has been established (via commit
   timestamps).
   </p><p>
   NOTE: So far, in-flight messages is not blocked on. That is, a send-ioctl
   might return to user-space, but a following recv-ioctl on the
   destination of the message might fail with EAGAIN. That is, a message
   might be in-flight for an undefined amount of time.
   </p><p>
   In other words: Message transmission is not instantaneous.
   </p><p>
   The queue implementation uses an rb-tree (ordered by timestamps), with a
   cached pointer to the front of the queue. The front pointer is only set if
   the first entry in the queue is ready to be dequeued (that is, it has an
   even timestamp). If the first entry is not ready to be dequeued, or if the
   queue is empty, the front pointer is NULL.
   </p><p>
   The queue itself must be embedded into the parent peer structure. We do not
   access any of the peer-data from within the queue, but we rely on the
   peer-lock to be held by the caller (see each function for details of which
   locks are required). Therefore, the lockdep annotations might access the
   surrounding peer object that the queue is embedded in. See
   <code class="function">bus1_queue_init_internal</code> for details.
</p><div class="refentry"><a name="API-struct-bus1-queue"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_queue — 
  message queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_queue {
  struct rb_root messages;
  struct rb_node __rcu * front;
  size_t n_committed;
  u64 clock;
};  </pre></div><div class="refsect1"><a name="id-1.10.17.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">messages</span></dt><dd><p>
queued messages
      </p></dd><dt><span class="term">front</span></dt><dd><p>
cached front entry
      </p></dd><dt><span class="term">n_committed</span></dt><dd><p>
number of committed, non-silent entries
      </p></dd><dt><span class="term">clock</span></dt><dd><p>
local clock (used for Lamport Timestamps)
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-queue-node"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_queue_node — 
     node into message queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_queue_node {
  union {unnamed_union};
  u64 timestamp_and_type;
};  </pre></div><div class="refsect1"><a name="id-1.10.18.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">{unnamed_union}</span></dt><dd><p>
   anonymous
      </p></dd><dt><span class="term">timestamp_and_type</span></dt><dd><p>
   message timestamp and type of parent object
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-tick"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_tick — 
     increment queue clock
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_tick </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.19.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.19.6"></a><h2>Description</h2><p>
   This performs a clock-tick on <em class="parameter"><code>queue</code></em>. The clock is incremented by a full
   interval (+2). The caller is free to use both, the new value (even numbered)
   and its predecessor (odd numbered). Both are uniquely allocated to the
   caller.
   </p><p>

   The caller must hold the peer lock.
</p></div><div class="refsect1"><a name="id-1.10.19.7"></a><h2>Return</h2><p>
   New clock value is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-sync"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_sync — 
     sync queue clock
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_sync </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.20.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     timestamp to sync on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.20.6"></a><h2>Description</h2><p>
   This synchronizes the clock of <em class="parameter"><code>queue</code></em> with the externally provided timestamp
   <em class="parameter"><code>timestamp</code></em>. That is, the queue clock is fast-forwarded to <em class="parameter"><code>timestamp</code></em>, in
   case it is newer than the queue clock. Otherwise, nothing is done.
   </p><p>

   This function works with even *and* odd timestamps. It is internally
   converted to the corresponding even timestamp, in case it is odd.
   </p><p>

   The caller must hold the peer lock.
</p></div><div class="refsect1"><a name="id-1.10.20.7"></a><h2>Return</h2><p>
   New clock value is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-peek-rcu"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_peek_rcu — 
     peek first available entry
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_queue_node * <b class="fsfunc">bus1_queue_peek_rcu </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.21.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.21.6"></a><h2>Description</h2><p>
   This returns a pointer to the first available entry in the given queue, or
   NULL if there is none. The queue stays unmodified and the returned entry
   remains on the queue.
   </p><p>

   The caller must be inside an rcu read-side crictical section, and the
   returned pointer is only valid for that critical section. Furthermore, the
   caller must only access fields of the queue-entry that are explicitly
   available for rcu-access.
   </p><p>

   If the caller needs to operate on the queue entry, it better lock the peer
   and call <code class="function">bus1_queue_peek</code>. This fast-path should only be used for <code class="function">poll</code>
   callbacks and alike.
</p></div><div class="refsect1"><a name="id-1.10.21.7"></a><h2>Return</h2><p>
   Pointer to first available entry, NULL if none available.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-is-readable"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_is_readable — 
     check whether a queue is readable
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_is_readable </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.22.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.22.6"></a><h2>Description</h2><p>
   This checks whether the given queue is readable. It is similar to
   <code class="function">bus1_queue_peek</code>, but also takes in account silent messages. That is, a
   queue is only considered readable, if it has a front entry *and* at least a
   single non-silent, committed message.
</p></div><div class="refsect1"><a name="id-1.10.22.7"></a><h2>Note that messages can have 3 different states</h2><p>
   - staging: the message is part of an active transaction
   - committed: the message is fully committed, but might still be blocked by
   a staging message
   - ready: the message is committed and ready to be dequeued.
   </p><p>

   This function only checks that there is at least one ready entry (which
   might be silent), and at least one committed non-silent entry. Preferably,
   we would check whether there is at least one *ready, non-silent* entry, but
   this would require linear queue-searches (since the transition from
   committed to ready is not explicit).
</p></div><div class="refsect1"><a name="id-1.10.22.8"></a><h2>In other words</h2><p>
   There might be a short race where we wake up a peer, even
   though it can *only* dequeue silent messages. However, if that happens, we
   guarantee that there is a non-silent message queued *AND* committed, that
   will reach the peer as soon as the kernel is done resolving in-flight
   dependencies. Hence, we would wake up the peer in the near future, anyway.
</p></div><div class="refsect1"><a name="id-1.10.22.9"></a><h2>Return</h2><p>
   True if the queue is readable, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-get-type"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_get_type — 
  query node type
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">unsigned int <b class="fsfunc">bus1_queue_node_get_type </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.23.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.23.6"></a><h2>Description</h2><p>
   This queries the node type that was provided via the node constructor. A
   node never changes its type during its entire lifetime.
   The caller must hold the peer lock or own the queue-node.
</p></div><div class="refsect1"><a name="id-1.10.23.7"></a><h2>Return</h2><p>
   Type of <em class="parameter"><code>node</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-get-timestamp"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_get_timestamp — 
     query node timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_node_get_timestamp </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.24.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.24.6"></a><h2>Description</h2><p>
   This queries the node timestamp that is currently set on this node. The
   caller must hold the peer lock or own the queue-node.
</p></div><div class="refsect1"><a name="id-1.10.24.7"></a><h2>Return</h2><p>
   Timestamp of <em class="parameter"><code>node</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-init-internal"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_init_internal — 
     initialize queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_init_internal </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.25.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to initialize
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.25.6"></a><h2>Description</h2><p>
   This initializes a new queue. The queue memory is considered uninitialized,
   any previous content is lost unrecoverably.
   </p><p>

   Note that all queues must be embedded into a parent bus1_peer_info object.
   The code works fine, if you don't, but the lockdep-annotations will fail
   horribly. They rely on <code class="function">container_of</code> to be valid on every queue. Use the
   <code class="function">bus1_queue_init_for_peer</code> macro to make sure you never violate this rule.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_destroy — 
     destroy queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_destroy </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.26.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to destroy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.26.6"></a><h2>Description</h2><p>
   This destroys a queue that was previously initialized via <code class="function">bus1_queue_init</code>.
   The caller must make sure the queue is empty before calling this.
   </p><p>

   This function is a no-op, and only does safety checks on the queue. It is
   safe to call this function multiple times on the same queue.
   </p><p>

   The caller must guarantee that the backing memory of <em class="parameter"><code>queue</code></em> is freed in an
   rcu-delayed manner.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-post-flush"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_post_flush — 
     flush queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_post_flush </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.27.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to flush
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.27.6"></a><h2>Description</h2><p>
   To flush an entire queue, callers should lock the peer and iterate the
   entire message tree, removing each entry without touching the tree. When
   done, calling into <code class="function">bus1_queue_post_flush</code> will reset the tree, assuming the
   caller completely cleared all entries.
   </p><p>

   We cannot implement flushing inside of queue-handling, as it requires
   knowledge about the attached payload of each message. Hence, we'd have to
   use a callback to let the caller release each message. This is cumbersome,
   hence we decided to force callers to traverse the tree themselves.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-stage"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_stage — 
     stage queue entry with new timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_stage </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, struct bus1_queue_node * <var class="pdparam">node</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.28.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to stage
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     new timestamp for <em class="parameter"><code>node</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.28.6"></a><h2>Description</h2><p>
   Link or update a queue entry according to <em class="parameter"><code>timestamp</code></em>. If the entry was not
   linked, yet, this will insert the entry into the queue. If it was already
   linked, it is updated and sorted according to <em class="parameter"><code>timestamp</code></em>.
   </p><p>

   The caller can provide both, odd timestamps (i.e., mark entry as staging),
   or even timestamps (i.e., commit the entry). If an entry is marked as
   staging, it can be updated as often as you want. However, once an entry is
   committed, it must not be updated, anymore.
   </p><p>

   Furthermore, the queue clock must be synced with the new timestamp *before*
   staging an entry. Similarly, the timestamp of an entry can only be
   increased, never decreased.
</p></div><div class="refsect1"><a name="id-1.10.28.7"></a><h2>Return</h2><p>
   True if this call turned the queue readable, false otherwise.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-remove"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_remove — 
     remove entry from queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_remove </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.29.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to remove
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.29.6"></a><h2>Description</h2><p>
   This unlinks <em class="parameter"><code>node</code></em> and fully removes it from the queue <em class="parameter"><code>queue</code></em>. You must
   never reuse that node again, once removed.
   </p><p>

   If <em class="parameter"><code>node</code></em> was still in staging, this call might uncover a new front entry and
   as such turn the queue readable. Hence, the caller *must* handle its return
   value.
</p></div><div class="refsect1"><a name="id-1.10.29.7"></a><h2>Return</h2><p>
   True if this call turned the queue readable, false otherwise.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-peek"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_peek — 
     peek first available entry
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_queue_node * <b class="fsfunc">bus1_queue_peek </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.30.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.30.6"></a><h2>Description</h2><p>
   This returns a pointer to the first available entry in the given queue, or
   NULL if there is none. The queue stays unmodified and the returned entry
   remains on the queue.
   </p><p>

   This only returns entries that are ready to be dequeued. Entries that are
   still in staging mode will not be considered.
   </p><p>

   The caller must hold the read-side peer-lock of the parent peer.
</p></div><div class="refsect1"><a name="id-1.10.30.7"></a><h2>Return</h2><p>
   Pointer to first available entry, NULL if none available.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_init — 
     initialize queue node
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_node_init </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var>, unsigned int <var class="pdparam">type</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.31.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>type</code></em></span></dt><dd><p>
     message type
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.31.6"></a><h2>Description</h2><p>
   This initializes a previously unused node, and prepares it for use with a
   message queue.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_destroy — 
     destroy queue node
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_node_destroy </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.32.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.32.6"></a><h2>Description</h2><p>
   This destroys a previously initialized queue node. This is a no-op and only
   serves as debugger, testing whether the node was properly unqueued before.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-is-queued"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_is_queued — 
     check whether a node is queued
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_node_is_queued </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.33.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.33.6"></a><h2>Description</h2><p>
   This checks whether a node is currently queued in a message queue. That is,
   the node was linked via <code class="function">bus1_queue_stage</code> and as not been dequeued, yet
   (both via <code class="function">bus1_queue_remove</code> or <code class="function">bus1_queue_flush</code>).
</p></div><div class="refsect1"><a name="id-1.10.33.7"></a><h2>Return</h2><p>
   True if <em class="parameter"><code>node</code></em> is currently queued.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-is-committed"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_is_committed — 
     check whether a node is committed
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_node_is_committed </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.34.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.34.6"></a><h2>Description</h2><p>
   This checks whether a given node was already committed. In this case, the
   queue node is owned by the queue. In all other cases, the node is usually
   owned by an ongoing transaction or some other ongoing operation.
</p></div><div class="refsect1"><a name="id-1.10.34.7"></a><h2>Return</h2><p>
   True if <em class="parameter"><code>node</code></em> is committed.
</p></div></div></div></div></body></html>
