<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>The Internal Bus1 API</title><link rel="stylesheet" type="text/css" href="bus1.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="icon" href="bus1.png" type="image/png"><script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75729104-1', 'auto');
      ga('send', 'pageview');
    </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><header><a href="index.html"><img src="bus1.svg" alt="bus1" style="width:64px;height:64px;"></a><span class="version">Version 1</span></header><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="BUS1-API"></a>The Internal Bus1 API</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#intro">1. Bus1 Overview</a></span></dt><dt><span class="chapter"><a href="#peer">2. Bus1 Peer</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer"><span class="phrase">struct bus1_peer</span></a></span><span class="refpurpose"> — 
  peer handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer-list"><span class="phrase">struct bus1_peer_list</span></a></span><span class="refpurpose"> — 
     list of acquired peers
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-acquire"><span class="phrase">bus1_peer_acquire</span></a></span><span class="refpurpose"> — 
     acquire active reference to peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-release"><span class="phrase">bus1_peer_release</span></a></span><span class="refpurpose"> — 
     release an active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-list-bind"><span class="phrase">bus1_peer_list_bind</span></a></span><span class="refpurpose"> — 
     temporarily bind a peer of a peer list
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-list-unbind"><span class="phrase">bus1_peer_list_unbind</span></a></span><span class="refpurpose"> — 
     temporarily unbind a peer of a peer list
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-new"><span class="phrase">bus1_peer_new</span></a></span><span class="refpurpose"> — 
  allocate new peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-disconnect"><span class="phrase">bus1_peer_disconnect</span></a></span><span class="refpurpose"> — 
     disconnect peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-free"><span class="phrase">bus1_peer_free</span></a></span><span class="refpurpose"> — 
     destroy peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-ioctl"><span class="phrase">bus1_peer_ioctl</span></a></span><span class="refpurpose"> — 
     handle peer runtime ioctls
 </span></dt></dl></dd><dt><span class="chapter"><a href="#message">3. Bus1 Message</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-message"><span class="phrase">struct bus1_message</span></a></span><span class="refpurpose"> — 
  message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-from-node"><span class="phrase">bus1_message_from_node</span></a></span><span class="refpurpose"> — 
     get parent message of a queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-new"><span class="phrase">bus1_message_new</span></a></span><span class="refpurpose"> — 
  allocate new message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-ref"><span class="phrase">bus1_message_ref</span></a></span><span class="refpurpose"> — 
     acquire message reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-unref"><span class="phrase">bus1_message_unref</span></a></span><span class="refpurpose"> — 
     release message reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-allocate"><span class="phrase">bus1_message_allocate</span></a></span><span class="refpurpose"> — 
     allocate message resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-pin"><span class="phrase">bus1_message_pin</span></a></span><span class="refpurpose"> — 
     pin message resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-unpin"><span class="phrase">bus1_message_unpin</span></a></span><span class="refpurpose"> — 
     release pinned message resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-install"><span class="phrase">bus1_message_install</span></a></span><span class="refpurpose"> — 
     install message payload into target process
 </span></dt></dl></dd><dt><span class="chapter"><a href="#transaction">4. Bus1 Transaction</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#id-1.6.4">
   ipc/bus1/transaction.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-new-from-user"><span class="phrase">bus1_transaction_new_from_user</span></a></span><span class="refpurpose"> — 
  create new transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-free"><span class="phrase">bus1_transaction_free</span></a></span><span class="refpurpose"> — 
     free transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-instantiate-for-id"><span class="phrase">bus1_transaction_instantiate_for_id</span></a></span><span class="refpurpose"> — 
     instantiate a message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-commit"><span class="phrase">bus1_transaction_commit</span></a></span><span class="refpurpose"> — 
     commit a transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-commit-seed"><span class="phrase">bus1_transaction_commit_seed</span></a></span><span class="refpurpose"> — 
     instantiate and commit seed
 </span></dt></dl></dd><dt><span class="chapter"><a href="#handle">5. Bus1 Handle</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-dest"><span class="phrase">struct bus1_handle_dest</span></a></span><span class="refpurpose"> — 
  destination context
 </span></dt><dt><span class="refentrytitle"><a href="#API-BUS1-HANDLE-BATCH-SIZE"><span class="phrase">BUS1_HANDLE_BATCH_SIZE</span></a></span><span class="refpurpose"> — 
     number of handles per set in a batch
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-entry"><span class="phrase">union bus1_handle_entry</span></a></span><span class="refpurpose"> — 
     batch entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-batch"><span class="phrase">struct bus1_handle_batch</span></a></span><span class="refpurpose"> — 
     dynamic set of handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-transfer"><span class="phrase">struct bus1_handle_transfer</span></a></span><span class="refpurpose"> — 
     handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-inflight"><span class="phrase">struct bus1_handle_inflight</span></a></span><span class="refpurpose"> — 
     set of inflight handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-batch-inline-size"><span class="phrase">bus1_handle_batch_inline_size</span></a></span><span class="refpurpose"> — 
     calculate required inline size
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle"><span class="phrase">struct bus1_handle</span></a></span><span class="refpurpose"> — 
  handle objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-bus1-node-bit"><span class="phrase">enum bus1_node_bit</span></a></span><span class="refpurpose"> — 
     state flags of node objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-node"><span class="phrase">struct bus1_node</span></a></span><span class="refpurpose"> — 
     node objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-unref-queued"><span class="phrase">bus1_handle_unref_queued</span></a></span><span class="refpurpose"> — 
     unref queued handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-pair"><span class="phrase">bus1_handle_pair</span></a></span><span class="refpurpose"> — 
     transfer handle manually from one peer to another
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release-by-id"><span class="phrase">bus1_handle_release_by_id</span></a></span><span class="refpurpose"> — 
     release a user handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-node-destroy-by-id"><span class="phrase">bus1_node_destroy_by_id</span></a></span><span class="refpurpose"> — 
     destroy a node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-flush-all"><span class="phrase">bus1_handle_flush_all</span></a></span><span class="refpurpose"> — 
     flush all nodes and handles of a peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-init"><span class="phrase">bus1_handle_dest_init</span></a></span><span class="refpurpose"> — 
     initialize destination handle context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-destroy"><span class="phrase">bus1_handle_dest_destroy</span></a></span><span class="refpurpose"> — 
     destroy destination handle context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-import"><span class="phrase">bus1_handle_dest_import</span></a></span><span class="refpurpose"> — 
     import destination handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-export"><span class="phrase">bus1_handle_dest_export</span></a></span><span class="refpurpose"> — 
     publish new nodes of destination context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-init"><span class="phrase">bus1_handle_transfer_init</span></a></span><span class="refpurpose"> — 
     initialize handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-release"><span class="phrase">bus1_handle_transfer_release</span></a></span><span class="refpurpose"> — 
     release handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-destroy"><span class="phrase">bus1_handle_transfer_destroy</span></a></span><span class="refpurpose"> — 
     destroy handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-import"><span class="phrase">bus1_handle_transfer_import</span></a></span><span class="refpurpose"> — 
     import handles for transfer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-export"><span class="phrase">bus1_handle_transfer_export</span></a></span><span class="refpurpose"> — 
     publish new nodes of transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-init"><span class="phrase">bus1_handle_inflight_init</span></a></span><span class="refpurpose"> — 
     initialize inflight context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-destroy"><span class="phrase">bus1_handle_inflight_destroy</span></a></span><span class="refpurpose"> — 
     destroy inflight-context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-flush"><span class="phrase">bus1_handle_inflight_flush</span></a></span><span class="refpurpose"> — 
     flush pinned resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-import"><span class="phrase">bus1_handle_inflight_import</span></a></span><span class="refpurpose"> — 
     import inflight context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-install"><span class="phrase">bus1_handle_inflight_install</span></a></span><span class="refpurpose"> — 
     install inflight handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-walk"><span class="phrase">bus1_handle_inflight_walk</span></a></span><span class="refpurpose"> — 
     walk all handle IDs
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-commit"><span class="phrase">bus1_handle_inflight_commit</span></a></span><span class="refpurpose"> — 
     commit inflight context
 </span></dt></dl></dd><dt><span class="chapter"><a href="#user">6. Bus1 User</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-user"><span class="phrase">struct bus1_user</span></a></span><span class="refpurpose"> — 
  resource accounting for users
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-stats"><span class="phrase">struct bus1_user_stats</span></a></span><span class="refpurpose"> — 
     quota statistics between a user and a peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-quota"><span class="phrase">struct bus1_user_quota</span></a></span><span class="refpurpose"> — 
     quota handling
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-exit"><span class="phrase">bus1_user_exit</span></a></span><span class="refpurpose"> — 
  clean up global resources of user accounting
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref-by-uid"><span class="phrase">bus1_user_ref_by_uid</span></a></span><span class="refpurpose"> — 
     get a user object for a uid
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref"><span class="phrase">bus1_user_ref</span></a></span><span class="refpurpose"> — 
     acquire reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-unref"><span class="phrase">bus1_user_unref</span></a></span><span class="refpurpose"> — 
     release reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-init"><span class="phrase">bus1_user_quota_init</span></a></span><span class="refpurpose"> — 
     initialize quota object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-destroy"><span class="phrase">bus1_user_quota_destroy</span></a></span><span class="refpurpose"> — 
     destroy quota object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-charge"><span class="phrase">bus1_user_quota_charge</span></a></span><span class="refpurpose"> — 
     try charging a user
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-discharge"><span class="phrase">bus1_user_quota_discharge</span></a></span><span class="refpurpose"> — 
     discharge a user
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-commit"><span class="phrase">bus1_user_quota_commit</span></a></span><span class="refpurpose"> — 
     commit a quota charge
 </span></dt></dl></dd><dt><span class="chapter"><a href="#pool">7. Bus1 Pool</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool-slice"><span class="phrase">struct bus1_pool_slice</span></a></span><span class="refpurpose"> — 
  pool slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool"><span class="phrase">struct bus1_pool</span></a></span><span class="refpurpose"> — 
     client pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-slice-is-public"><span class="phrase">bus1_pool_slice_is_public</span></a></span><span class="refpurpose"> — 
     check whether a slice is public
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-create"><span class="phrase">bus1_pool_create</span></a></span><span class="refpurpose"> — 
  create memory pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-destroy"><span class="phrase">bus1_pool_destroy</span></a></span><span class="refpurpose"> — 
     pool to destroy
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-alloc"><span class="phrase">bus1_pool_alloc</span></a></span><span class="refpurpose"> — 
     allocate memory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-kernel"><span class="phrase">bus1_pool_release_kernel</span></a></span><span class="refpurpose"> — 
     release kernel-owned slice reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-publish"><span class="phrase">bus1_pool_publish</span></a></span><span class="refpurpose"> — 
     publish a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-user"><span class="phrase">bus1_pool_release_user</span></a></span><span class="refpurpose"> — 
     release a public slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-flush"><span class="phrase">bus1_pool_flush</span></a></span><span class="refpurpose"> — 
     flush all user references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-mmap"><span class="phrase">bus1_pool_mmap</span></a></span><span class="refpurpose"> — 
     mmap the pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-iovec"><span class="phrase">bus1_pool_write_iovec</span></a></span><span class="refpurpose"> — 
     copy user memory to a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-kvec"><span class="phrase">bus1_pool_write_kvec</span></a></span><span class="refpurpose"> — 
     copy kernel memory to a slice
 </span></dt></dl></dd><dt><span class="chapter"><a href="#queue">8. Bus1 Queue</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue-node"><span class="phrase">struct bus1_queue_node</span></a></span><span class="refpurpose"> — 
  node into message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue"><span class="phrase">struct bus1_queue</span></a></span><span class="refpurpose"> — 
     message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-init"><span class="phrase">bus1_queue_node_init</span></a></span><span class="refpurpose"> — 
     initialize queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-destroy"><span class="phrase">bus1_queue_node_destroy</span></a></span><span class="refpurpose"> — 
     destroy queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-type"><span class="phrase">bus1_queue_node_get_type</span></a></span><span class="refpurpose"> — 
     query node type
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-timestamp"><span class="phrase">bus1_queue_node_get_timestamp</span></a></span><span class="refpurpose"> — 
     query node timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-queued"><span class="phrase">bus1_queue_node_is_queued</span></a></span><span class="refpurpose"> — 
     check whether a node is queued
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-staging"><span class="phrase">bus1_queue_node_is_staging</span></a></span><span class="refpurpose"> — 
     check whether a node is marked staging
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-tick"><span class="phrase">bus1_queue_tick</span></a></span><span class="refpurpose"> — 
     increment queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-sync"><span class="phrase">bus1_queue_sync</span></a></span><span class="refpurpose"> — 
     sync queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-is-readable"><span class="phrase">bus1_queue_is_readable</span></a></span><span class="refpurpose"> — 
     check whether a queue is readable
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-compare"><span class="phrase">bus1_queue_compare</span></a></span><span class="refpurpose"> — 
     comparator for queue ordering
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-init"><span class="phrase">bus1_queue_init</span></a></span><span class="refpurpose"> — 
  initialize queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-destroy"><span class="phrase">bus1_queue_destroy</span></a></span><span class="refpurpose"> — 
     destroy queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-flush"><span class="phrase">bus1_queue_flush</span></a></span><span class="refpurpose"> — 
     flush message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-stage"><span class="phrase">bus1_queue_stage</span></a></span><span class="refpurpose"> — 
     stage queue entry with fresh timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-staged"><span class="phrase">bus1_queue_commit_staged</span></a></span><span class="refpurpose"> — 
     commit staged queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-unstaged"><span class="phrase">bus1_queue_commit_unstaged</span></a></span><span class="refpurpose"> — 
     commit unstaged queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-remove"><span class="phrase">bus1_queue_remove</span></a></span><span class="refpurpose"> — 
     remove entry from queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-peek"><span class="phrase">bus1_queue_peek</span></a></span><span class="refpurpose"> — 
     peek first available entry
 </span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="intro"></a>Chapter 1. Bus1 Overview</h1></div></div></div><p>
   </p><p>
   bus1 is a local IPC system, which provides a decentralized infrastructure to
   share objects between local peers. The main building blocks are nodes and
   handles. Nodes represent objects of a local peer, while handles represent
   descriptors that point to a node. Nodes can be created and destroyed by any
   peer, and they will always remain owned by their respective creator. Handles,
   on the other hand, are used to refer to nodes and can be passed around with
   messages as auxiliary data. Whenever a handle is transferred, the receiver
   will get its own handle allocated, pointing to the same node as the original
   handle.
   </p><p>
   Any peer can send messages directed at one of their handles. This will
   transfer the message to the owner of the node the handle points to. If a
   peer does not posess a handle to a given node, it will not be able to send a
   message to that node. That is, handles provide exclusive access management.
   Anyone that somehow acquired a handle to a node is privileged to further
   send this handle to other peers. As such, access management is transitive.
   Once a peer acquired a handle, it cannot be revoked again. However, a node
   owner can, at anytime, destroy a node. This will effectively unbind all
   existing handles to that node on any peer, notifying each one of the
   destruction.
   </p><p>
   Unlike nodes and handles, peers cannot be addressed directly. In fact, peers
   are completely disconnected entities. A peer is merely an anchor of a set of
   nodes and handles, including an incoming message queue for any of those.
   Whether multiple nodes are all part of the same peer, or part of different
   peers does not affect the remote view of those. Peers solely exist as
   management entity and command dispatcher to local processes.
   </p><p>
   The set of actors on a system is completely decentralized. There is no
   global component involved that provides a central registry or discovery
   mechanism. Furthermore, communication between peers only involves those
   peers, and does not affect any other peer in any way. No global
   communication lock is taken. However, any communication is still globally
   ordered, including unicasts, multicasts, and notifications.
</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="peer"></a>Chapter 2. Bus1 Peer</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer"><span class="phrase">struct bus1_peer</span></a></span><span class="refpurpose"> — 
  peer handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-peer-list"><span class="phrase">struct bus1_peer_list</span></a></span><span class="refpurpose"> — 
     list of acquired peers
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-acquire"><span class="phrase">bus1_peer_acquire</span></a></span><span class="refpurpose"> — 
     acquire active reference to peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-release"><span class="phrase">bus1_peer_release</span></a></span><span class="refpurpose"> — 
     release an active reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-list-bind"><span class="phrase">bus1_peer_list_bind</span></a></span><span class="refpurpose"> — 
     temporarily bind a peer of a peer list
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-list-unbind"><span class="phrase">bus1_peer_list_unbind</span></a></span><span class="refpurpose"> — 
     temporarily unbind a peer of a peer list
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-new"><span class="phrase">bus1_peer_new</span></a></span><span class="refpurpose"> — 
  allocate new peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-disconnect"><span class="phrase">bus1_peer_disconnect</span></a></span><span class="refpurpose"> — 
     disconnect peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-free"><span class="phrase">bus1_peer_free</span></a></span><span class="refpurpose"> — 
     destroy peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-peer-ioctl"><span class="phrase">bus1_peer_ioctl</span></a></span><span class="refpurpose"> — 
     handle peer runtime ioctls
 </span></dt></dl></div><p>
   </p><p>
   XXX
</p><div class="refentry"><a name="API-struct-bus1-peer"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_peer — 
  peer handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_peer {
  u64 id;
  u64 flags;
  const struct cred * cred;
  struct pid_namespace * pid_ns;
  struct bus1_user * user;
  struct bus1_user_quota quota;
  wait_queue_head_t waitq;
  struct bus1_active active;
};  </pre></div><div class="refsect1"><a name="id-1.4.4.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">id</span></dt><dd><p>
unique peer ID
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
peer flags
      </p></dd><dt><span class="term">cred</span></dt><dd><p>
user creds
      </p></dd><dt><span class="term">pid_ns</span></dt><dd><p>
user pid namespace
      </p></dd><dt><span class="term">user</span></dt><dd><p>
object owner
      </p></dd><dt><span class="term">quota</span></dt><dd><p>
quota handling
      </p></dd><dt><span class="term">waitq</span></dt><dd><p>
peer wide wait queue
      </p></dd><dt><span class="term">active</span></dt><dd><p>
active references
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-peer-list"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_peer_list — 
     list of acquired peers
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_peer_list {
  struct bus1_peer * peer;
  void * next;
};  </pre></div><div class="refsect1"><a name="id-1.4.5.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">peer</span></dt><dd><p>
   acquired peer
      </p></dd><dt><span class="term">next</span></dt><dd><p>
   next list element
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-acquire"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_acquire — 
     acquire active reference to peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_acquire </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.6.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.6.6"></a><h2>Description</h2><p>
   Acquire a new active reference to the given peer. If the peer was not
   activated yet, or if it was already deactivated, this will fail.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.4.6.7"></a><h2>Return</h2><p>
   Pointer to peer, NULL on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-release"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_release — 
     release an active reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_release </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.7.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     handle to release, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.7.6"></a><h2>Description</h2><p>
   This releases an active reference to a peer, acquired previously via
   <code class="function">bus1_peer_acquire</code>.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.4.7.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-list-bind"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_list_bind — 
     temporarily bind a peer of a peer list
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_list_bind </b>(</code>struct bus1_peer_list * <var class="pdparam">list</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>list</code></em></span></dt><dd><p>
     entry to bind
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.8.6"></a><h2>Description</h2><p>
   Whenever you deal with an unbound set of peers that must be acquired at the
   same time, we need to work around lockdep limitations (see
   bus1_active_lockdep_{acquired,released}() for details). The bus1_peer_list
   object is a simple wrapper to store a list of peers. Whenever your iterate
   that list, you call <code class="function">bus1_peer_list_bind</code> to temporarily enable lockdep
   annotations for that single peer, and <code class="function">bus1_peer_list_unbind</code> when done.
   </p><p>

   That is, each access to a peer in a peer-list is guarded by the <code class="function">bind</code> and
   <code class="function">unbind</code> calls, enabling/disabling lockdep. Note that <code class="function">acquire</code> returns
   peers bound, so after initializing a peer-list, you first have to unbind the
   peer.
</p></div><div class="refsect1"><a name="id-1.4.8.7"></a><h2>Return</h2><p>
   Pointer to bound peer.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-list-unbind"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_list_unbind — 
     temporarily unbind a peer of a peer list
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_peer_list_unbind </b>(</code>struct bus1_peer_list * <var class="pdparam">list</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>list</code></em></span></dt><dd><p>
     entry to unbind
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.9.6"></a><h2>Description</h2><p>
   See <code class="function">bus1_peer_list_bind</code> for details. This is the inverse operation.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-new"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_new — 
  allocate new peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_new </b>(</code> <var class="pdparam">void</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>void</code></em></span></dt><dd><p>
     no arguments
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.10.6"></a><h2>Description</h2><p>
   </p><p>

   Allocate a new peer. The peer is *not* activated, nor linked into any
   context. The caller owns the only pointer to the new peer.
</p></div><div class="refsect1"><a name="id-1.4.10.7"></a><h2>Return</h2><p>
   Pointer to peer, ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-disconnect"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_disconnect — 
     disconnect peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_peer_disconnect </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.11.6"></a><h2>Description</h2><p>
   This tears down a peer synchronously. It first marks the peer as deactivated,
   waits for all outstanding operations to finish, before resetting and
   deactivating the peer.
   </p><p>

   It is perfectly safe to call this function multiple times, even in parallel.
   It is guaranteed to block *until* the peer is fully torn down, regardless
   whether this was the call to tear it down, or not.
</p></div><div class="refsect1"><a name="id-1.4.11.7"></a><h2>Return</h2><p>
   0 on success, negative error code if already torn down.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_free — 
     destroy peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_peer * <b class="fsfunc">bus1_peer_free </b>(</code>struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.12.6"></a><h2>Description</h2><p>
   Disconnects and destroy a peer object that was previously allocated via
   <code class="function">bus1_peer_new</code>.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.4.12.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-peer-ioctl"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_peer_ioctl — 
     handle peer runtime ioctls
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_peer_ioctl </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, unsigned int <var class="pdparam">cmd</var>, unsigned long <var class="pdparam">arg</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.4.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to work on
    </p></dd><dt><span class="term"><em class="parameter"><code>cmd</code></em></span></dt><dd><p>
     ioctl command
    </p></dd><dt><span class="term"><em class="parameter"><code>arg</code></em></span></dt><dd><p>
     ioctl argument
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.4.13.6"></a><h2>Description</h2><p>
   This handles the given ioctl (cmd+arg) on the passed peer. The caller must
   hold an active reference to <em class="parameter"><code>peer</code></em>.
   </p><p>

   This only handles the runtime ioctls. Setup and teardown must be called
   directly.
   </p><p>

   Multiple ioctls can be called in parallel just fine. No locking is needed.
</p></div><div class="refsect1"><a name="id-1.4.13.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="message"></a>Chapter 3. Bus1 Message</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-message"><span class="phrase">struct bus1_message</span></a></span><span class="refpurpose"> — 
  message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-from-node"><span class="phrase">bus1_message_from_node</span></a></span><span class="refpurpose"> — 
     get parent message of a queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-new"><span class="phrase">bus1_message_new</span></a></span><span class="refpurpose"> — 
  allocate new message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-ref"><span class="phrase">bus1_message_ref</span></a></span><span class="refpurpose"> — 
     acquire message reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-unref"><span class="phrase">bus1_message_unref</span></a></span><span class="refpurpose"> — 
     release message reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-allocate"><span class="phrase">bus1_message_allocate</span></a></span><span class="refpurpose"> — 
     allocate message resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-pin"><span class="phrase">bus1_message_pin</span></a></span><span class="refpurpose"> — 
     pin message resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-unpin"><span class="phrase">bus1_message_unpin</span></a></span><span class="refpurpose"> — 
     release pinned message resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-message-install"><span class="phrase">bus1_message_install</span></a></span><span class="refpurpose"> — 
     install message payload into target process
 </span></dt></dl></div><p>
   </p><p>
   XXX
</p><div class="refentry"><a name="API-struct-bus1-message"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_message — 
  message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_message {
  u64 flags;
  u64 destination;
  uid_t uid;
  gid_t gid;
  pid_t pid;
  pid_t tid;
  struct bus1_queue_node qnode;
  struct bus1_user * user;
  struct bus1_pool_slice * slice;
  struct file ** files;
  size_t n_bytes;
  size_t n_files;
  size_t n_secctx;
  size_t n_accounted_handles;
  struct bus1_handle_inflight handles;
};  </pre></div><div class="refsect1"><a name="id-1.5.4.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">flags</span></dt><dd><p>
message flags
      </p></dd><dt><span class="term">destination</span></dt><dd><p>
destination ID
      </p></dd><dt><span class="term">uid</span></dt><dd><p>
sender UID
      </p></dd><dt><span class="term">gid</span></dt><dd><p>
sender GID
      </p></dd><dt><span class="term">pid</span></dt><dd><p>
sender PID
      </p></dd><dt><span class="term">tid</span></dt><dd><p>
sender TID
      </p></dd><dt><span class="term">qnode</span></dt><dd><p>
embedded queue node
<em class="parameter"><code>transaction</code></em>.index:		index into multicast destination array
<em class="parameter"><code>transaction</code></em>.link:		message list (during transactions)
<em class="parameter"><code>transaction</code></em>.dest:		pinned destination (during transactions)
      </p></dd><dt><span class="term">user</span></dt><dd><p>
sending user
      </p></dd><dt><span class="term">slice</span></dt><dd><p>
actual message data
      </p></dd><dt><span class="term">files</span></dt><dd><p>
passed file descriptors
      </p></dd><dt><span class="term">n_bytes</span></dt><dd><p>
number of user-bytes transmitted
      </p></dd><dt><span class="term">n_files</span></dt><dd><p>
number of files transmitted
      </p></dd><dt><span class="term">n_secctx</span></dt><dd><p>
number of bytes of security context transmitted
      </p></dd><dt><span class="term">n_accounted_handles</span></dt><dd><p>
number of accounted handles
      </p></dd><dt><span class="term">handles</span></dt><dd><p>
passed handles
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-from-node"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_from_node — 
     get parent message of a queue node
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_from_node </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.5.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to get parent of
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.5.6"></a><h2>Description</h2><p>
   This turns a queue node into a message. The caller must verify that the
   passed node is actually a message.
</p></div><div class="refsect1"><a name="id-1.5.5.7"></a><h2>Return</h2><p>
   Pointer to message is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-new"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_new — 
  allocate new message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_new </b>(</code>size_t <var class="pdparam">n_bytes</var>, size_t <var class="pdparam">n_files</var>, size_t <var class="pdparam">n_handles</var>, size_t <var class="pdparam">n_secctx</var>, struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.6.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>n_bytes</code></em></span></dt><dd><p>
     number of bytes to transmit
    </p></dd><dt><span class="term"><em class="parameter"><code>n_files</code></em></span></dt><dd><p>
     number of files to pre-allocate
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to pre-allocate
    </p></dd><dt><span class="term"><em class="parameter"><code>n_secctx</code></em></span></dt><dd><p>
     number of bytes of the security context to transmit
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     sending peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.6.6"></a><h2>Description</h2><p>
   This allocates a new, unused message for free use to the caller. Storage for
   files and handles is (partially) pre-allocated. The number of embedded
   handles is capped, so in case many handles are passed more memory will have
   to be allocated later.
</p></div><div class="refsect1"><a name="id-1.5.6.7"></a><h2>Return</h2><p>
   Pointer to new message, ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-ref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_ref — 
     acquire message reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_ref </b>(</code>struct bus1_message * <var class="pdparam">message</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.7.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to acquire reference to, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.7.6"></a><h2>Description</h2><p>
   If non-NULL is passed, this acquires a new reference to the passed message.
</p></div><div class="refsect1"><a name="id-1.5.7.7"></a><h2>Return</h2><p>
   <em class="parameter"><code>message</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-unref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_unref — 
     release message reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_unref </b>(</code>struct bus1_message * <var class="pdparam">message</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to release reference of, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.8.6"></a><h2>Description</h2><p>
   If non-NULL is passed, this releases a single reference to the passed
   message. The caller must guarantee that the message has no resources
   attached, anymore (by flushing it beforehand, if required).
</p></div><div class="refsect1"><a name="id-1.5.8.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-allocate"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_allocate — 
     allocate message resources
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_message_allocate </b>(</code>struct bus1_message * <var class="pdparam">message</var>, struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     owning peer of the message
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.9.6"></a><h2>Description</h2><p>
   Allocate a pool slice for the given message, and charge the quota of the
   given user for all the associated in-flight resources.
   </p><p>

   This returns the message resources pinned. Use <code class="function">bus1_message_unpin</code> to
   release them again.
</p></div><div class="refsect1"><a name="id-1.5.9.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-pin"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_pin — 
     pin message resources
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_pin </b>(</code>struct bus1_message * <var class="pdparam">message</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to pin, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.10.6"></a><h2>Description</h2><p>
   Pin the resources of the given message. The caller must have them already
   pinned, this just increments the pin-counter.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.5.10.7"></a><h2>Return</h2><p>
   <em class="parameter"><code>message</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-unpin"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_unpin — 
     release pinned message resources
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_message * <b class="fsfunc">bus1_message_unpin </b>(</code>struct bus1_message * <var class="pdparam">message</var>, struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to unpin, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     owner of the message
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.11.6"></a><h2>Description</h2><p>
   This unpins the resources of the message. If this was the last pin, the
   resources are deallocated and flushed.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.5.11.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-message-install"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_message_install — 
     install message payload into target process
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_message_install </b>(</code>struct bus1_message * <var class="pdparam">message</var>, struct bus1_peer * <var class="pdparam">peer</var>, struct bus1_cmd_recv * <var class="pdparam">param</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.5.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>message</code></em></span></dt><dd><p>
     message to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     calling peer
    </p></dd><dt><span class="term"><em class="parameter"><code>param</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.5.12.6"></a><h2>Description</h2><p>
   This installs the payload FDs and handles of <em class="parameter"><code>message</code></em> into <em class="parameter"><code>peer</code></em> and
   the calling process. Handles are always installed, FDs are only installed if
   explicitly requested via <em class="parameter"><code>inst_fds</code></em>.
</p></div><div class="refsect1"><a name="id-1.5.12.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="transaction"></a>Chapter 4. Bus1 Transaction</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#id-1.6.4">
   ipc/bus1/transaction.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-new-from-user"><span class="phrase">bus1_transaction_new_from_user</span></a></span><span class="refpurpose"> — 
  create new transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-free"><span class="phrase">bus1_transaction_free</span></a></span><span class="refpurpose"> — 
     free transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-instantiate-for-id"><span class="phrase">bus1_transaction_instantiate_for_id</span></a></span><span class="refpurpose"> — 
     instantiate a message
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-commit"><span class="phrase">bus1_transaction_commit</span></a></span><span class="refpurpose"> — 
     commit a transaction
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-transaction-commit-seed"><span class="phrase">bus1_transaction_commit_seed</span></a></span><span class="refpurpose"> — 
     instantiate and commit seed
 </span></dt></dl></div><p>
   </p><p>
   XXX
</p><div class="refentry"><a name="id-1.6.4"></a><div class="titlepage"></div><div class="refnamediv"><p>
   ipc/bus1/transaction.h
   — 
   Document generation inconsistency
  </p></div><div class="refsect1"><a name="id-1.6.4.2"></a><h2>
   Oops
  </h2><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
    The template for this document tried to insert
    the structured comment from the file
    <code class="filename">ipc/bus1/transaction.h</code> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </p></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-new-from-user"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_new_from_user — 
  create new transaction
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_transaction * <b class="fsfunc">bus1_transaction_new_from_user </b>(</code>u8 * <var class="pdparam">stack_buffer</var>, size_t <var class="pdparam">stack_size</var>, struct bus1_peer * <var class="pdparam">peer</var>, struct bus1_cmd_send * <var class="pdparam">param</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.5.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>stack_buffer</code></em></span></dt><dd><p>
     stack buffer to use as backing memory
    </p></dd><dt><span class="term"><em class="parameter"><code>stack_size</code></em></span></dt><dd><p>
     size of <em class="parameter"><code>stack_buffer</code></em> in bytes
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     origin of this transaction
    </p></dd><dt><span class="term"><em class="parameter"><code>param</code></em></span></dt><dd><p>
     transaction parameters
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.5.6"></a><h2>Description</h2><p>
   This allocates a new transaction object for a user-transaction as specified
   via <em class="parameter"><code>param</code></em>. The transaction is optionally put onto the stack, if the passed
   buffer <em class="parameter"><code>stack_buffer</code></em> is big enough. Otherwise, the memory is allocated. The
   caller must make sure to pass the same stack-pointer to
   <code class="function">bus1_transaction_free</code>.
   </p><p>

   The transaction object imports all its data from user-space. If anything
   fails, an error is returned.
   </p><p>

   Note that the transaction object relies on being local to the current task.
   That is, its lifetime must be limited to your own function lifetime. You
   must not pass pointers to transaction objects to contexts outside of this
   lifetime. This makes it possible to optimize access to 'current' (and its
   properties like creds and pids), and to place the transaction on the stack,
   when it fits.
</p></div><div class="refsect1"><a name="id-1.6.5.7"></a><h2>Return</h2><p>
   Pointer to transaction object, or ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-free"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_free — 
     free transaction
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_transaction * <b class="fsfunc">bus1_transaction_free </b>(</code>struct bus1_transaction * <var class="pdparam">transaction</var>, u8 * <var class="pdparam">stack_buffer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.6.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transaction</code></em></span></dt><dd><p>
     transaction to free, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>stack_buffer</code></em></span></dt><dd><p>
     stack buffer passed to constructor
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.6.6"></a><h2>Description</h2><p>
   This releases a transaction and all associated memory. If the transaction
   failed, any in-flight messages are dropped and pinned peers are released. If
   the transaction was successful, this just releases the temporary data that
   was used for the transmission.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.6.6.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-instantiate-for-id"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_instantiate_for_id — 
     instantiate a message
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_transaction_instantiate_for_id </b>(</code>struct bus1_transaction * <var class="pdparam">transaction</var>, size_t <var class="pdparam">index</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.7.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transaction</code></em></span></dt><dd><p>
     transaction to work with
    </p></dd><dt><span class="term"><em class="parameter"><code>index</code></em></span></dt><dd><p>
     index into destination array
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.7.6"></a><h2>Description</h2><p>
   Instantiate the message from the given transaction for the handle id
   at <em class="parameter"><code>index</code></em> in the destination array. A new pool-slice is allocated, a queue
   entry is created and the message is queued as in-flight message on the
   transaction object. The message is not linked on the destination, yet. You
   need to commit the transaction to actually link it on the destination queue.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-commit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_commit — 
     commit a transaction
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_transaction_commit </b>(</code>struct bus1_transaction * <var class="pdparam">transaction</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transaction</code></em></span></dt><dd><p>
     transaction to commit
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.8.6"></a><h2>Description</h2><p>
   This performs the final commit of this transaction. All instances of the
   message that have been created on this transaction are staged on their
   respective destination queues and committed. This function makes sure to
   adhere to global-order restrictions, hence, the caller *must* instantiate
   the message for each destination before committing the whole transaction.
   Otherwise, ordering would not be guaranteed.
   </p><p>

   This function flushes the entire transaction. Technically, you can
   instantiate further entries once this call returns and commit them again.
   However, they will be treated as a new message which just happens to have
   the same contents as the previous one. This might come in handy for messages
   that might be triggered multiple times (like peer notifications).
   </p><p>

   This function may fail if the handle id of newly allocated nodes cannot be
   written back to the caller. Errors due to racing node destructions are
   silently ignored.
</p></div><div class="refsect1"><a name="id-1.6.8.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-transaction-commit-seed"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_transaction_commit_seed — 
     instantiate and commit seed
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_transaction_commit_seed </b>(</code>struct bus1_transaction * <var class="pdparam">transaction</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.6.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transaction</code></em></span></dt><dd><p>
     transaction to use
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.6.9.6"></a><h2>Description</h2><p>
   This instantiates a new message with the given transaction, and commits it
   as new seed on the owner-peer of the transaction. Any existing seed is
   deallocated and freed.
</p></div><div class="refsect1"><a name="id-1.6.9.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="handle"></a>Chapter 5. Bus1 Handle</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-dest"><span class="phrase">struct bus1_handle_dest</span></a></span><span class="refpurpose"> — 
  destination context
 </span></dt><dt><span class="refentrytitle"><a href="#API-BUS1-HANDLE-BATCH-SIZE"><span class="phrase">BUS1_HANDLE_BATCH_SIZE</span></a></span><span class="refpurpose"> — 
     number of handles per set in a batch
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-entry"><span class="phrase">union bus1_handle_entry</span></a></span><span class="refpurpose"> — 
     batch entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-batch"><span class="phrase">struct bus1_handle_batch</span></a></span><span class="refpurpose"> — 
     dynamic set of handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-transfer"><span class="phrase">struct bus1_handle_transfer</span></a></span><span class="refpurpose"> — 
     handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle-inflight"><span class="phrase">struct bus1_handle_inflight</span></a></span><span class="refpurpose"> — 
     set of inflight handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-batch-inline-size"><span class="phrase">bus1_handle_batch_inline_size</span></a></span><span class="refpurpose"> — 
     calculate required inline size
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-handle"><span class="phrase">struct bus1_handle</span></a></span><span class="refpurpose"> — 
  handle objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-bus1-node-bit"><span class="phrase">enum bus1_node_bit</span></a></span><span class="refpurpose"> — 
     state flags of node objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-node"><span class="phrase">struct bus1_node</span></a></span><span class="refpurpose"> — 
     node objects
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-unref-queued"><span class="phrase">bus1_handle_unref_queued</span></a></span><span class="refpurpose"> — 
     unref queued handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-pair"><span class="phrase">bus1_handle_pair</span></a></span><span class="refpurpose"> — 
     transfer handle manually from one peer to another
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-release-by-id"><span class="phrase">bus1_handle_release_by_id</span></a></span><span class="refpurpose"> — 
     release a user handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-node-destroy-by-id"><span class="phrase">bus1_node_destroy_by_id</span></a></span><span class="refpurpose"> — 
     destroy a node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-flush-all"><span class="phrase">bus1_handle_flush_all</span></a></span><span class="refpurpose"> — 
     flush all nodes and handles of a peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-init"><span class="phrase">bus1_handle_dest_init</span></a></span><span class="refpurpose"> — 
     initialize destination handle context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-destroy"><span class="phrase">bus1_handle_dest_destroy</span></a></span><span class="refpurpose"> — 
     destroy destination handle context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-import"><span class="phrase">bus1_handle_dest_import</span></a></span><span class="refpurpose"> — 
     import destination handle
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-dest-export"><span class="phrase">bus1_handle_dest_export</span></a></span><span class="refpurpose"> — 
     publish new nodes of destination context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-init"><span class="phrase">bus1_handle_transfer_init</span></a></span><span class="refpurpose"> — 
     initialize handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-release"><span class="phrase">bus1_handle_transfer_release</span></a></span><span class="refpurpose"> — 
     release handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-destroy"><span class="phrase">bus1_handle_transfer_destroy</span></a></span><span class="refpurpose"> — 
     destroy handle transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-import"><span class="phrase">bus1_handle_transfer_import</span></a></span><span class="refpurpose"> — 
     import handles for transfer
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-transfer-export"><span class="phrase">bus1_handle_transfer_export</span></a></span><span class="refpurpose"> — 
     publish new nodes of transfer context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-init"><span class="phrase">bus1_handle_inflight_init</span></a></span><span class="refpurpose"> — 
     initialize inflight context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-destroy"><span class="phrase">bus1_handle_inflight_destroy</span></a></span><span class="refpurpose"> — 
     destroy inflight-context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-flush"><span class="phrase">bus1_handle_inflight_flush</span></a></span><span class="refpurpose"> — 
     flush pinned resources
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-import"><span class="phrase">bus1_handle_inflight_import</span></a></span><span class="refpurpose"> — 
     import inflight context
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-install"><span class="phrase">bus1_handle_inflight_install</span></a></span><span class="refpurpose"> — 
     install inflight handles
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-walk"><span class="phrase">bus1_handle_inflight_walk</span></a></span><span class="refpurpose"> — 
     walk all handle IDs
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-handle-inflight-commit"><span class="phrase">bus1_handle_inflight_commit</span></a></span><span class="refpurpose"> — 
     commit inflight context
 </span></dt></dl></div><p>
   </p><p>
   The object system on a bus is based on 'nodes' and 'handles'. Any peer can
   allocate new, local objects at any time. The creator automatically becomes
   the sole owner of the object. References to objects can be passed as payload
   of messages. The recipient will then gain their own reference to the object
   as well. Additionally, an object can be the destination of a message, in
   which case the message is always sent to the original creator (and thus the
   owner) of the object.
   </p><p>
   Internally, objects are called 'nodes'. A reference to an object is a
   'handle'. Whenever a new node is created, the owner implicitly gains an
   handle as well. In fact, handles are the only way to refer to a node. The
   node itself is entirely hidden in the implementation.
   </p><p>
   Whenever a handle is passed as payload of a message, the target peer will
   gain a handle linked to the same underlying node. This works regardless
   of whether the sender is the owner of the underlying node, or not.
   </p><p>
   Each peer can identify all its handles (both owned and un-owned) by a 64-bit
   integer. The namespace is local to each peer, and the numbers cannot be
   compared with the numbers of other peers (in fact, they will be very likely
   to clash, but might still have *different* underlying nodes). However, if a
   peer receives a reference to the same node multiple times, the resulting
   handle will be the same. The kernel keeps count of how often each peer owns a
   handle.
   </p><p>
   If a peer no longer requires a specific handle, it can release it. If the
   peer releases its last reference to a handle, the handle will be destroyed.
   </p><p>
   The ID of an handle is never reused. That is, once a handle was fully
   released, any new handle the peer receives will have a different ID. Note,
   however, that the handle of the owner of a node is internally pinned. As
   such, it is always reused if the owner gains a handle to its own node again
   (this is required for explicit node destruction).
   </p><p>
   The owner of a node (and *only* the owner) can trigger the destruction of a
   node (even if other peers still own handles to it). In this case, all peers
   that own a handle are notified of this fact.
   Once all handles to a specific node have been released (except for the handle
   internally pinned in the node itself), the owner of the node is notified of
   this, so it can potentially destroy both any linked state and the node
   itself.
   </p><p>
   Node destruction is fully synchronized with any transaction. That is, a node
   and all its handles are valid in every message that is transmitted *before*
   the notification of its destruction. Furthermore, no message after this
   notification will carry the ID of such a destroyed node.
   Note that message transactions are fully async. That is, there is no unique
   point in time that a message is synchronized with another message. Hence,
   whether a specific handle passed with a message is still valid or not,
   cannot be predicted by the sender, but only by one of the receivers.
</p><div class="refentry"><a name="API-struct-bus1-handle-dest"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle_dest — 
  destination context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle_dest {
  struct bus1_handle * handle;
  struct bus1_peer * raw_peer;
  u64 __user * idp;
};  </pre></div><div class="refsect1"><a name="id-1.7.11.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">handle</span></dt><dd><p>
local destination handle
      </p></dd><dt><span class="term">raw_peer</span></dt><dd><p>
remote destination peer (raw active ref)
      </p></dd><dt><span class="term">idp</span></dt><dd><p>
user-memory to store allocated ID at
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-BUS1-HANDLE-BATCH-SIZE"></a><div class="titlepage"></div><div class="refnamediv"><p>BUS1_HANDLE_BATCH_SIZE — 
     number of handles per set in a batch
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef"> <b class="fsfunc">BUS1_HANDLE_BATCH_SIZE </b>(</code><code>void)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.12.5"></a><h2>Arguments</h2><p>
  None
 </p></div><div class="refsect1"><a name="id-1.7.12.6"></a><h2>Description</h2><p>
   </p><p>

   We need to support large handle transactions, bigger than any linear
   allocation we're supposed to do in a running kernel. Hence, we batch all
   handles in a transaction into sets of this size. The `bus1_handle_batch`
   object transparently hides this, and pretends it is a linear array.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle-entry"></a><div class="titlepage"></div><div class="refnamediv"><p>union bus1_handle_entry — 
     batch entry
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
union bus1_handle_entry {
  union bus1_handle_entry * next;
  struct bus1_handle * handle;
  u64 id;
};  </pre></div><div class="refsect1"><a name="id-1.7.13.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">next</span></dt><dd><p>
   pointer to next batch entry
      </p></dd><dt><span class="term">handle</span></dt><dd><p>
   pointer to stored handle
      </p></dd><dt><span class="term">id</span></dt><dd><p>
   stored handle ID
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.13.6"></a><h2>Description</h2><p>
   This union represents a single handle-entry in a batch. To support large
   batches, we only store a limited number of handles consecutively. Once the
   batch size is reached, a new batch is allocated and linked  This is all
   hidden in the batch implementation, the details are hidden from the caller.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle-batch"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle_batch — 
     dynamic set of handles
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle_batch {
  size_t n_entries;
  size_t n_handles;
  union bus1_handle_entry entries[0];
};  </pre></div><div class="refsect1"><a name="id-1.7.14.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_entries</span></dt><dd><p>
   number of ids or handles this batch carries (excluding
   .next pointers)
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
   number of slots that actually have a handle pinned
      </p></dd><dt><span class="term">entries[0]</span></dt><dd><p>
   stored entries
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.14.6"></a><h2>Description</h2><p>
   The batch object allows handling multiple handles in a single set. Each
   batch can store an unlimited number of handles, and internally they're
   grouped into batches of BUS1_HANDLE_BATCH_SIZE entries.
   </p><p>

   All handles are put into the trailing array <em class="parameter"><code>entries</code></em>. However, at most
   BUS1_HANDLE_BATCH_SIZE entries are stored there. If this number is exceeded,
   then batch-&gt;entries[BUS1_HANDLE_BATCH_SIZE].next points to the next
   dynamically allocated array of bus1_handle_entry objects. This can be
   extended as often as you want, to support unlimited sized batches.
   </p><p>

   The caller must not access <em class="parameter"><code>entries</code></em> directly!
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle-transfer"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle_transfer — 
     handle transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle_transfer {
  size_t n_new;
  struct bus1_handle_batch batch;
};  </pre></div><div class="refsect1"><a name="id-1.7.15.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_new</span></dt><dd><p>
   number of newly allocated nodes
      </p></dd><dt><span class="term">batch</span></dt><dd><p>
   associated handles
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.15.6"></a><h2>Description</h2><p>
   The bus1_handle_transfer object contains context state for message
   transactions, regarding handle transfers. It pins all the local handles of
   the sending peer for the whole duration of a transaction. It is usually used
   to instantiate bus1_handle_inflight objects for each destination.
   </p><p>

   A transfer context should have the same lifetime as the parent transaction
   context.
   </p><p>

   Note that the tail of the object contains a dynamically sized array with the
   first handle-set of <em class="parameter"><code>batch</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle-inflight"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle_inflight — 
     set of inflight handles
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle_inflight {
  size_t n_new;
  struct bus1_handle_batch batch;
};  </pre></div><div class="refsect1"><a name="id-1.7.16.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_new</span></dt><dd><p>
   number of newly allocated nodes
      </p></dd><dt><span class="term">batch</span></dt><dd><p>
   associated handles
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.16.6"></a><h2>Description</h2><p>
   The bus1_handle_inflight object carries state for each message instance
   regarding handle transfers. That is, it contains all the handle instances
   for the receiver of the message (while bus1_handle_transfer pins the handles
   of the sender). This object is usually embedded in the queue-entry that is
   used to send a single message instance to another peer.
   </p><p>

   Note that the tail of the object contains a dynamically sized array with the
   first handle-set of <em class="parameter"><code>batch</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-batch-inline-size"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_batch_inline_size — 
     calculate required inline size
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">size_t <b class="fsfunc">bus1_handle_batch_inline_size </b>(</code>size_t <var class="pdparam">n_entries</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>n_entries</code></em></span></dt><dd><p>
     size of batch
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.17.6"></a><h2>Description</h2><p>
   This calculates the size of the trailing entries array that is to be
   embedded into a <span class="quote">“<span class="quote">struct bus1_handle_batch</span>”</span>. That is, to statically allocate
   a batch, you need a memory block of size:
   </p><p>

   sizeof(struct bus1_handle_batch) + bus1_handle_batch_inline_size(n);
   </p><p>

   where 'n' is the number of entries to store. Note that <em class="parameter"><code>n</code></em> is capped. You
   still need to call <code class="function">bus1_handle_batch_create</code> afterwards, to make sure the
   memory is properly allocated, in case it does not fit into a single set.
</p></div><div class="refsect1"><a name="id-1.7.17.7"></a><h2>Return</h2><p>
   Size of required trailing bytes of a batch structure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-handle"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_handle — 
  handle objects
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_handle {
  struct bus1_queue_node qnode;
  atomic_t n_inflight;
  atomic_t n_user;
  struct rb_node rb_id;
  struct rb_node rb_node;
  struct bus1_node * node;
  u64 id;
  struct bus1_peer __rcu * holder;
  union {unnamed_union};
};  </pre></div><div class="refsect1"><a name="id-1.7.18.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">qnode</span></dt><dd><p>
embedded queue node (used for destruction notification)
      </p></dd><dt><span class="term">n_inflight</span></dt><dd><p>
number of inflight references; initially -1 if
unattached; &gt;0 if live; 0 if about to be detached
      </p></dd><dt><span class="term">n_user</span></dt><dd><p>
number of user-visible references (shifted by -1)
      </p></dd><dt><span class="term">rb_id</span></dt><dd><p>
link into owning peer, based on ID
      </p></dd><dt><span class="term">rb_node</span></dt><dd><p>
link into owning peer, based on node pointer
      </p></dd><dt><span class="term">node</span></dt><dd><p>
node this handle is linked to
      </p></dd><dt><span class="term">id</span></dt><dd><p>
current ID of this handle
      </p></dd><dt><span class="term">holder</span></dt><dd><p>
holder of this node
      </p></dd><dt><span class="term">{unnamed_union}</span></dt><dd><p>
anonymous
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.18.6"></a><h2>Description</h2><p>
   Handle objects represent an accessor to nodes. A handle is always held by a
   specific peer, and by that peer only. The peer-lock (or data-lock,
   respectively) protects access to this handle. Effectively, handles represent
   a connection between two peers (between the holder of the handle and the
   owner of its linked node). Such connections can exist both ways, hence, both
   peers are treated as equals. You cannot lock both peers at the same time.
   </p><p>

   <em class="parameter"><code>ref</code></em> and <em class="parameter"><code>n_inflight</code></em> must be accessed atomically, <em class="parameter"><code>node</code></em> is set statically
   and pinned for the entire lifetime of the object. <em class="parameter"><code>n_user</code></em>, <em class="parameter"><code>rb_id</code></em>, <em class="parameter"><code>rb_node</code></em>,
   <em class="parameter"><code>id</code></em>, and <em class="parameter"><code>holder</code></em> are protected by the peer-lock of the holding peer.
   <em class="parameter"><code>link_node</code></em> is protected by the peer-lock of the node-owner
   (handle-&gt;node-&gt;owner.holder, which *might* be NULL if racing a node
   destruction).
   </p><p>

   Handles always pin the node they're linked to, and the node can be accessed
   freely at all times. During handle setup, two independent steps are required:
   </p><p>

   1) Attach:
   The handle must be attached to the node so a node-owner can enumerate
   all linked handles. This required locking the peer-lock of the
   node-owner.
   </p><p>

   2) Install:
   The handle must be installed into the lookup-trees of the holding peer.
   This requires locking the peer-lock of the holder of the handle.
   </p><p>

   Handles don't have any lock themselves, but are protected by the respective
   peer locks of their holders. However, during teardown of a handle, the holder
   must be cleared to NULL, which means racing accesses might be unable to
   dereference the peer. Hence, if we detect this case, we treat the handle as
   disconnected and rely on the context to clean the handle up properly. The
   holder of a handle is set *before* ATTACH and cleared during UNINSTALL. That
   is, we expect a handle to have the holder set before it is made visible to
   any other context, but we immediately clear it at the first part of
   destruction.
   </p><p>

   The two connections of a handle (to its node, and to its holder) can be
   dropped independently. The holder of a handle always has full control over
   its lifetime. That means, only if the holder releases its last reference, or
   if they disconnect, they will cause an uninstall of the handle. As long as a
   holder has a reference, the handle will stay alive (but there's no guarantee
   that its linked node is still live).
   At the same time, the owner of a node is has full control over the node
   lifetime. They can destroy the node at any time, causing a detach operation
   of all linked handles (note that all handle-&gt;node pointers stay valid, but
   the handle-&gt;link_node links are cleared).
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-enum-bus1-node-bit"></a><div class="titlepage"></div><div class="refnamediv"><p>enum bus1_node_bit — 
     state flags of node objects
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
enum bus1_node_bit {
  BUS1_NODE_BIT_PERSISTENT,
  BUS1_NODE_BIT_ATTACHED,
  BUS1_NODE_BIT_DESTROYED
};  </pre></div><div class="refsect1"><a name="id-1.7.19.5"></a><h2>Constants</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">BUS1_NODE_BIT_PERSISTENT</span></dt><dd><p>
   Node was created as persistent node by its
   owner. This flag is set during node creation
   and must not be modified further.
      </p></dd><dt><span class="term">BUS1_NODE_BIT_ATTACHED</span></dt><dd><p>
   Owner handle is attached to this node. This is
   a debug flag to verify that a node was properly
   initialized before it is used.
      </p></dd><dt><span class="term">BUS1_NODE_BIT_DESTROYED</span></dt><dd><p>
   Node is about to be, or is already, destroyed.
   No further handles can be attached and the node
   destruction has a valid timestamp to order
   against other messages.
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-node"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_node — 
     node objects
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_node {
  struct bus1_queue_node qnode;
  unsigned long flags;
  u64 timestamp;
  struct list_head list_handles;
  struct bus1_handle owner;
};  </pre></div><div class="refsect1"><a name="id-1.7.20.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">qnode</span></dt><dd><p>
   embedded queue node (used for release notification)
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
   node flags, see enum bus1_node_bit
      </p></dd><dt><span class="term">timestamp</span></dt><dd><p>
   destruction timestamp (0 if still live)
      </p></dd><dt><span class="term">list_handles</span></dt><dd><p>
   linked list of registered handles
      </p></dd><dt><span class="term">owner</span></dt><dd><p>
   embedded handle of node owner
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.20.6"></a><h2>Description</h2><p>
   Every existing node is represented by a single bus1_node object. A node is
   always connected to its owner, which is embedded with its own handle as
   <em class="parameter"><code>owner</code></em>. <em class="parameter"><code>ref</code></em> and <em class="parameter"><code>flags</code></em> must be accessed with atomic operations, everything
   else is protected by the peer-lock (or data-lock respectively) of
   node-&gt;owner.holder.
   </p><p>

   A node represents the context shared by all handles connected to that node.
   The node itself is not linked into any lookup trees, nor should anyone but
   handles take references to the node. To pin a node, always pin the handle
   you want to use to access the node through. A bus1_node object itself does
   not give any guarantee about node-&gt;owner, hence, you might not be able to
   lock the required mutices.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-unref-queued"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_unref_queued — 
     unref queued handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_handle_unref_queued </b>(</code>struct bus1_queue_node * <var class="pdparam">qnode</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.21.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>qnode</code></em></span></dt><dd><p>
     queue node to operate on, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.21.6"></a><h2>Description</h2><p>
   This returns the handle-id of the queued handle notification <em class="parameter"><code>qnode</code></em> and
   drops a single reference of <em class="parameter"><code>qnode</code></em>.
   </p><p>

   If the returned ID is required to be stable and valid, the owning peer of
   the respective handle must be locked.
   </p><p>

   If NULL is passed, this is a no-op and returns BUS1_HANDLE_INVALID.
</p></div><div class="refsect1"><a name="id-1.7.21.7"></a><h2>Return</h2><p>
   Handle ID, or BUS1_HANDLE_INVALID if unknown to the user.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-pair"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_pair — 
     transfer handle manually from one peer to another
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_pair </b>(</code>struct bus1_peer * <var class="pdparam">src</var>, struct bus1_peer * <var class="pdparam">dst</var>, u64 * <var class="pdparam">src_idp</var>, u64 * <var class="pdparam">dst_idp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.22.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>src</code></em></span></dt><dd><p>
     holder of handle to transfer
    </p></dd><dt><span class="term"><em class="parameter"><code>dst</code></em></span></dt><dd><p>
     peer to import handle to
    </p></dd><dt><span class="term"><em class="parameter"><code>src_idp</code></em></span></dt><dd><p>
     ID of handle to transfer
    </p></dd><dt><span class="term"><em class="parameter"><code>dst_idp</code></em></span></dt><dd><p>
     output for newly created handle ID
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.22.6"></a><h2>Description</h2><p>
   This imports a handle into the peer <em class="parameter"><code>dst</code></em> and returns its new ID via <em class="parameter"><code>dst_idp</code></em>.
   The handle to be transferred must be given via <em class="parameter"><code>src_idp</code></em> (and <em class="parameter"><code>src</code></em> must be its
   holder). If BUS1_NODE_FLAG_ALLOCATE is given, a new node is allocated in
   <em class="parameter"><code>src</code></em> and returned in <em class="parameter"><code>src_idp</code></em>.
</p></div><div class="refsect1"><a name="id-1.7.22.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-release-by-id"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_release_by_id — 
     release a user handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_release_by_id </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, u64 <var class="pdparam">id</var>, size_t * <var class="pdparam">n_handlesp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.23.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>id</code></em></span></dt><dd><p>
     handle ID
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handlesp</code></em></span></dt><dd><p>
     output-var to store number of released handles, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.23.6"></a><h2>Description</h2><p>
   This releases a *user* visible reference to the handle with the given ID.
   </p><p>

   For each handle of which the last user-refcount is dropped, this increments
   <em class="parameter"><code>n_handlesp</code></em> by one (usually this means either 0 or 1).
</p></div><div class="refsect1"><a name="id-1.7.23.7"></a><h2>Return</h2><p>
   &gt;=0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-node-destroy-by-id"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_node_destroy_by_id — 
     destroy a node
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_node_destroy_by_id </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, u64 * <var class="pdparam">idp</var>, size_t * <var class="pdparam">n_handlesp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.24.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>idp</code></em></span></dt><dd><p>
     pointer to handle ID
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handlesp</code></em></span></dt><dd><p>
     output-var to store number of released handles, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.24.6"></a><h2>Description</h2><p>
   This destroys the underlying node of the handle with the given ID. The usual
   allocation rules for <em class="parameter"><code>idp</code></em> apply. If <em class="parameter"><code>idp</code></em> was modified, 1 is returned. If
   <em class="parameter"><code>idp</code></em> was not modified, 0 is returned. On error, a negative error code is
   returned.
   </p><p>

   For each handle of which the last user-refcount is dropped, this increments
   <em class="parameter"><code>n_handlesp</code></em> by one (usually this means either 0 or 1).
</p></div><div class="refsect1"><a name="id-1.7.24.7"></a><h2>Return</h2><p>
   &gt;=0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-flush-all"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_flush_all — 
     flush all nodes and handles of a peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_flush_all </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, size_t * <var class="pdparam">n_handlesp</var>, bool <var class="pdparam">final</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.25.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handlesp</code></em></span></dt><dd><p>
     output-var to store number of released handles, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>final</code></em></span></dt><dd><p>
     whether to flush persistent nodes
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.25.6"></a><h2>Description</h2><p>
   This atomically destroys all nodes, and releases all handles, of the given
   peer. Note that the destruction is atomic in all regards, but the handle
   release is only atomic in regard to the holding peer. That is, the possible
   effect on any remote node is not atomic, but done sequentially afterwards.
   </p><p>

   For each handle of which the last user-refcount is dropped, this increments
   <em class="parameter"><code>n_handlesp</code></em> by one.
   </p><p>

   If <em class="parameter"><code>final</code></em> is false, persistent nodes are left untouched, otherwise, even
   persistent nodes are destroyed.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-dest-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_dest_init — 
     initialize destination handle context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_dest_init </b>(</code>struct bus1_handle_dest * <var class="pdparam">dest</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.26.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>dest</code></em></span></dt><dd><p>
     destination context to initialize
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.26.6"></a><h2>Description</h2><p>
   This initializes a destination handle context. The object is needed to
   lookup and optionally create the destination handle held by the sender during
   a transaction. That is, for each destination of a transaction, you need one
   destination handle context.
   </p><p>

   The destination handle can be imported via <code class="function">bus1_handle_dest_import</code>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-dest-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_dest_destroy — 
     destroy destination handle context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_dest_destroy </b>(</code>struct bus1_handle_dest * <var class="pdparam">dest</var>, struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.27.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>dest</code></em></span></dt><dd><p>
     destination handle context to destroy, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     info:		owning peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.27.6"></a><h2>Description</h2><p>
   This releases all data pinned by a destination handle context. If Null is
   passed, or if the destination object was already destroyed, then nothing is
   done.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-dest-import"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_dest_import — 
     import destination handle
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_dest_import </b>(</code>struct bus1_handle_dest * <var class="pdparam">dest</var>, struct bus1_peer * <var class="pdparam">peer</var>, u64 __user * <var class="pdparam">idp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.28.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>dest</code></em></span></dt><dd><p>
     destination context
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to import handles of
    </p></dd><dt><span class="term"><em class="parameter"><code>idp</code></em></span></dt><dd><p>
     user-space handle ID pointer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.28.6"></a><h2>Description</h2><p>
   This imports a handle-ID from user-space (provided as <em class="parameter"><code>idp</code></em>) into the
   destination handle context. It then resolves it to the actual bus1_handle
   objects, optionally creating a new one on demand.
   </p><p>

   This can only be called once per destination handle context.
</p></div><div class="refsect1"><a name="id-1.7.28.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-dest-export"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_dest_export — 
     publish new nodes of destination context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_handle_dest_export </b>(</code>struct bus1_handle_dest * <var class="pdparam">dest</var>, struct bus1_peer * <var class="pdparam">peer</var>, u64 <var class="pdparam">timestamp</var>, unsigned long <var class="pdparam">sender</var>, bool <var class="pdparam">commit</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.29.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>dest</code></em></span></dt><dd><p>
     destination context
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     owning peer of <em class="parameter"><code>dest</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     final timestamp of message transaction
    </p></dd><dt><span class="term"><em class="parameter"><code>sender</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>commit</code></em></span></dt><dd><p>
     whether to commit the node
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.29.6"></a><h2>Description</h2><p>
   If a node was created as the destination of a transaction, we have to publish
   its handle ID back to the caller. This function acquires the ID, and it is up
   to the caller to copy it back to userspace.
   </p><p>

   The caller must hold the peer lock of <em class="parameter"><code>peer</code></em>.
</p></div><div class="refsect1"><a name="id-1.7.29.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_init — 
     initialize handle transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_transfer_init </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var>, size_t <var class="pdparam">n_entries</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.30.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>n_entries</code></em></span></dt><dd><p>
     number of handles that are transferred
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.30.6"></a><h2>Description</h2><p>
   This initializes a handle-transfer context. This object is needed to lookup,
   pin, and optionally create, the handles of the sender during a transaction.
   That is, for each transaction, you need one handle-transfer object,
   initialized with the number of handles to transfer.
   </p><p>

   Handles can be imported via <code class="function">bus1_handle_transfer_import</code>. Once done,
   the handle-inflight objects can be instantiated from it for each destination
   of the transaction.
   </p><p>

   The handle-transfer context embeds a handle-batch, as such must be
   pre-allocated via <code class="function">bus1_handle_batch_inline_size</code>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-release"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_release — 
     release handle transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_transfer_release </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var>, struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.31.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context to release, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     owning peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.31.6"></a><h2>Description</h2><p>
   This releases all handles that were pinned on the transfer context. This
   might require locking the owning peer.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_destroy — 
     destroy handle transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_transfer_destroy </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.32.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.32.6"></a><h2>Description</h2><p>
   This frees all allocated data of the handle-transfer context. If handles were
   imported, the caller must call <code class="function">bus1_handle_transfer_release</code> before
   destroying the transfer context.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-import"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_import — 
     import handles for transfer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_transfer_import </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var>, struct bus1_peer * <var class="pdparam">peer</var>, const u64 __user * <var class="pdparam">ids</var>, size_t <var class="pdparam">n_ids</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.33.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer to import handles of
    </p></dd><dt><span class="term"><em class="parameter"><code>ids</code></em></span></dt><dd><p>
     user-space array of handle IDs
    </p></dd><dt><span class="term"><em class="parameter"><code>n_ids</code></em></span></dt><dd><p>
     number of IDs in <em class="parameter"><code>ids</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.33.6"></a><h2>Description</h2><p>
   This imports an array of handle-IDs from user-space (provided as <em class="parameter"><code>ids</code></em> +
   <em class="parameter"><code>n_ids</code></em>) into the transfer context. It then resolves each of them to their
   actual bus1_handle objects, optionally creating new ones on demand.
   </p><p>

   This can only be called once per transfer context. Also, <em class="parameter"><code>n_ids</code></em> must match
   the size used with <code class="function">bus1_handle_transfer_init</code>.
</p></div><div class="refsect1"><a name="id-1.7.33.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-transfer-export"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_transfer_export — 
     publish new nodes of transfer context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_transfer_export </b>(</code>struct bus1_handle_transfer * <var class="pdparam">transfer</var>, struct bus1_peer * <var class="pdparam">peer</var>, u64 __user * <var class="pdparam">ids</var>, size_t <var class="pdparam">n_ids</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.34.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     transfer context
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     owning peer of <em class="parameter"><code>transfer</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>ids</code></em></span></dt><dd><p>
     user pointer to store IDs to
    </p></dd><dt><span class="term"><em class="parameter"><code>n_ids</code></em></span></dt><dd><p>
     number of IDs
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.34.6"></a><h2>Description</h2><p>
   For every node that is created as part of an handle transfer, we have to
   publish the handle ID back to the caller. This function acquires the handle
   IDs *and* directly copies them over into the user-provided buffers.
   </p><p>

   The caller must hold the peer lock of <em class="parameter"><code>peer</code></em>.
</p></div><div class="refsect1"><a name="id-1.7.34.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_init — 
     initialize inflight context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_inflight_init </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, size_t <var class="pdparam">n_entries</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.35.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>n_entries</code></em></span></dt><dd><p>
     number of entries to store in this context
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.35.6"></a><h2>Description</h2><p>
   This initializes an inflight-context to carry <em class="parameter"><code>n_entries</code></em> handles. An
   inflight-context is used to instantiate and commit the handles a peer
   *receives* via a transaction. That is, it is created once for each
   destination of a transaction, and it is instantiated from the
   transfer-context of the transaction origin/sender.
   </p><p>

   The inflight-context embeds a handle-batch, as such must be pre-allocated
   via <code class="function">bus1_handle_batch_inline_size</code>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_destroy — 
     destroy inflight-context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_inflight_destroy </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.36.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to destroy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.36.6"></a><h2>Description</h2><p>
   This destroys the inflight context. The caller must make sure to flush the
   context before destroying it, in case any handles were imported.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-flush"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_flush — 
     flush pinned resources
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_inflight_flush </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer * <var class="pdparam">peer</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.37.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to flush
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     owning peer
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.37.6"></a><h2>Description</h2><p>
   This releases all handles that were pinned on the inflight context. This
   might require locking the owning peer.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-import"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_import — 
     import inflight context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_handle_inflight_import </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer * <var class="pdparam">peer</var>, struct bus1_handle_transfer * <var class="pdparam">transfer</var>, struct bus1_peer * <var class="pdparam">src</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.38.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to instantiate
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer info to instantiate for
    </p></dd><dt><span class="term"><em class="parameter"><code>transfer</code></em></span></dt><dd><p>
     peer info owning the transfer object
    </p></dd><dt><span class="term"><em class="parameter"><code>src</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.38.6"></a><h2>Description</h2><p>
   Instantiate an inflight-context from an existing transfer-context. Import
   each pinned handle from the transfer-context into the peer <em class="parameter"><code>peer</code></em>,
   creating new handles if required. All the handles are pinned in the inflight
   context, but not committed, yet.
   </p><p>

   This must only be called once per inflight object. Furthermore, the number
   of handles must match the number of handles of the transfer-context.
</p></div><div class="refsect1"><a name="id-1.7.38.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-install"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_install — 
     install inflight handles
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_inflight_install </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer * <var class="pdparam">dst</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.39.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     instantiated inflight context
    </p></dd><dt><span class="term"><em class="parameter"><code>dst</code></em></span></dt><dd><p>
     peer <em class="parameter"><code>inflight</code></em> is for
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.39.6"></a><h2>Description</h2><p>
   After an inflight context was successfully instantiated, this will install
   the handles into the peer <em class="parameter"><code>dst</code></em>.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-walk"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_walk — 
     walk all handle IDs
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">size_t <b class="fsfunc">bus1_handle_inflight_walk </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer * <var class="pdparam">peer</var>, size_t * <var class="pdparam">pos</var>, size_t * <var class="pdparam">new</var>, void ** <var class="pdparam">iter</var>, u64 * <var class="pdparam">ids</var>, u64 <var class="pdparam">timestamp</var>, unsigned long <var class="pdparam">sender</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.40.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to walk
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer info of inflight owner
    </p></dd><dt><span class="term"><em class="parameter"><code>pos</code></em></span></dt><dd><p>
     current iterator position
    </p></dd><dt><span class="term"><em class="parameter"><code>new</code></em></span></dt><dd><p>
     counts new handle installs
    </p></dd><dt><span class="term"><em class="parameter"><code>iter</code></em></span></dt><dd><p>
     opaque iterator
    </p></dd><dt><span class="term"><em class="parameter"><code>ids</code></em></span></dt><dd><p>
     output storage for ID block
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     timestamp of the transaction
    </p></dd><dt><span class="term"><em class="parameter"><code>sender</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.40.6"></a><h2>Description</h2><p>
   This walks over all stored handles of <em class="parameter"><code>inflight</code></em>, returning their IDs in
   blocks to the caller, instantiating them if necessary. If a given handle will
   be invalid at <em class="parameter"><code>timestamp</code></em>, BUS1_HANDLE_INVALID is returned instead. The caller
   must initialize <em class="parameter"><code>pos</code></em> to 0 and pre-allocate <em class="parameter"><code>ids</code></em> large enough to hold IDs of
   all stored handles, but at most BUS1_HANDLE_BATCH_SIZE.
   </p><p>

   On each call, this function advances <em class="parameter"><code>pos</code></em> and <em class="parameter"><code>iter</code></em> to keep track of the
   iteration, and updates <em class="parameter"><code>ids</code></em> with the handle IDs of the current block. It
   returns the size of the current block, which is at most
   BUS1_HANDLE_BATCH_SIZE. For each newly to-be-installed user-space, it
   increases <em class="parameter"><code>new</code></em> by one.
   </p><p>

   Once this returns 0, the iteration is finished.
</p></div><div class="refsect1"><a name="id-1.7.40.7"></a><h2>Return</h2><p>
   Number of IDs in the next block, 0 if done.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-handle-inflight-commit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_handle_inflight_commit — 
     commit inflight context
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_handle_inflight_commit </b>(</code>struct bus1_handle_inflight * <var class="pdparam">inflight</var>, struct bus1_peer * <var class="pdparam">peer</var>, u64 <var class="pdparam">timestamp</var>, unsigned long <var class="pdparam">sender</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.7.41.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>inflight</code></em></span></dt><dd><p>
     inflight context to commit
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd><dt><span class="term"><em class="parameter"><code>sender</code></em></span></dt><dd><p>
     -- undescribed --
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.7.41.6"></a><h2>Description</h2><p>
   This commits a fully installed inflight context, given the timestamp of a
   transaction. This will make sure to only transfer the actual handles if it is
   ordered *before* the handle destruction.
   </p><p>

   This must be called after a successful walk via <code class="function">bus1_handle_inflight_walk</code>.
   You must not release the peer-lock in-between, and the same timestamp must
   be provided.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="user"></a>Chapter 6. Bus1 User</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-user"><span class="phrase">struct bus1_user</span></a></span><span class="refpurpose"> — 
  resource accounting for users
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-stats"><span class="phrase">struct bus1_user_stats</span></a></span><span class="refpurpose"> — 
     quota statistics between a user and a peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-user-quota"><span class="phrase">struct bus1_user_quota</span></a></span><span class="refpurpose"> — 
     quota handling
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-exit"><span class="phrase">bus1_user_exit</span></a></span><span class="refpurpose"> — 
  clean up global resources of user accounting
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref-by-uid"><span class="phrase">bus1_user_ref_by_uid</span></a></span><span class="refpurpose"> — 
     get a user object for a uid
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-ref"><span class="phrase">bus1_user_ref</span></a></span><span class="refpurpose"> — 
     acquire reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-unref"><span class="phrase">bus1_user_unref</span></a></span><span class="refpurpose"> — 
     release reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-init"><span class="phrase">bus1_user_quota_init</span></a></span><span class="refpurpose"> — 
     initialize quota object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-destroy"><span class="phrase">bus1_user_quota_destroy</span></a></span><span class="refpurpose"> — 
     destroy quota object
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-charge"><span class="phrase">bus1_user_quota_charge</span></a></span><span class="refpurpose"> — 
     try charging a user
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-discharge"><span class="phrase">bus1_user_quota_discharge</span></a></span><span class="refpurpose"> — 
     discharge a user
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-user-quota-commit"><span class="phrase">bus1_user_quota_commit</span></a></span><span class="refpurpose"> — 
     commit a quota charge
 </span></dt></dl></div><p>
   </p><p>
   Different users can communicate via bus1, and many resources are shared
   between multiple users. The bus1_user object represents the UID of a user,
   like <span class="quote">“<span class="quote">struct user_struct</span>”</span> does in the kernel core. It is used to account
   global resources, apply limits, and calculate quotas if different UIDs
   communicate with each other.
   </p><p>
   All dynamic resources have global per-user limits, which cannot be exceeded
   by a user. They prevent a single user from exhausting local resources. Each
   peer that is created is always owned by the user that initialized it. All
   resources allocated on that peer are accounted on that pinned user.
   Additionally to global resources, there are local limits per peer, that can
   be controlled by each peer individually (e.g., specifying a maximum pool
   size). Those local limits allow a user to distribute the globally available
   resources across its peer instances.
   </p><p>
   Since bus1 allows communication across UID boundaries, any such transmission
   of resources must be properly accounted. Bus1 employs dynamic quotas to
   fairly distribute available resources. That is, each transmission is seen by
   bus1 as a transmission of resources from a UID to a peer. Any transmitted
   resources are thus limited by a quota object that represents the combination
   of the sending UID and the receiving peer. This means, regardless how many
   different peers a possibly malicious user creates, they are accounted to the
   same limits. So whenever a UID transmits resources to a peer, it gets access
   to a dynamically calculated subset of the receiver's resource limits. But it
   never gets access to the entire resource space, so it cannot exhaust the
   resource limits of the receiver, but only its own quota on those resource
   limits.
</p><div class="refentry"><a name="API-struct-bus1-user"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_user — 
  resource accounting for users
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_user {
  union {unnamed_union};
  struct kref ref;
  unsigned int id;
  kuid_t uid;
  atomic_t n_slices;
  atomic_t n_handles;
  atomic_t n_inflight_bytes;
  atomic_t n_inflight_fds;
  atomic_t max_slices;
  atomic_t max_handles;
  atomic_t max_bytes;
  atomic_t max_fds;
};  </pre></div><div class="refsect1"><a name="id-1.8.6.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">{unnamed_union}</span></dt><dd><p>
anonymous
      </p></dd><dt><span class="term">ref</span></dt><dd><p>
reference counter
      </p></dd><dt><span class="term">id</span></dt><dd><p>
internal index of this user
      </p></dd><dt><span class="term">uid</span></dt><dd><p>
UID of the user
      </p></dd><dt><span class="term">n_slices</span></dt><dd><p>
number of remaining quota for owned slices
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
number of remaining quota for owned handles
      </p></dd><dt><span class="term">n_inflight_bytes</span></dt><dd><p>
number of remaining quota for inflight bytes
      </p></dd><dt><span class="term">n_inflight_fds</span></dt><dd><p>
number of remaining quota for inflight FDs
      </p></dd><dt><span class="term">max_slices</span></dt><dd><p>
maximum number of owned slices
      </p></dd><dt><span class="term">max_handles</span></dt><dd><p>
maximum number of owned handles
      </p></dd><dt><span class="term">max_bytes</span></dt><dd><p>
maximum number of inflight bytes
      </p></dd><dt><span class="term">max_fds</span></dt><dd><p>
maximum number of inflight FDs
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-user-stats"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_user_stats — 
     quota statistics between a user and a peer
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_user_stats {
  u16 n_slices;
  u16 n_handles;
  u32 n_bytes;
  u16 n_fds;
};  </pre></div><div class="refsect1"><a name="id-1.8.7.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_slices</span></dt><dd><p>
   number of queued slices
      </p></dd><dt><span class="term">n_handles</span></dt><dd><p>
   number of queued handles
      </p></dd><dt><span class="term">n_bytes</span></dt><dd><p>
   memory in bytes used by queued messages
      </p></dd><dt><span class="term">n_fds</span></dt><dd><p>
   number of queued fds
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-user-quota"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_user_quota — 
     quota handling
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_user_quota {
  size_t n_stats;
  struct bus1_user_stats * stats;
};  </pre></div><div class="refsect1"><a name="id-1.8.8.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">n_stats</span></dt><dd><p>
   number of allocated user entries
      </p></dd><dt><span class="term">stats</span></dt><dd><p>
   user entries
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-exit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_exit — 
  clean up global resources of user accounting
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_exit </b>(</code> <var class="pdparam">void</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>void</code></em></span></dt><dd><p>
     no arguments
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.9.6"></a><h2>Description</h2><p>
   </p><p>

   This function cleans up any remaining global resources that were allocated
   by the user accounting helpers. The caller must make sure that no user
   object is referenced anymore, before calling this. This function just clears
   caches and verifies nothing is leaked.
   </p><p>

   This is meant to be called on module-exit.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-ref-by-uid"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_ref_by_uid — 
     get a user object for a uid
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_user * <b class="fsfunc">bus1_user_ref_by_uid </b>(</code>kuid_t <var class="pdparam">uid</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>uid</code></em></span></dt><dd><p>
     uid of the user
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.10.6"></a><h2>Description</h2><p>
   Find and return the user object for the uid if it exists, otherwise create
   it first. This function may take the bus1_user_lock.
</p></div><div class="refsect1"><a name="id-1.8.10.7"></a><h2>Return</h2><p>
   A user object for the given uid, ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-ref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_ref — 
     acquire reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_user * <b class="fsfunc">bus1_user_ref </b>(</code>struct bus1_user * <var class="pdparam">user</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to acquire, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.11.6"></a><h2>Description</h2><p>
   Acquire an additional reference to a user-object. The caller must already
   own a reference.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.8.11.7"></a><h2>Return</h2><p>
   <em class="parameter"><code>user</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-unref"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_unref — 
     release reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_user * <b class="fsfunc">bus1_user_unref </b>(</code>struct bus1_user * <var class="pdparam">user</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to release, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.12.6"></a><h2>Description</h2><p>
   Release a reference to a user-object. This function may take the
   bus1_user_lock.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div><div class="refsect1"><a name="id-1.8.12.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_init — 
     initialize quota object
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_quota_init </b>(</code>struct bus1_user_quota * <var class="pdparam">quota</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>quota</code></em></span></dt><dd><p>
     quota object to initialize
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.13.6"></a><h2>Description</h2><p>
   Initialize all fields of a quota object.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_destroy — 
     destroy quota object
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_quota_destroy </b>(</code>struct bus1_user_quota * <var class="pdparam">quota</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>quota</code></em></span></dt><dd><p>
     quota object to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.14.6"></a><h2>Description</h2><p>
   Destroy and deallocate a quota object. All linked resources are freed, and
   the object is ready for re-use.
   </p><p>

   If NULL is passed, this is a no-op.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-charge"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_charge — 
     try charging a user
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_user_quota_charge </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, struct bus1_user * <var class="pdparam">user</var>, size_t <var class="pdparam">n_bytes</var>, size_t <var class="pdparam">n_handles</var>, size_t <var class="pdparam">n_fds</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.15.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer with quota to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_bytes</code></em></span></dt><dd><p>
     number of bytes to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to charge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_fds</code></em></span></dt><dd><p>
     number of FDs to charge
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.15.6"></a><h2>Description</h2><p>
   This charges <em class="parameter"><code>user</code></em> for the given resources on <em class="parameter"><code>peer</code></em>. If the charge would
   exceed the given quotas at this time, the function fails without making any
   charge. If the charge is successful, the available resources are adjusted
   accordingly both locally on <em class="parameter"><code>peer</code></em> and globally on the associated user.
   </p><p>

   This charges for _one_ message with a size of <em class="parameter"><code>n_bytes</code></em>, carrying
   <em class="parameter"><code>n_handles</code></em> handles and <em class="parameter"><code>n_fds</code></em> file descriptors as payload.
</p></div><div class="refsect1"><a name="id-1.8.15.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-discharge"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_discharge — 
     discharge a user
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_quota_discharge </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, struct bus1_user * <var class="pdparam">user</var>, size_t <var class="pdparam">n_bytes</var>, size_t <var class="pdparam">n_handles</var>, size_t <var class="pdparam">n_fds</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.16.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer with quota to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to discharge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_bytes</code></em></span></dt><dd><p>
     number of bytes to discharge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to discharge
    </p></dd><dt><span class="term"><em class="parameter"><code>n_fds</code></em></span></dt><dd><p>
     number of FDs to discharge
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.16.6"></a><h2>Description</h2><p>
   This reverts a single charge done via <code class="function">bus1_user_quota_charge</code>. It
   discharges a single message with a slice of size <em class="parameter"><code>n_bytes</code></em>, <em class="parameter"><code>n_handles</code></em> handles
   and <em class="parameter"><code>n_fds</code></em> file-descriptors.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-user-quota-commit"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_user_quota_commit — 
     commit a quota charge
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_user_quota_commit </b>(</code>struct bus1_peer * <var class="pdparam">peer</var>, struct bus1_user * <var class="pdparam">user</var>, size_t <var class="pdparam">n_bytes</var>, size_t <var class="pdparam">n_handles</var>, size_t <var class="pdparam">n_fds</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.8.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer with quota to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>user</code></em></span></dt><dd><p>
     user to commit for
    </p></dd><dt><span class="term"><em class="parameter"><code>n_bytes</code></em></span></dt><dd><p>
     number of bytes to commit
    </p></dd><dt><span class="term"><em class="parameter"><code>n_handles</code></em></span></dt><dd><p>
     number of handles to commit
    </p></dd><dt><span class="term"><em class="parameter"><code>n_fds</code></em></span></dt><dd><p>
     number of FDs to commit
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.8.17.6"></a><h2>Description</h2><p>
   Commit a quota charge to the receiving peer. This de-accounts the in-flight
   charges, but keeps the actual object charges on the receiver. The caller must
   make sure the actual objects are de-accounted once they are destructed.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="pool"></a>Chapter 7. Bus1 Pool</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool-slice"><span class="phrase">struct bus1_pool_slice</span></a></span><span class="refpurpose"> — 
  pool slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-pool"><span class="phrase">struct bus1_pool</span></a></span><span class="refpurpose"> — 
     client pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-slice-is-public"><span class="phrase">bus1_pool_slice_is_public</span></a></span><span class="refpurpose"> — 
     check whether a slice is public
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-create"><span class="phrase">bus1_pool_create</span></a></span><span class="refpurpose"> — 
  create memory pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-destroy"><span class="phrase">bus1_pool_destroy</span></a></span><span class="refpurpose"> — 
     pool to destroy
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-alloc"><span class="phrase">bus1_pool_alloc</span></a></span><span class="refpurpose"> — 
     allocate memory
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-kernel"><span class="phrase">bus1_pool_release_kernel</span></a></span><span class="refpurpose"> — 
     release kernel-owned slice reference
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-publish"><span class="phrase">bus1_pool_publish</span></a></span><span class="refpurpose"> — 
     publish a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-release-user"><span class="phrase">bus1_pool_release_user</span></a></span><span class="refpurpose"> — 
     release a public slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-flush"><span class="phrase">bus1_pool_flush</span></a></span><span class="refpurpose"> — 
     flush all user references
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-mmap"><span class="phrase">bus1_pool_mmap</span></a></span><span class="refpurpose"> — 
     mmap the pool
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-iovec"><span class="phrase">bus1_pool_write_iovec</span></a></span><span class="refpurpose"> — 
     copy user memory to a slice
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-pool-write-kvec"><span class="phrase">bus1_pool_write_kvec</span></a></span><span class="refpurpose"> — 
     copy kernel memory to a slice
 </span></dt></dl></div><p>
   </p><p>
   A pool is a shmem-backed memory pool shared between userspace and the kernel.
   The pool is used to transfer memory from the kernel to userspace without
   requiring userspace to allocate the memory.
   </p><p>
   The pool is managed in slices, which are published to userspace when they are
   ready to be read and must be released by userspace when userspace is done
   with them.
   </p><p>
   Userspace has read-only access to its pools and the kernel has read-write
   access, but published slices are not altered.
</p><div class="refentry"><a name="API-struct-bus1-pool-slice"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_pool_slice — 
  pool slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_pool_slice {
  u32 offset;
  u32 free:1;
  u32 ref_kernel:1;
  u32 ref_user:1;
  struct list_head entry;
  struct rb_node rb;
};  </pre></div><div class="refsect1"><a name="id-1.9.6.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">offset</span></dt><dd><p>
relative offset in parent pool
      </p></dd><dt><span class="term">free</span></dt><dd><p>
whether this slice is in-use or not
      </p></dd><dt><span class="term">ref_kernel</span></dt><dd><p>
whether a kernel reference exists
      </p></dd><dt><span class="term">ref_user</span></dt><dd><p>
whether a user reference exists
      </p></dd><dt><span class="term">entry</span></dt><dd><p>
link into linear list of slices
      </p></dd><dt><span class="term">rb</span></dt><dd><p>
link to busy/free rb-tree
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.6.6"></a><h2>Description</h2><p>
   Each chunk of memory in the pool is managed as a slice. A slice can be
   accessible by both the kernel and user-space, and their access rights are
   managed independently. As long as the kernel has a reference to a slice, its
   offset and size can be accessed freely and will not change. Once the kernel
   drops its reference, it must not access the slice, anymore.
   </p><p>

   To allow user-space access, the slice must be published. This marks the slice
   as referenced by user-space. Note that all slices are always readable by
   user-space, since the entire pool can be mapped. Publishing a slice only
   marks the slice as referenced by user-space, so it will not be modified or
   removed. Once user-space releases its reference, it should no longer access
   the slice as it might be modified and/or overwritten by other data.
   </p><p>

   Only if neither kernel nor user-space have a reference to a slice, the slice
   is released. The kernel reference can only be acquired/released once, but
   user-space references can be published/released several times. In particular,
   if the kernel retains a reference when a slice is published and later
   released by userspace, the same slice can be published again in the future.
   </p><p>

   Note that both kernel-space and user-space must be aware that slice
   references are not ref-counted. They are simple booleans. For the kernel-side
   this is obvious, as no ref/unref functions are provided. But user-space must
   be aware that the same slice being published several times does not increase
   the reference count.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-pool"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_pool — 
     client pool
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_pool {
  struct file * f;
  size_t allocated_size;
  struct list_head slices;
  struct rb_root slices_busy;
  struct rb_root slices_free;
};  </pre></div><div class="refsect1"><a name="id-1.9.7.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">f</span></dt><dd><p>
   backing shmem file
      </p></dd><dt><span class="term">allocated_size</span></dt><dd><p>
   currently allocated memory in bytes
      </p></dd><dt><span class="term">slices</span></dt><dd><p>
   all slices sorted by address
      </p></dd><dt><span class="term">slices_busy</span></dt><dd><p>
   tree of allocated slices
      </p></dd><dt><span class="term">slices_free</span></dt><dd><p>
   tree of free slices
      </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.7.6"></a><h2>Description</h2><p>
   A pool is used to allocate memory slices that can be shared between
   kernel-space and user-space. A pool is always backed by a shmem-file and puts
   a simple slice-allocator on top. User-space gets read-only access to the
   entire pool, kernel-space gets read/write access via accessor-functions.
   </p><p>

   Pools are used to transfer large sets of data to user-space, without
   requiring a round-trip to ask user-space for a suitable memory chunk.
   Instead, the kernel simply allocates slices in the pool and tells user-space
   where it put the data.
   </p><p>

   All pool operations must be serialized by the caller. No internal lock is
   provided. Slices can be queried/modified unlocked. But any pool operation
   (allocation, release, flush, ...) must be serialized!
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-slice-is-public"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_slice_is_public — 
     check whether a slice is public
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_pool_slice_is_public </b>(</code>struct bus1_pool_slice * <var class="pdparam">slice</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.8.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to check
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.8.6"></a><h2>Description</h2><p>
   This checks whether <em class="parameter"><code>slice</code></em> is public. That is, <code class="function">bus1_pool_publish</code> has been
   called and the user has not released their reference, yet.
   </p><p>

   Note that if you need reliable results, you better make sure this cannot
   race calls to <code class="function">bus1_pool_publish</code> (or <code class="function">bus1_pool_release_user</code>,
   respectively). IOW, keep the owning peer locked.
</p></div><div class="refsect1"><a name="id-1.9.8.7"></a><h2>Return</h2><p>
   True if public, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-create"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_create — 
  create memory pool
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_pool_create </b>(</code>struct bus1_pool * <var class="pdparam">pool</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.9.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.9.6"></a><h2>Description</h2><p>
   Initialize a new pool object.
</p></div><div class="refsect1"><a name="id-1.9.9.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_destroy — 
     pool to destroy
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_pool_destroy </b>(</code>struct bus1_pool * <var class="pdparam">pool</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.10.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.10.6"></a><h2>Description</h2><p>
   This destroys a pool that was previously create via <code class="function">bus1_pool_create</code>. If
   NULL is passed, or if <em class="parameter"><code>pool</code></em>-&gt;f is NULL (i.e., the pool was initialized to 0
   but not created via <code class="function">bus1_pool_create</code>, yet), then this is a no-op.
   </p><p>

   The caller must make sure that no kernel reference to any slice exists. Any
   pending user-space reference to any slice is dropped by this function.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-alloc"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_alloc — 
     allocate memory
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_pool_slice * <b class="fsfunc">bus1_pool_alloc </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, size_t <var class="pdparam">size</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.11.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to allocate memory from
    </p></dd><dt><span class="term"><em class="parameter"><code>size</code></em></span></dt><dd><p>
     number of bytes to allocate
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.11.6"></a><h2>Description</h2><p>
   This allocates a new slice of <em class="parameter"><code>size</code></em> bytes from the memory pool at <em class="parameter"><code>pool</code></em>. The
   slice must be released via <code class="function">bus1_pool_release_kernel</code> by the caller. All
   slices are aligned to 8 bytes (both offset and size).
   </p><p>

   If no suitable slice can be allocated, an error is returned.
   </p><p>

   Each pool slice can have two different references, a kernel reference and a
   user-space reference. Initially, it only has a kernel-reference, which must
   be dropped via <code class="function">bus1_pool_release_kernel</code>. However, if you previously
   publish the slice via <code class="function">bus1_pool_publish</code>, it will also have a user-space
   reference, which user-space must (indirectly) release via a call to
   <code class="function">bus1_pool_release_user</code>.
   A slice is only actually freed if neither reference exists, anymore. Hence,
   pool-slice can be held by both, the kernel and user-space, and both can rely
   on it staying around as long as they wish.
</p></div><div class="refsect1"><a name="id-1.9.11.7"></a><h2>Return</h2><p>
   Pointer to new slice, or ERR_PTR on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-release-kernel"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_release_kernel — 
     release kernel-owned slice reference
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_pool_slice * <b class="fsfunc">bus1_pool_release_kernel </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.12.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to free memory on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to release
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.12.6"></a><h2>Description</h2><p>
   This releases the kernel-reference to a slice that was previously allocated
   via <code class="function">bus1_pool_alloc</code>. This only releases the kernel reference to the slice.
   If the slice was already published to user-space, then their reference is
   left untouched. Once both references are gone, the memory is actually freed.
</p></div><div class="refsect1"><a name="id-1.9.12.7"></a><h2>Return</h2><p>
   NULL is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-publish"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_publish — 
     publish a slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_pool_publish </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.13.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to publish
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.13.6"></a><h2>Description</h2><p>
   Publish a pool slice to user-space, so user-space can get access to it via
   the mapped pool memory. If the slice was already published, this is a no-op.
   Otherwise, the slice is marked as public and will only get freed once both
   the user-space reference *and* kernel-space reference are released.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-release-user"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_release_user — 
     release a public slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_pool_release_user </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, size_t <var class="pdparam">offset</var>, size_t * <var class="pdparam">n_slicesp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.14.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>
     offset of slice to release
    </p></dd><dt><span class="term"><em class="parameter"><code>n_slicesp</code></em></span></dt><dd><p>
     output variable to store number of released slices, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.14.6"></a><h2>Description</h2><p>
   Release the user-space reference to a pool-slice, specified via the offset
   of the slice. If both, the user-space reference *and* the kernel-space
   reference to the slice are gone, the slice will be actually freed.
   </p><p>

   If no slice exists with the given offset, or if there is no user-space
   reference to the specified slice, an error is returned.
</p></div><div class="refsect1"><a name="id-1.9.14.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-flush"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_flush — 
     flush all user references
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_pool_flush </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, size_t * <var class="pdparam">n_slicesp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.15.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to flush
    </p></dd><dt><span class="term"><em class="parameter"><code>n_slicesp</code></em></span></dt><dd><p>
     output variable to store number of released slices, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.15.6"></a><h2>Description</h2><p>
   This flushes all user-references to any slice in <em class="parameter"><code>pool</code></em>. Kernel references
   are left untouched.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-mmap"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_mmap — 
     mmap the pool
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_pool_mmap </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct vm_area_struct * <var class="pdparam">vma</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.16.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>vma</code></em></span></dt><dd><p>
     VMA to map to
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.16.6"></a><h2>Description</h2><p>
   This maps the pools shmem file to the provided VMA. Only read-only mappings
   are allowed.
</p></div><div class="refsect1"><a name="id-1.9.16.7"></a><h2>Return</h2><p>
   0 on success, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-write-iovec"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_write_iovec — 
     copy user memory to a slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">ssize_t <b class="fsfunc">bus1_pool_write_iovec </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var>, loff_t <var class="pdparam">offset</var>, struct iovec * <var class="pdparam">iov</var>, size_t <var class="pdparam">n_iov</var>, size_t <var class="pdparam">total_len</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to write to
    </p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>
     relative offset into slice memory
    </p></dd><dt><span class="term"><em class="parameter"><code>iov</code></em></span></dt><dd><p>
     iovec array, pointing to data to copy
    </p></dd><dt><span class="term"><em class="parameter"><code>n_iov</code></em></span></dt><dd><p>
     number of elements in <em class="parameter"><code>iov</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>total_len</code></em></span></dt><dd><p>
     total number of bytes to copy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.17.6"></a><h2>Description</h2><p>
   This copies the memory pointed to by <em class="parameter"><code>iov</code></em> into the memory slice <em class="parameter"><code>slice</code></em> at
   relative offset <em class="parameter"><code>offset</code></em> (relative to begin of slice).
</p></div><div class="refsect1"><a name="id-1.9.17.7"></a><h2>Return</h2><p>
   Numbers of bytes copied, negative error code on failure.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-pool-write-kvec"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_pool_write_kvec — 
     copy kernel memory to a slice
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">ssize_t <b class="fsfunc">bus1_pool_write_kvec </b>(</code>struct bus1_pool * <var class="pdparam">pool</var>, struct bus1_pool_slice * <var class="pdparam">slice</var>, loff_t <var class="pdparam">offset</var>, struct kvec * <var class="pdparam">iov</var>, size_t <var class="pdparam">n_iov</var>, size_t <var class="pdparam">total_len</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.9.18.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>pool</code></em></span></dt><dd><p>
     pool to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>slice</code></em></span></dt><dd><p>
     slice to write to
    </p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>
     relative offset into slice memory
    </p></dd><dt><span class="term"><em class="parameter"><code>iov</code></em></span></dt><dd><p>
     kvec array, pointing to data to copy
    </p></dd><dt><span class="term"><em class="parameter"><code>n_iov</code></em></span></dt><dd><p>
     number of elements in <em class="parameter"><code>iov</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>total_len</code></em></span></dt><dd><p>
     total number of bytes to copy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.9.18.6"></a><h2>Description</h2><p>
   This copies the memory pointed to by <em class="parameter"><code>iov</code></em> into the memory slice <em class="parameter"><code>slice</code></em> at
   relative offset <em class="parameter"><code>offset</code></em> (relative to begin of slice).
</p></div><div class="refsect1"><a name="id-1.9.18.7"></a><h2>Return</h2><p>
   Numbers of bytes copied, negative error code on failure.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="queue"></a>Chapter 8. Bus1 Queue</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue-node"><span class="phrase">struct bus1_queue_node</span></a></span><span class="refpurpose"> — 
  node into message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bus1-queue"><span class="phrase">struct bus1_queue</span></a></span><span class="refpurpose"> — 
     message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-init"><span class="phrase">bus1_queue_node_init</span></a></span><span class="refpurpose"> — 
     initialize queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-destroy"><span class="phrase">bus1_queue_node_destroy</span></a></span><span class="refpurpose"> — 
     destroy queue node
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-type"><span class="phrase">bus1_queue_node_get_type</span></a></span><span class="refpurpose"> — 
     query node type
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-get-timestamp"><span class="phrase">bus1_queue_node_get_timestamp</span></a></span><span class="refpurpose"> — 
     query node timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-queued"><span class="phrase">bus1_queue_node_is_queued</span></a></span><span class="refpurpose"> — 
     check whether a node is queued
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-node-is-staging"><span class="phrase">bus1_queue_node_is_staging</span></a></span><span class="refpurpose"> — 
     check whether a node is marked staging
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-tick"><span class="phrase">bus1_queue_tick</span></a></span><span class="refpurpose"> — 
     increment queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-sync"><span class="phrase">bus1_queue_sync</span></a></span><span class="refpurpose"> — 
     sync queue clock
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-is-readable"><span class="phrase">bus1_queue_is_readable</span></a></span><span class="refpurpose"> — 
     check whether a queue is readable
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-compare"><span class="phrase">bus1_queue_compare</span></a></span><span class="refpurpose"> — 
     comparator for queue ordering
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-init"><span class="phrase">bus1_queue_init</span></a></span><span class="refpurpose"> — 
  initialize queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-destroy"><span class="phrase">bus1_queue_destroy</span></a></span><span class="refpurpose"> — 
     destroy queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-flush"><span class="phrase">bus1_queue_flush</span></a></span><span class="refpurpose"> — 
     flush message queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-stage"><span class="phrase">bus1_queue_stage</span></a></span><span class="refpurpose"> — 
     stage queue entry with fresh timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-staged"><span class="phrase">bus1_queue_commit_staged</span></a></span><span class="refpurpose"> — 
     commit staged queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-commit-unstaged"><span class="phrase">bus1_queue_commit_unstaged</span></a></span><span class="refpurpose"> — 
     commit unstaged queue entry with new timestamp
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-remove"><span class="phrase">bus1_queue_remove</span></a></span><span class="refpurpose"> — 
     remove entry from queue
 </span></dt><dt><span class="refentrytitle"><a href="#API-bus1-queue-peek"><span class="phrase">bus1_queue_peek</span></a></span><span class="refpurpose"> — 
     peek first available entry
 </span></dt></dl></div><p>
   </p><p>
   (You are highly encouraged to read up on 'Lamport Timestamps', the
   concept of 'happened-before', and 'causal ordering'. The queue
   implementation has its roots in Lamport Timestamps, treating a set of local
   CPUs as a distributed system to avoid any global synchronization.)
   </p><p>
   A message queue is a FIFO, i.e., messages are linearly ordered by the time
   they were sent. Moreover, atomic delivery of messages to multiple queues are
   supported, without any global synchronization, i.e., the order of message
   delivery is consistent across queues.
   </p><p>
   Messages can be destined for multiple queues, hence, we need to be careful
   that all queues get a consistent partial order of incoming messages. We
   define the concept of `global order' to provide a basic set of guarantees.
   This global order is a partial order on the set of all messages. The order is
   defined as:
   </p><p>
   1) If a message B was queued *after* a message A, then: A &lt; B
   </p><p>
   2) If a message B was queued *after* a message A was dequeued, then: A &lt; B
   </p><p>
   3) If a message B was dequeued *after* it a message A on the same queue,
   then: A &lt; B
   </p><p>
   (Note: Causality is honored. `after' and `before' do not refer to the
   same task, nor the same queue, but rather any kind of
   synchronization between the two operations.)
   </p><p>
   The queue object implements this global order in a lockless fashion. It
   solely relies on a distributed clock on each queue. Each message to be sent
   causes a clock tick on the local clock and on all destination clocks.
   Furthermore, all clocks are synchronized, meaning they're fast-forwarded in
   case they're behind the highest of all participating peers. No global state
   tracking is involved.
   </p><p>
   During a message transaction, we first queue a message as 'staging' entry in
   each destination with a preliminary timestamp. This timestamp is explicitly
   odd numbered. Any odd numbered timestamp is considered 'staging' and causes
   *any* message ordered after it to be blocked until it is no longer staging.
   This allows us to queue the message in parallel with any racing multicast,
   and be guaranteed that all possible conflicts are blocked until we eventually
   commit a transaction. To commit a transaction (after all staging entries are
   queued), we choose the highest timestamp we have seen across all destinations
   and re-queue all our entries on each peer. Here we use a commit timestamp
   (even numbered).
   </p><p>
   With this in mind, we define that a client can only dequeue messages from
   its queue, which have an even timestamp. Furthermore, if there is a message
   queued with an odd timestamp that is lower than the even timestamp of
   another message, then neither message can be dequeued. They're considered to
   be in-flight conflicts. This guarantees that two concurrent multicast
   messages can be queued without any *global* locks, but either can only be
   dequeued by a peer if their ordering has been established (via commit
   timestamps).
   </p><p>
   NOTE: A fully committed message is not guaranteed to be ready to be dequeued
   as it may be blocked by a staging entry. This means that there is an
   arbitrary (though bounded) time from a message transaction completing
   when the queue may still appear to be empty. In other words, message
   transmission is not instantaneous. It would be possible to change this
   at the cost of shortly blocking each message transaction on all other
   conflicting tasks.
   </p><p>
   The queue implementation uses an rb-tree (ordered by timestamps and sender),
   with a cached pointer to the front of the queue. The front pointer is only
   set if the first entry in the queue is ready to be dequeued (that is, it has
   an even timestamp). If the first entry is not ready to be dequeued, or if the
   queue is empty, the front pointer is NULL.
</p><div class="refentry"><a name="API-struct-bus1-queue-node"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_queue_node — 
  node into message queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_queue_node {
  union {unnamed_union};
  struct kref ref;
  unsigned long sender;
  u64 timestamp_and_type;
};  </pre></div><div class="refsect1"><a name="id-1.10.15.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">{unnamed_union}</span></dt><dd><p>
anonymous
      </p></dd><dt><span class="term">ref</span></dt><dd><p>
reference counter
      </p></dd><dt><span class="term">sender</span></dt><dd><p>
sender tag
      </p></dd><dt><span class="term">timestamp_and_type</span></dt><dd><p>
message timestamp and type of parent object
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-struct-bus1-queue"></a><div class="titlepage"></div><div class="refnamediv"><p>struct bus1_queue — 
     message queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct bus1_queue {
  u64 clock;
  struct rb_node __rcu * front;
  struct rb_root messages;
};  </pre></div><div class="refsect1"><a name="id-1.10.16.5"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">clock</span></dt><dd><p>
   local clock (used for Lamport Timestamps)
      </p></dd><dt><span class="term">front</span></dt><dd><p>
   cached front entry
      </p></dd><dt><span class="term">messages</span></dt><dd><p>
   queued messages
      </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_init — 
     initialize queue node
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_node_init </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var>, unsigned int <var class="pdparam">type</var>, unsigned long <var class="pdparam">sender</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.17.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>type</code></em></span></dt><dd><p>
     message type
    </p></dd><dt><span class="term"><em class="parameter"><code>sender</code></em></span></dt><dd><p>
     sender tag
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.17.6"></a><h2>Description</h2><p>
   This initializes a previously unused node, and prepares it for use with a
   message queue. The initial ref-count is set to 1.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_destroy — 
     destroy queue node
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_node_destroy </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.18.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to destroy, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.18.6"></a><h2>Description</h2><p>
   This destroys a previously initialized queue node. This is a no-op and only
   serves as debugger, testing whether the node was properly unqueued before.
   This must not be called if there are still references left to the node. That
   is, this function should rather be called from your <code class="function">kref_put</code> callback.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-get-type"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_get_type — 
     query node type
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">unsigned int <b class="fsfunc">bus1_queue_node_get_type </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.19.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.19.6"></a><h2>Description</h2><p>
   This queries the node type that was provided via the node constructor. A
   node never changes its type during its entire lifetime.
   </p><p>

   The caller must lock the queue or own the queue-node.
</p></div><div class="refsect1"><a name="id-1.10.19.7"></a><h2>Return</h2><p>
   Type of <em class="parameter"><code>node</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-get-timestamp"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_get_timestamp — 
     query node timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_node_get_timestamp </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.20.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.20.6"></a><h2>Description</h2><p>
   This queries the node timestamp that is currently set on this node.
   </p><p>

   The caller must lock the queue or own the queue-node.
</p></div><div class="refsect1"><a name="id-1.10.20.7"></a><h2>Return</h2><p>
   Timestamp of <em class="parameter"><code>node</code></em> is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-is-queued"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_is_queued — 
     check whether a node is queued
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_node_is_queued </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.21.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.21.6"></a><h2>Description</h2><p>
   This checks whether a node is currently queued in a message queue. That is,
   the node was linked via <code class="function">bus1_queue_stage</code> and as not been dequeued, yet
   (both via <code class="function">bus1_queue_remove</code> or <code class="function">bus1_queue_flush</code>).
</p></div><div class="refsect1"><a name="id-1.10.21.7"></a><h2>Return</h2><p>
   True if <em class="parameter"><code>node</code></em> is currently queued.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-node-is-staging"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_node_is_staging — 
     check whether a node is marked staging
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_node_is_staging </b>(</code>struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.22.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     node to query, or NULL
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.22.6"></a><h2>Description</h2><p>
   This checks whether a given node is queued, but still marked staging. That
   means, the node has been put on the queue but there is still a transaction
   that pins it to commit it later.
</p></div><div class="refsect1"><a name="id-1.10.22.7"></a><h2>Return</h2><p>
   True if <em class="parameter"><code>node</code></em> is queued as staging entry.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-tick"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_tick — 
     increment queue clock
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_tick </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.23.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.23.6"></a><h2>Description</h2><p>
   This performs a clock-tick on <em class="parameter"><code>queue</code></em>. The clock is incremented by a full
   interval (+2). The caller is free to use both, the new value (even numbered)
   and its predecessor (odd numbered). Both are uniquely allocated to the
   caller.
   </p><p>

   The caller must lock the queue.
</p></div><div class="refsect1"><a name="id-1.10.23.7"></a><h2>Return</h2><p>
   New clock value is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-sync"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_sync — 
     sync queue clock
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_sync </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.24.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     timestamp to sync on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.24.6"></a><h2>Description</h2><p>
   This synchronizes the clock of <em class="parameter"><code>queue</code></em> with the externally provided timestamp
   <em class="parameter"><code>timestamp</code></em>. That is, the queue clock is fast-forwarded to <em class="parameter"><code>timestamp</code></em>, in
   case it is newer than the queue clock. Otherwise, nothing is done.
   </p><p>

   The passed in timestamp must be even.
   </p><p>

   The caller must lock the queue.
</p></div><div class="refsect1"><a name="id-1.10.24.7"></a><h2>Return</h2><p>
   New clock value is returned.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-is-readable"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_is_readable — 
     check whether a queue is readable
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_is_readable </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.25.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.25.6"></a><h2>Description</h2><p>
   This checks whether the given queue is readable.
   </p><p>

   Note that messages can have 3 different states:
   - staging: the message is part of an active transaction
   - committed: the message is fully committed, but might still be blocked by
   a staging message
   - ready: the message is committed and ready to be dequeued
   </p><p>

   This function checks that there is at least one ready entry.
</p></div><div class="refsect1"><a name="id-1.10.25.7"></a><h2>Return</h2><p>
   True if the queue is readable, false if not.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-compare"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_compare — 
     comparator for queue ordering
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">bus1_queue_compare </b>(</code>u64 <var class="pdparam">a_ts</var>, unsigned long <var class="pdparam">a_sender</var>, u64 <var class="pdparam">b_ts</var>, unsigned long <var class="pdparam">b_sender</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.26.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>a_ts</code></em></span></dt><dd><p>
     timestamp of first node to compare
    </p></dd><dt><span class="term"><em class="parameter"><code>a_sender</code></em></span></dt><dd><p>
     sender tag of first node to compare
    </p></dd><dt><span class="term"><em class="parameter"><code>b_ts</code></em></span></dt><dd><p>
     timestamp of second node to compare against
    </p></dd><dt><span class="term"><em class="parameter"><code>b_sender</code></em></span></dt><dd><p>
     sender tag of second node to compare against
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.26.6"></a><h2>Description</h2><p>
   Messages on a message queue are ordered. This function implements the
   comparator used for all message ordering in queues. Two tags are used for
   ordering, the timestamp and the sender-tag of a node. Both must be passed to
   this function.
   </p><p>

   This compares the tuples (<em class="parameter"><code>a_ts</code></em>, <em class="parameter"><code>a_sender</code></em>) and (<em class="parameter"><code>b_ts</code></em>, <em class="parameter"><code>b_sender</code></em>).
</p></div><div class="refsect1"><a name="id-1.10.26.7"></a><h2>Return</h2><p>
   &lt;0 if (<em class="parameter"><code>a_ts</code></em>, <em class="parameter"><code>a_sender</code></em>) is ordered before, 0 if the same, &gt;0 if
   ordered after.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-init"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_init — 
  initialize queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_init </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.27.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to initialize
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.27.6"></a><h2>Description</h2><p>
   This initializes a new queue. The queue memory is considered uninitialized,
   any previous content is unrecoverable.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-destroy"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_destroy — 
     destroy queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_destroy </b>(</code>struct bus1_queue * <var class="pdparam">queue</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.28.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to destroy
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.28.6"></a><h2>Description</h2><p>
   This destroys a queue that was previously initialized via <code class="function">bus1_queue_init</code>.
   The caller must make sure the queue is empty before calling this.
   </p><p>

   This function is a no-op, and only does safety checks on the queue. It is
   safe to call this function multiple times on the same queue.
   </p><p>

   The caller must guarantee that the backing memory of <em class="parameter"><code>queue</code></em> is freed in an
   rcu-delayed manner.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-flush"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_flush — 
     flush message queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_flush </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, struct list_head * <var class="pdparam">list</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.29.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to flush
    </p></dd><dt><span class="term"><em class="parameter"><code>list</code></em></span></dt><dd><p>
     list to put flushed messages to
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.29.6"></a><h2>Description</h2><p>
   This flushes all entries from <em class="parameter"><code>queue</code></em> and puts them into <em class="parameter"><code>list</code></em> (no particular
   order) for the caller to clean up. All the entries returned in <em class="parameter"><code>list</code></em> must be
   unref'ed by the caller.
   </p><p>

   The caller must lock the queue.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-stage"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_stage — 
     stage queue entry with fresh timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">u64 <b class="fsfunc">bus1_queue_stage </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, wait_queue_head_t * <var class="pdparam">waitq</var>, struct bus1_queue_node * <var class="pdparam">node</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.30.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait queue to use for wake-ups, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to stage
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     minimum timestamp for <em class="parameter"><code>node</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.30.6"></a><h2>Description</h2><p>
   Link a queue entry with a new timestamp. The staging entry blocks all
   messages with timestamps synced on this queue in the future, as well as any
   messages with a timestamp greater than <em class="parameter"><code>timestamp</code></em>. However, it does not block
   any messages already committed to this queue.
   </p><p>

   The caller must provide an even timestamp and the entry may not already have
   been committed.
   </p><p>

   The queue owns its own reference to the node, so the caller retains their
   reference after this call returns.
   </p><p>

   The caller must lock the queue.
</p></div><div class="refsect1"><a name="id-1.10.30.7"></a><h2>Return</h2><p>
   The timestamp used.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-commit-staged"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_commit_staged — 
     commit staged queue entry with new timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_commit_staged </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, wait_queue_head_t * <var class="pdparam">waitq</var>, struct bus1_queue_node * <var class="pdparam">node</var>, u64 <var class="pdparam">timestamp</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.31.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait queue to use for wake-ups, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to commit
    </p></dd><dt><span class="term"><em class="parameter"><code>timestamp</code></em></span></dt><dd><p>
     new timestamp for <em class="parameter"><code>node</code></em>
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.31.6"></a><h2>Description</h2><p>
   Update a queue entry according to <em class="parameter"><code>timestamp</code></em>. If the queue entry is already
   staged on the queue, it is updated and sorted according to <em class="parameter"><code>timestamp</code></em>.
   Otherwise, nothing is done.
   </p><p>

   The caller must provide an even timestamp and the entry may not already have
   been committed.
   </p><p>

   Furthermore, the queue clock must be synced with the new timestamp *before*
   staging an entry. Similarly, the timestamp of an entry can only be
   increased, never decreased.
   </p><p>

   The queue owns its own reference to the node, so the caller retains their
   reference after this call returns.
   </p><p>

   The caller must lock the queue.
</p></div><div class="refsect1"><a name="id-1.10.31.7"></a><h2>Return</h2><p>
   True if the entry was committed, false otherwise.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-commit-unstaged"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_commit_unstaged — 
     commit unstaged queue entry with new timestamp
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">bus1_queue_commit_unstaged </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, wait_queue_head_t * <var class="pdparam">waitq</var>, struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.32.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait queue to use for wake-ups, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to commit
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.32.6"></a><h2>Description</h2><p>
   Directly commit an unstaged queue entry to the destination queue. If the
   queue entry is already, nothing is done.
   </p><p>

   The destination queue is ticked and the resulting timestamp is used to commit
   the queue entry.
   </p><p>

   The queue owns its own reference to the node, so the caller retains their
   reference after this call returns.
   </p><p>

   The caller must lock the queue.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-remove"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_remove — 
     remove entry from queue
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">bool <b class="fsfunc">bus1_queue_remove </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, wait_queue_head_t * <var class="pdparam">waitq</var>, struct bus1_queue_node * <var class="pdparam">node</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.33.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>waitq</code></em></span></dt><dd><p>
     wait queue to use for wake-ups, or NULL
    </p></dd><dt><span class="term"><em class="parameter"><code>node</code></em></span></dt><dd><p>
     queue entry to remove
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.33.6"></a><h2>Description</h2><p>
   This unlinks <em class="parameter"><code>node</code></em> and fully removes it from the queue <em class="parameter"><code>queue</code></em>. You must
   never reuse that node again, once removed.
   </p><p>

   If <em class="parameter"><code>node</code></em> was still in staging, this call might uncover a new front entry and
   as such turn the queue readable. Hence, the caller *must* handle its return
   value.
   </p><p>

   The queue will drop its reference to the node, but rely on the caller to
   have a reference on their own (which is implied by passing <em class="parameter"><code>node</code></em> as argument
   to this function). The caller retains their reference after this call
   returns.
   </p><p>

   The caller must lock the queue.
</p></div><div class="refsect1"><a name="id-1.10.33.7"></a><h2>Return</h2><p>
   True if removed by this call, false if already removed.
</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="API-bus1-queue-peek"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1_queue_peek — 
     peek first available entry
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">struct bus1_queue_node * <b class="fsfunc">bus1_queue_peek </b>(</code>struct bus1_queue * <var class="pdparam">queue</var>, bool * <var class="pdparam">continuep</var><code>)</code>;</p></div></div><div class="refsect1"><a name="id-1.10.34.5"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue to operate on
    </p></dd><dt><span class="term"><em class="parameter"><code>continuep</code></em></span></dt><dd><p>
     output variable to store continue-state of peeked node
    </p></dd></dl></div></div><div class="refsect1"><a name="id-1.10.34.6"></a><h2>Description</h2><p>
   This returns a reference to the first available entry in the given queue, or
   NULL if there is none. The queue stays unmodified and the returned entry
   remains on the queue.
   </p><p>

   This only returns entries that are ready to be dequeued. Entries that are
   still in staging mode will not be considered.
   </p><p>

   If a node is returned, the continue-state of that node is stored in
   <em class="parameter"><code>continuep</code></em>. The continue-state describes whether there are more nodes queued
   that are part of the same transaction.
   </p><p>

   The caller must lock the queue.
</p></div><div class="refsect1"><a name="id-1.10.34.7"></a><h2>Return</h2><p>
   Reference to first available entry, NULL if none available.
</p></div></div></div></div></body></html>
