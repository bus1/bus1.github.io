<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>bus1.pool</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><a href="/"><img src="/bus1.png" alt="bus1" style="width:48px;height:48px;"></a><span style="float:right">Version 1</span><hr><div class="refentry"><a name="bus1.pool"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>bus1.pool â€” bus1 pool</p></div><div class="refsect1"><a name="id-1.4"></a><h2>Description</h2><p>
      A pool for received message payloads is installed for every
      <span class="emphasis"><em>peer</em></span>, and is sized according to the information
      stored in the <code class="varname">pool_size</code> member of
      <span class="type">struct bus_cmd_peer_init</span> or
      <span class="type">struct bus1_cmd_peer_clone</span>
      when calling <code class="constant">BUS1_CMD_PEER_INIT</code> or
      <code class="constant">BUS1_CMD_PEER_CLONE</code>, respectively. Internally, the
      pool is segmented into <span class="emphasis"><em>slices</em></span>, each referenced by its
      <span class="emphasis"><em>offset</em></span> in the pool, expressed in <span class="type">bytes</span>.
      See
      <a href="bus1.peer.html"><span class="citerefentry"><span class="refentrytitle">bus1.peer</span>(7)</span></a>
      for more information about <code class="constant">BUS1_CMD_PEER_INIT</code> and
      <code class="constant">BUS1_CMD_PEER_CLONE</code>.
    </p><p>
      The pool is written to by the kernel when one of the following
      <span class="emphasis"><em>ioctls</em></span> is issued:

      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">BUS1_CMD_SEND</code></span></dt><dd><p>
            ... to instantiate the message payload
          </p></dd><dt><span class="term"><code class="constant">BUS1_CMD_RECV</code></span></dt><dd><p>
            ... to instantiate the file-descriptor and handle numbers passed
            with a message
          </p></dd></dl></div><p>

    </p><p>
      The <code class="varname">offset</code> field returned by
      <code class="constant">BUS1_CMD_RECV</code> describes the offset inside the pool.
      In order to make the slice available for subsequent calls,
      <code class="constant">BUS1_CMD_SLICE_RELEASE</code> has to be called on that
      offset (see below). Otherwise, the pool will fill up, and the peer will
      not be able to receive any more information through its pool.
    </p></div><div class="refsect1"><a name="id-1.5"></a><h2>Pool slice allocation</h2><p>
      Pool slices are allocated by the kernel in order to deliver messages to a
      peer. Allocation of pool slices cannot be initiated by userspace.
    </p><p>
      In order to protect against peers filling up each other's pools, a
      per-user quota is applied to the slice allocation. Once a slice has been
      returned to userspace from a <code class="constant">BUS1_CMD_RECV</code> call, the
      slice is owned by the receiving peer and as such is not subject to any
      quota. The remaning space in the pool is partitioned up by considering
      that at any point in time a given user may use up to half the available
      space in the pool not used by any other user.
    </p></div><div class="refsect1"><a name="id-1.6"></a><h2>Accessing the pool memory</h2><p>
      Memory in the pool is read-only for userspace and may only be written
      to by the kernel. To read from the pool memory, the caller is expected to
      <a href="mmap.html"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a>
      the buffer into its task, like this:
    </p><pre class="programlisting">
uint8_t *buf = mmap(NULL, size, PROT_READ, MAP_SHARED, peer_fd, 0);
    </pre><p>
      In order to map the entire pool, the <code class="varname">size</code> parameter in
      the example above should be set to the value of the
      <code class="varname">pool_size</code> member of
      <span class="type">struct bus1_cmd_peer_init</span> or
      <span class="type">struct bus1_cmd_peer_clone</span> when
      <code class="constant">BUS1_CMD_PEER_INIT</code> or
      <code class="constant">BUS1_CMD_PEER_CLONE</code> was employed to create the peer
      (see above).
    </p><p>
      The <span class="emphasis"><em>file descriptor</em></span> used to map the memory must be
      the one that was used to create the <span class="emphasis"><em>peer</em></span>.
      In other words, the one that was used to call
      <code class="constant">BUS1_CMD_PEER_INIT</code>, or the one returned as the
      <code class="varname">fd</code> member of <span class="type">struct bus1_cmd_peer_clone</span>
      when <code class="constant">BUS1_CMD_PEER_CLONE</code> was used to create the peer.
      See
      <a href="bus1.peer.html"><span class="citerefentry"><span class="refentrytitle">bus1.peer</span>(7)</span></a>
      for more details.
    </p><p>
      Alternatively, instead of mapping the entire pool buffer, only parts
      of it can be mapped. Every bus1 command that returns an
      <span class="emphasis"><em>offset</em></span> (see above) also reports a
      <span class="emphasis"><em>size</em></span> along with it, so programs can be written
      in a way that it only maps portions of the pool to access a specific
      <span class="emphasis"><em>slice</em></span>.
    </p><p>
      When access to the pool memory is no longer needed, programs should
      call <code class="function">munmap()</code> on the pointer returned by
      <code class="function">mmap()</code>.
    </p></div><div class="refsect1"><a name="id-1.7"></a><h2>Freeing pool slices</h2><p>
      The <code class="constant">BUS1_CMD_SLICE_RELEASE</code> ioctl is used to free a
      slice inside the pool, describing an offset that was returned in an
      <code class="varname">offset</code> field of another ioctl struct.
      The <code class="constant">BUS1_CMD_SLICE_RELEASE</code> command takes a
      <span class="type">__u64</span> as argument, which is the offset to the slice being
      freed.
    </p></div><div class="refsect1"><a name="id-1.8"></a><h2>Return value</h2><p>
      On success, all mentioned ioctl commands return <span class="errorcode">0</span>;
      on error, <span class="errorcode">-1</span> is returned, and
      <code class="varname">errno</code> is set to indicate the error.
      If the issued ioctl is illegal for the file descriptor used,
      <code class="varname">errno</code> will be set to <code class="constant">ENOTTY</code>.
    </p></div><div class="refsect1"><a name="id-1.9"></a><h2>See Also</h2><span class="simplelist">
        <a href="bus1.html"><span class="citerefentry"><span class="refentrytitle">bus1</span>(7)</span></a>
      , 
        <a href="bus1.peer.html"><span class="citerefentry"><span class="refentrytitle">bus1.peer</span>(7)</span></a>
      , 
        <a href="bus1.message.html"><span class="citerefentry"><span class="refentrytitle">bus1.message</span>(7)</span></a>
      , 
        <a href="mmap.html"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a>
        , 
        <a href="munmap.html"><span class="citerefentry"><span class="refentrytitle">munmap</span>(2)</span></a>
      </span></div></div></body></html>
