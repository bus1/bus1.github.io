<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>bus1.node</title><link rel="stylesheet" type="text/css" href="bus1.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="icon" href="bus1.png" type="image/png"><script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75729104-1', 'auto');
      ga('send', 'pageview');
    </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><header><a href="index.html"><img src="bus1.svg" alt="bus1" style="width:64px;height:64px;"></a><span class="version">Version 1</span></header><div class="refentry"><a name="bus1.node"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1.node â€” Bus Node</p></div><div class="refsect1"><a name="id-1.4"></a><h2>Description</h2><p>
      Messages are sent to <span class="emphasis"><em>nodes</em></span>. A node is a kernel object
      owned by a peer, and messages destined for a node will be received by the
      peer that owns the node.
    </p><p>
      A handle is a reference to a node, and there is no other way to refer to a
      node than by one of its handles. A handle is local to its holder, and is
      how the holder of a handle is connected to the owner of the corresponding
      node. When sending a message, the (possibly remote) destination nodes of
      the message are represented by (local) handles referring to the node.
    </p><p>
      A handle may be passed from one peer to another, just like
      file-descriptors are passed over UDS (or bus1 for that matter). When
      passing a handle a copy of it is installed in the destination peer which
      references the same underlying node. There is otherwise no relation
      between the original and the passed handle. Handles are reference counted,
      so the kernel keeps track of how many times a peer holds a given handle.
    </p></div><div class="refsect1"><a name="id-1.5"></a><h2>Handle ids</h2><p>
      Handles are referred to in userspace by their handle ids, like
      file-descriptors are referenced by file-descriptor number. The handle id
      namespace is local to a given peer (rather than a given process), and has
      no meaning outside of it. A handle only ever has one handle id associated
      with it, and a handle id is never reused to refer to two handles. In
      particular, if all the references to a handle are released and a new
      handle is received to the same node, it is guaranteed to be assigned a
      fresh handle id, unless the peer owns the underlying node (see below).
    </p></div><div class="refsect1"><a name="id-1.6"></a><h2>Node ids</h2><p>
      Nodes can not be referenced directly, but only through their handles. The
      owner of a node will initially also hold a handle to that node. However,
      the handle can be released, and the owner of a node does not need to own
      a handle to it. Even after the handle has potentially been released the
      handle id will be used whenever referring to the underlying node, and if
      a peer receives a handle to a node it owns the original handle id will
      always be reused.
    </p></div><div class="refsect1"><a name="id-1.7"></a><h2>Node creation</h2><p>
      Nodes can be created on-the-fly by setting the
      <code class="constant">BUS1_NODE_FLAG_ALLOCATE</code> flag in any handle ID passed
      to the kernel. In this case a new node owned by the sending peer is
      created as well as a new handle held by the sending peer. The newly
      allocated handle ID is returned to userspace by overwriting the passed in
      handle ID.
    </p><p>
      The <code class="constant">BUS1_NODE_FLAG_MANAGED</code> flag must be set when
      creating a node on-the-fly, this indicates that the kernel should allocate
      the next available handle ID in its namespace. No other allocation scheme
      is currently supported, so this flag must be set when allocating a new
      node. This may change in the future.
    </p><p>
      The optional <code class="constant">BUS1_NODE_FLAG_PERSISTENT</code> flag indicates
      that the created node should not be destroyed in case the peer is reset.
    </p></div><div class="refsect1"><a name="id-1.8"></a><h2>Reachability</h2><p>
      A peer can only send a message to another peer if it holds a handle to one
      of its nodes. A handle to a node can be obtained from another peer who
      holds such a handle by passing it with a message. It follows that two
      peers that are disconnected (i.e., there are no path of handles, nodes and
      peers from one to the other) can never become connected and can never
      communicate. In order to make it possible for any peers to communicate at
      all, the <code class="constant">BUS1_CMD_PEER_CLONE</code> ioctl allows a new peer
      to be created from an existing one and a handle to be passed from the
      origina to the new peer in such a way that they are connected at creation.
    </p></div><div class="refsect1"><a name="id-1.9"></a><h2>Handle lifetime and scope</h2><p>
      A peer can hold at most one handle to a given node at a time, though the
      handle is reference counted. A handle first becomes valid when the peer
      receives it with a message or creates it, and the peer gains additional
      references to the handle each time it receives it. The handle remains
      valid until the peer either drops the last reference to it or receives a
      destruction notification for the handle.
    </p></div><div class="refsect1"><a name="id-1.10"></a><h2>Releasing a handle</h2><p>
      A reference to a handle can be released by calling the
      <code class="constant">BUS1_CMD_HANDLE_RELEASE</code> ioctl. The ioctl takes an
      <span class="type">__u64</span> as argument, which is the handle id of the handle to be
      released. When the last reference to a handle is released the handle id is
      no longer valid, and any future handle to the same node will be assigned
      a new handle id. Moreover, when the last reference to the last handle to a
      given node is released, a release notification is sent to the node.
      The notification is ordered as if the release ioctl was a unicast message
      sent from the holder of the hanlde to the owner of the node. Any message
      ordered before the release notification is unaffected by it, and once a
      peer receives a release notification it is guaranteed that nobody holds
      a handle to the node, and hence no future messages can be sent to it,
      unless the owner of the node hands out a fresh handle to it.
    </p><p>
      It is worth noting that a handle may be in-flight, i.e., it has been sent
      from one peer to another without the destination peer receiving it yet.
      This may cause a situation where no peer holds a handle to a node, but no
      release notification has been queued as there are in-flight handles still
      pinning it.
    </p></div><div class="refsect1"><a name="id-1.11"></a><h2>Destroying a node</h2><p>
      The owner of a node can destroy the node explicitly by calling the
      <code class="constant">BUS1_CMD_NODE_DESTROY</code> ioctl. The ioctl takes an
      <span class="type">__u64</span> as argument, which is the original handle id associated
      with the node to be destroyed. A destruction notification is sent to all
      peers that hold a handle to the node. The destruction notification is
      ordered as if it were a multicast message from the owner of the node to
      all the holders of the handles. Any message to the node that is ordered
      before the destruction notification is guaranteed to be delivered, and so
      is any handle that is passed along with a message delivered before the
      destruction notification it. No message may be delivered to the node
      ordered after the destruction notification and any handle passed after the
      destruction notification is replaced by
      <code class="constant">BUS1_HANDLE_INVALID</code>. A local handle to a node is
      valid until its destruction notification is received though actual
      operations on it may fail.
    </p></div><div class="refsect1"><a name="id-1.12"></a><h2>Return value</h2><p>
      On success, all mentioned ioctl commands return <span class="errorcode">0</span>;
      on error, <span class="errorcode">-1</span> is returned, and
      <code class="varname">errno</code> is set to indicate the error. See
      <a href="bus1.html"><span class="citerefentry"><span class="refentrytitle">bus1</span>(7)</span></a>
      for a list of possible error codes, in addition to the ones listed below.
    </p><div class="refsect2"><a name="id-1.12.3"></a><h3>
        <code class="constant">BUS1_CMD_NODE_DESTROY</code> and
        <code class="constant">BUS1_CMD_HANDLE_RELEASE</code> may fail with the following
        errors
      </h3><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">ENXIO</code></span></dt><dd><p>
            The handle id is invalid.
          </p></dd></dl></div></div></div><div class="refsect1"><a name="id-1.13"></a><h2>See Also</h2><span class="simplelist">
        <a href="bus1.html"><span class="citerefentry"><span class="refentrytitle">bus1</span>(7)</span></a>
      , 
        <a href="bus1.peer.html"><span class="citerefentry"><span class="refentrytitle">bus1.peer</span>(7)</span></a>
      , 
        <a href="bus1.message.html"><span class="citerefentry"><span class="refentrytitle">bus1.message</span>(7)</span></a>
      </span></div></div></body></html>
