<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>bus1</title><link rel="stylesheet" type="text/css" href="bus1.css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></meta><link xmlns="" rel="icon" href="bus1.png" type="image/png"><script xmlns="">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75729104-1', 'auto');
      ga('send', 'pageview');
    </script></head><body><header xmlns=""><a href="/"><img src="bus1.svg" alt="bus1" style="width:48px;height:48px;"></a><span class="version">Version 1</span></header><div class="refentry"><a id="bus1"></a><div class="titlepage"></div><div class="refnamediv"><p>bus1 â€” Kernel Message Bus</p></div><div class="refsect1"><a id="id-1.4"></a><h2>Synopsis</h2><p>
      bus1 is an inter-process communication bus system controlled by the
      kernel. It provides user-space with an API to create peers and send
      unicast and multicast messages between them. It does not enforce any
      layout on the transmitted data, but only provides the transport layer used
      for message interchange between peers.
    </p><p>
      This set of man-pages gives a comprehensive overview of the kernel-level
      API, with all ioctl commands, associated structs and bit masks. However,
      most people will not use this API level directly, but rather let one of
      the high-level abstraction libraries help them integrate bus functionality
      into their applications.
    </p></div><div class="refsect1"><a id="id-1.5"></a><h2>Description</h2><p>
      bus1 provides a character device at <code class="filename">/dev/bus1</code>. Any
      advanced operations are done via <code class="function">ioctl()</code> on this
      file.
    </p></div><div class="refsect1"><a id="id-1.6"></a><h2>Terminology</h2><div class="refsect2"><a id="id-1.6.2"></a><h3>Peer</h3><p>
        A peer is a client on the bus that can send or receive messages. A peer
        is represented by a file-descriptor created by opening
        <code class="filename">/dev/bus1</code> or by cloning an existing peer. See
        <a xmlns="" href="bus1.peer.html"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">bus1.peer</span>(7)</span></a>
        for more details.
      </p></div><div class="refsect2"><a id="id-1.6.3"></a><h3>Node</h3><p>
        A node is a representation of a generic object owend by a peer. A peer
        may own several nodes and their primary function is to be the recipient
        of messages. See
        <a xmlns="" href="bus1.node.html"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">bus1.node</span>(7)</span></a>
        for more details.
      </p></div><div class="refsect2"><a id="id-1.6.4"></a><h3>Handle</h3><p>
        A handle is a reference to a node. A peer may hold several handles, both
        to nodes owned by itself and nodes owned by other peers. The destination
        of a message is always a handle, meaning the message will be delivered
        to the owner of the node the handle is referencing. A handle is local to
        its holder, but a copy of a handle may be passed from one peer to
        another along with a message. See
        <a xmlns="" href="bus1.node.html"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">bus1.node</span>(7)</span></a>
        for more details.
      </p></div><div class="refsect2"><a id="id-1.6.5"></a><h3>Pool</h3><p>
        Each peer allocates a piece of shmem-backed memory that is used to
        receive messages. It is never used for sending. In order to access that
        memory, an application must <code class="function">mmap()</code> it into its
        address space. See
        <a xmlns="" href="bus1.pool.html"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">bus1.pool</span>(7)</span></a>
        for more details.
      </p></div><div class="refsect2"><a id="id-1.6.6"></a><h3>Message</h3><p>
        Peers can exchange messages with other peers by addressing the peers
        with handles to their nodes. A message consists of a logical byte stream
        of arbitrary size. Messages can carry additional file descriptors or
        handles to nodes to be passed from one peer to another, just like
        passing file descriptors over UNIX domain sockets. See
        <a xmlns="" href="bus1.message.html"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">bus1.message</span>(7)</span></a>
        for more details.
      </p></div></div><div class="refsect1"><a id="id-1.7"></a><h2>The ioctl interface</h2><p>
       As stated in the 'synopsis' section above, application developers are
       strongly encouraged to use bus1 through a the high-level abstraction
       library, rather than using the low-level API directly.
    </p><p>
      bus1 on the kernel level exposes its functions exclusively through
      <a xmlns="" href="http://linux.die.net/man/2/ioctl"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a>,
      employed on file descriptors returned by
      <a xmlns="" href="http://linux.die.net/man/2/open"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">open</span>(2)</span></a>
      on <code class="filename">/dev/bus1</code> or by the
      <code class="constant">BUS1_CMD_PEER_CLONE</code> ioctl described below.
    </p><p>
      Following is a list of all the ioctls, along with the command structs they
      must be used with.
    </p><div class="informaltable"><table border="0"><colgroup><col></col><col></col><col></col></colgroup><thead><tr><th>ioctl signature</th><th>command</th><th>transported struct</th></tr></thead><tbody><tr><td><code class="constant">0x0</code></td><td><code class="constant">BUS1_CMD_PEER_INIT</code></td><td><span class="type">struct bus1_cmd_peer_init *</span></td></tr><tr><td><code class="constant">0x0</code></td><td><code class="constant">BUS1_CMD_PEER_QUERY</code></td><td><span class="type">struct bus1_cmd_peer_init *</span></td></tr><tr><td><code class="constant">0x0</code></td><td><code class="constant">BUS1_CMD_PEER_RESET</code></td><td><span class="type">struct bus1_cmd_peer_reset *</span></td></tr><tr><td><code class="constant">0x0</code></td><td><code class="constant">BUS1_CMD_PEER_CLONE</code></td><td><span class="type">struct bus1_cmd_peer_clone *</span></td></tr><tr><td><code class="constant">0x0</code></td><td><code class="constant">BUS1_CMD_NODE_DESTROY</code></td><td><span class="type">__u64</span></td></tr><tr><td><code class="constant">0x0</code></td><td><code class="constant">BUS1_CMD_HANDLE_RELEASE</code></td><td><span class="type">__u64</span></td></tr><tr><td><code class="constant">0x0</code></td><td><code class="constant">BUS1_CMD_SLICE_RELEASE</code></td><td><span class="type">__u64</span></td></tr><tr><td><code class="constant">0x0</code></td><td><code class="constant">BUS1_CMD_SEND</code></td><td><span class="type">struct bus1_cmd_send *</span></td></tr><tr><td><code class="constant">0x0</code></td><td><code class="constant">BUS1_CMD_RECV</code></td><td><span class="type">struct bus1_cmd_recv *</span></td></tr></tbody></table></div><p>
      These ioctls, along with the structs they transport, are explained in
      detail in the other documents linked to in the "See Also" section below.
    </p></div><div class="refsect1"><a id="id-1.8"></a><h2>Return values</h2><p>
      On success all bus1 ioctls return <span class="errorcode">0</span>; on failure,
      <span class="errorcode">-1</span> is returned and <code class="varname">errno</code> set to
      indicate the error.
    </p><div class="refsect2"><a id="id-1.8.3"></a><h3>
        The following error codes are well defined and used throughout
      </h3><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">ENOMEM</code></span></dt><dd><p>
            Out of kernel memory.
          </p></dd><dt><span class="term"><code class="constant">EFAULT</code></span></dt><dd><p>
            Cannot acces ioctl parameters.
          </p></dd><dt><span class="term"><code class="constant">EINVAL</code></span></dt><dd><p>
            Invalid parameters.
          </p></dd><dt><span class="term"><code class="constant">EMSGSIZE</code></span></dt><dd><p>
            Parameters are too large or too small.
          </p></dd><dt><span class="term"><code class="constant">ENOTTY</code></span></dt><dd><p>
            Unknown ioctl.
          </p></dd><dt><span class="term"><code class="constant">ENXIO</code></span></dt><dd><p>
            Destination handle does not exist.
          </p></dd><dt><span class="term"><code class="constant">ESHUTDOWN</code></span></dt><dd><p>
            Local peer was already disconnected.
          </p></dd><dt><span class="term"><code class="constant">ENOTCONN</code></span></dt><dd><p>
            Local peer is not initialized.
          </p></dd><dt><span class="term"><code class="constant">EISCONN</code></span></dt><dd><p>
            Local peer is already initialized.
          </p></dd><dt><span class="term"><code class="constant">EXFULL</code></span></dt><dd><p>
            Target memory pool is full.
          </p></dd><dt><span class="term"><code class="constant">ESTALE</code></span></dt><dd><p>
            Referenced node has no local handles.
          </p></dd><dt><span class="term"><code class="constant">EINPROGRESS</code></span></dt><dd><p>
            Node destruction already in progress.
          </p></dd><dt><span class="term"><code class="constant">EDQUOT</code></span></dt><dd><p>
            Quota exceeded.
          </p></dd><dt><span class="term"><code class="constant">EBADFD</code></span></dt><dd><p>
            Invalid file-descriptor.
          </p></dd><dt><span class="term"><code class="constant">EPERM</code></span></dt><dd><p>
            Permission denied.
          </p></dd><dt><span class="term"><code class="constant">EAGAIN</code></span></dt><dd><p>
            No messages ready to be dequeued.
          </p></dd><dt><span class="term"><code class="constant">ETOOMANYREFS</code></span></dt><dd><p>
            User has too many in-flight file-descriptors.
          </p></dd><dt><span class="term"><code class="constant">EOPNOTSUPP</code></span></dt><dd><p>
            Could not pass file-descriptor of unsupported type.
          </p></dd></dl></div></div></div><div class="refsect1"><a id="id-1.9"></a><h2>See Also</h2><span class="simplelist">
        <a xmlns="" href="bus1.peer.html"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">bus1.peer</span>(7)</span></a>
      , 
        <a xmlns="" href="bus1.node.html"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">bus1.node</span>(7)</span></a>
      , 
        <a xmlns="" href="bus1.message.html"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">bus1.message</span>(7)</span></a>
      , 
        <a xmlns="" href="bus1.pool.html"><span xmlns="http://www.w3.org/1999/xhtml" class="citerefentry"><span class="refentrytitle">bus1.pool</span>(7)</span></a>
      </span></div></div></body></html>
